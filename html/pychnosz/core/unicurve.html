<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pychnosz.core.unicurve API documentation</title>
<meta name="description" content="CHNOSZ unicurve() function - Calculate univariant curves for geothermometry/geobarometry …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pychnosz.core.unicurve</code></h1>
</header>
<section id="section-intro">
<p>CHNOSZ unicurve() function - Calculate univariant curves for geothermometry/geobarometry.</p>
<p>This module implements functions to solve for temperatures or pressures of equilibration
for a given logK value, producing univariant curves useful for aqueous geothermometry
and geobarometry applications.</p>
<p>Author: Based on pyCHNOSZ univariant.r by Grayson Boyer
Optimized: Uses scipy.optimize.brentq() for efficient root-finding</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pychnosz.core.unicurve.unicurve"><code class="name flex">
<span>def <span class="ident">unicurve</span></span>(<span>logK: int | float | List[int | float],<br>species: str | List[str] | int | List[int],<br>coeff: int | float | List[int | float],<br>state: str | List[str],<br>pressures: float | List[float] = 1,<br>temperatures: float | List[float] = 25,<br>IS: float = 0,<br>minT: float = 0.1,<br>maxT: float = 100,<br>minP: float = 1,<br>maxP: float = 500,<br>tol: float | None = None,<br>solve: str = 'T',<br>messages: bool = True,<br>show: bool = True,<br>plot_it: bool = True,<br>width: int = 600,<br>height: int = 400,<br>res: int = 200) ‑> <a title="pychnosz.core.unicurve.UnivariantResult" href="#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a> | List[<a title="pychnosz.core.unicurve.UnivariantResult" href="#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unicurve(logK: Union[float, int, List[Union[float, int]]],
             species: Union[str, List[str], int, List[int]],
             coeff: Union[int, float, List[Union[int, float]]],
             state: Union[str, List[str]],
             pressures: Union[float, List[float]] = 1,
             temperatures: Union[float, List[float]] = 25,
             IS: float = 0,
             minT: float = 0.1,
             maxT: float = 100,
             minP: float = 1,
             maxP: float = 500,
             tol: Optional[float] = None,
             solve: str = &#34;T&#34;,
             messages: bool = True,
             show: bool = True,
             plot_it: bool = True,
             width: int = 600,
             height: int = 400,
             res: int = 200) -&gt; Union[UnivariantResult, List[UnivariantResult]]:
    &#34;&#34;&#34;
    Solve for temperatures or pressures of equilibration for a given logK value(s).

    This function calculates univariant curves useful for aqueous geothermometry
    and geobarometry. Given a measured equilibrium constant (logK) for a reaction,
    it solves for the temperatures (at specified pressures) or pressures (at
    specified temperatures) where the reaction would produce that logK value.

    The solver uses scipy.optimize.brentq (Brent&#39;s method), which combines
    bisection, secant, and inverse quadratic interpolation for efficient and
    robust convergence. This is ~100x faster than the original binary search
    algorithm while maintaining identical numerical accuracy.

    Parameters
    ----------
    logK : float, int, or list of float or int
        Logarithm (base 10) of the equilibrium constant(s). When a list is
        provided, each logK value is processed separately and a list of results
        is returned.
    species : str, int, or list of str or int
        Name, formula, or database index of species involved in the reaction
    coeff : int, float, or list
        Reaction stoichiometric coefficients (negative for reactants, positive for products)
    state : str or list of str
        Physical state(s) of species: &#34;aq&#34;, &#34;cr&#34;, &#34;gas&#34;, &#34;liq&#34;
    pressures : float or list of float, default 1
        Pressure(s) in bars (used when solving for temperature)
    temperatures : float or list of float, default 25
        Temperature(s) in °C (used when solving for pressure)
    IS : float, default 0
        Ionic strength for activity corrections (mol/kg)
    minT : float, default 0.1
        Minimum temperature (°C) to search (ignored when solving for pressure)
    maxT : float, default 100
        Maximum temperature (°C) to search (ignored when solving for pressure)
    minP : float, default 1
        Minimum pressure (bar) to search (ignored when solving for temperature)
    maxP : float, default 500
        Maximum pressure (bar) to search (ignored when solving for temperature)
    tol : float, optional
        Tolerance for convergence. Default: 1/(10^(n+2)) where n is number of
        decimal places in logK, with maximum default of 1e-5
    solve : str, default &#34;T&#34;
        What to solve for: &#34;T&#34; for temperature or &#34;P&#34; for pressure
    messages : bool, default True
        Print informational messages
    show : bool, default True
        Display result table
    plot_it : bool, default True
        Display interactive plotly plot showing logK vs T (or P) with target logK
        as horizontal line and intersection points marked
    width : int, default 600
        Plot width in pixels (used if plot_it=True)
    height : int, default 400
        Plot height in pixels (used if plot_it=True)
    res : int, default 200
        Number of points to calculate for plotting the logK curve
        (used if plot_it=True)

    Returns
    -------
    UnivariantResult or list of UnivariantResult
        When logK is a single value: returns a UnivariantResult object.
        When logK is a list: returns a list of UnivariantResult objects.
        Each result contains:
        - reaction: DataFrame with reaction stoichiometry
        - out: DataFrame with solved T or P values and thermodynamic properties
        - warnings: List of warning messages

    Examples
    --------
    &gt;&gt;&gt; from pychnosz import unicurve, reset
    &gt;&gt;&gt; reset()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Solve for temperature: quartz dissolution
    &gt;&gt;&gt; # SiO2(quartz) = SiO2(aq)
    &gt;&gt;&gt; result = unicurve(logK=-2.71, species=[&#34;quartz&#34;, &#34;SiO2&#34;],
    ...                   state=[&#34;cr&#34;, &#34;aq&#34;], coeff=[-1, 1],
    ...                   pressures=200, minT=1, maxT=350)
    &gt;&gt;&gt; print(result.out[[&#34;P&#34;, &#34;T&#34;, &#34;logK&#34;]])
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Solve for pressure: water dissociation
    &gt;&gt;&gt; result = unicurve(logK=-14, species=[&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;],
    ...                   state=[&#34;liq&#34;, &#34;aq&#34;, &#34;aq&#34;], coeff=[-1, 1, 1],
    ...                   temperatures=[25, 50, 75], solve=&#34;P&#34;,
    ...                   minP=1, maxP=1000)
    &gt;&gt;&gt; print(result.out[[&#34;T&#34;, &#34;P&#34;, &#34;logK&#34;]])

    Notes
    -----
    This function uses scipy.optimize.brentq for root-finding, which provides:
    - Guaranteed convergence if root is bracketed
    - Typical convergence in 5-15 function evaluations
    - ~100x speedup compared to custom binary search (1600 → 15 evaluations)
    - Identical numerical results to original implementation

    The algorithm also implements &#34;warm start&#34; optimization: when solving for
    multiple pressures/temperatures, previous solutions are used to intelligently
    bracket subsequent searches, further improving performance.

    References
    ----------
    Based on univariant.r from pyCHNOSZ by Grayson Boyer
    Optimized using Brent, R. P. (1973). Algorithms for Minimization without Derivatives.
    &#34;&#34;&#34;
    # Track whether input was a single value or list
    single_logK_input = not isinstance(logK, list)

    # Ensure logK is a list for processing
    if single_logK_input:
        logK_list = [logK]
    else:
        logK_list = logK

    # Ensure species, state, and coeff are lists
    if not isinstance(species, list):
        species = [species]
    if not isinstance(state, list):
        state = [state]
    if not isinstance(coeff, list):
        coeff = [coeff]

    # Process each logK value
    results = []

    for this_logK in logK_list:
        result = UnivariantResult()

        # Set default tolerance based on logK precision
        if tol is None:
            # Count decimal places in logK
            logK_str = str(float(this_logK))
            if &#39;.&#39; in logK_str:
                n_decimals = len(logK_str.split(&#39;.&#39;)[1].rstrip(&#39;0&#39;))
            else:
                n_decimals = 0
            this_tol = 10 ** (-(n_decimals + 2))
            if this_tol &gt; 1e-5:
                this_tol = 1e-5
        else:
            this_tol = tol

        # Get reaction information from first subcrt call
        try:
            initial_calc = subcrt(species, coeff=coeff, state=state, T=25, P=1,
                                 exceed_Ttr=True, messages=False, show=False)
            result.reaction = initial_calc.reaction
        except Exception as e:
            if messages:
                warnings.warn(f&#34;Error getting reaction information: {str(e)}&#34;)
            result.reaction = None

        if solve.upper() == &#34;T&#34;:
            # Solve for temperature at given pressure(s)
            if not isinstance(pressures, list):
                pressures = [pressures]

            results_list = []
            prev_T = None  # For warm start optimization

            for i, pressure in enumerate(pressures):
                if messages:
                    print(f&#34;Solving for T at P = {pressure} bar (logK = {this_logK})...&#34;)

                # Warm start: use previous solution to narrow search range if available
                current_minT = minT
                current_maxT = maxT
                if prev_T is not None and minT &lt; prev_T &lt; maxT:
                    # Center search around previous solution with a safety margin
                    # logK typically changes by ~0.006 per °C, so ±50°C should be safe
                    margin = 50
                    current_minT = max(minT, prev_T - margin)
                    current_maxT = min(maxT, prev_T + margin)
                    if messages:
                        print(f&#34;  Using warm start: searching {current_minT:.1f} to {current_maxT:.1f}°C&#34;)

                result_dict = _solve_T_for_pressure(this_logK, species, state, coeff, pressure,
                                           IS, current_minT, current_maxT, this_tol,
                                           initial_guess=prev_T, messages=messages)

                # If warm start failed, try full range
                if result_dict[&#39;T&#39;] is None and prev_T is not None:
                    if messages:
                        print(f&#34;  Warm start failed, searching full range...&#34;)
                    result_dict = _solve_T_for_pressure(this_logK, species, state, coeff, pressure,
                                               IS, minT, maxT, this_tol, messages=messages)

                results_list.append(result_dict)

                # Update for next warm start
                if result_dict[&#39;T&#39;] is not None:
                    prev_T = result_dict[&#39;T&#39;]

            result.out = pd.DataFrame(results_list)

        elif solve.upper() == &#34;P&#34;:
            # Solve for pressure at given temperature(s)
            if not isinstance(temperatures, list):
                temperatures = [temperatures]

            results_list = []
            prev_P = None  # For warm start optimization

            for i, temperature in enumerate(temperatures):
                if messages:
                    print(f&#34;Solving for P at T = {temperature} °C (logK = {this_logK})...&#34;)

                # Warm start: use previous solution to narrow search range if available
                current_minP = minP
                current_maxP = maxP
                if prev_P is not None and minP &lt; prev_P &lt; maxP:
                    # Center search around previous solution with a safety margin
                    # Pressure effects vary, use a generous ±500 bar margin
                    margin = 500
                    current_minP = max(minP, prev_P - margin)
                    current_maxP = min(maxP, prev_P + margin)
                    if messages:
                        print(f&#34;  Using warm start: searching {current_minP:.0f} to {current_maxP:.0f} bar&#34;)

                result_dict = _solve_P_for_temperature(this_logK, species, state, coeff, temperature,
                                              IS, current_minP, current_maxP, this_tol,
                                              initial_guess=prev_P, messages=messages)

                # If warm start failed, try full range
                if result_dict[&#39;P&#39;] is None and prev_P is not None:
                    if messages:
                        print(f&#34;  Warm start failed, searching full range...&#34;)
                    result_dict = _solve_P_for_temperature(this_logK, species, state, coeff, temperature,
                                                  IS, minP, maxP, this_tol, messages=messages)

                results_list.append(result_dict)

                # Update for next warm start
                if result_dict[&#39;P&#39;] is not None:
                    prev_P = result_dict[&#39;P&#39;]

            result.out = pd.DataFrame(results_list)

        else:
            raise ValueError(f&#34;solve must be &#39;T&#39; or &#39;P&#39;, got &#39;{solve}&#39;&#34;)

        # Create interactive plot if requested
        if plot_it:
            if not PLOTLY_AVAILABLE:
                warnings.warn(&#34;plotly is not installed. Set plot_it=False to suppress this warning, &#34;
                             &#34;or install plotly with: pip install plotly&#34;)
            else:
                result.fig = _create_unicurve_plot(this_logK, species, state, coeff, result, solve,
                                                   minT, maxT, minP, maxP, IS, width, height, res, messages)

        # Display result if requested
        if show and result.out is not None:
            try:
                from IPython.display import display
                if result.reaction is not None:
                    print(&#34;\nReaction:&#34;)
                    display(result.reaction)
                print(f&#34;\nResults (logK = {this_logK}):&#34;)
                display(result.out)
            except ImportError:
                # Not in Jupyter, just print
                if result.reaction is not None:
                    print(&#34;\nReaction:&#34;)
                    print(result.reaction)
                print(f&#34;\nResults (logK = {this_logK}):&#34;)
                print(result.out)

        # Add this result to the list
        results.append(result)

    # Return single result or list based on input
    if single_logK_input:
        return results[0]
    else:
        return results</code></pre>
</details>
<div class="desc"><p>Solve for temperatures or pressures of equilibration for a given logK value(s).</p>
<p>This function calculates univariant curves useful for aqueous geothermometry
and geobarometry. Given a measured equilibrium constant (logK) for a reaction,
it solves for the temperatures (at specified pressures) or pressures (at
specified temperatures) where the reaction would produce that logK value.</p>
<p>The solver uses scipy.optimize.brentq (Brent's method), which combines
bisection, secant, and inverse quadratic interpolation for efficient and
robust convergence. This is ~100x faster than the original binary search
algorithm while maintaining identical numerical accuracy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logK</code></strong> :&ensp;<code>float, int,</code> or <code>list</code> of <code>float</code> or <code>int</code></dt>
<dd>Logarithm (base 10) of the equilibrium constant(s). When a list is
provided, each logK value is processed separately and a list of results
is returned.</dd>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int,</code> or <code>list</code> of <code>str</code> or <code>int</code></dt>
<dd>Name, formula, or database index of species involved in the reaction</dd>
<dt><strong><code>coeff</code></strong> :&ensp;<code>int, float,</code> or <code>list</code></dt>
<dd>Reaction stoichiometric coefficients (negative for reactants, positive for products)</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Physical state(s) of species: "aq", "cr", "gas", "liq"</dd>
<dt><strong><code>pressures</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, default <code>1</code></dt>
<dd>Pressure(s) in bars (used when solving for temperature)</dd>
<dt><strong><code>temperatures</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, default <code>25</code></dt>
<dd>Temperature(s) in °C (used when solving for pressure)</dd>
<dt><strong><code>IS</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Ionic strength for activity corrections (mol/kg)</dd>
<dt><strong><code>minT</code></strong> :&ensp;<code>float</code>, default <code>0.1</code></dt>
<dd>Minimum temperature (°C) to search (ignored when solving for pressure)</dd>
<dt><strong><code>maxT</code></strong> :&ensp;<code>float</code>, default <code>100</code></dt>
<dd>Maximum temperature (°C) to search (ignored when solving for pressure)</dd>
<dt><strong><code>minP</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Minimum pressure (bar) to search (ignored when solving for temperature)</dd>
<dt><strong><code>maxP</code></strong> :&ensp;<code>float</code>, default <code>500</code></dt>
<dd>Maximum pressure (bar) to search (ignored when solving for temperature)</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance for convergence. Default: 1/(10^(n+2)) where n is number of
decimal places in logK, with maximum default of 1e-5</dd>
<dt><strong><code>solve</code></strong> :&ensp;<code>str</code>, default <code>"T"</code></dt>
<dd>What to solve for: "T" for temperature or "P" for pressure</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Print informational messages</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display result table</dd>
<dt><strong><code>plot_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display interactive plotly plot showing logK vs T (or P) with target logK
as horizontal line and intersection points marked</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, default <code>600</code></dt>
<dd>Plot width in pixels (used if plot_it=True)</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, default <code>400</code></dt>
<dd>Plot height in pixels (used if plot_it=True)</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>int</code>, default <code>200</code></dt>
<dd>Number of points to calculate for plotting the logK curve
(used if plot_it=True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="pychnosz.core.unicurve.UnivariantResult" href="#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a></code> or <code>list</code> of <code><a title="pychnosz.core.unicurve.UnivariantResult" href="#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a></code></dt>
<dd>When logK is a single value: returns a UnivariantResult object.
When logK is a list: returns a list of UnivariantResult objects.
Each result contains:
- reaction: DataFrame with reaction stoichiometry
- out: DataFrame with solved T or P values and thermodynamic properties
- warnings: List of warning messages</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz import unicurve, reset
&gt;&gt;&gt; reset()
&gt;&gt;&gt;
&gt;&gt;&gt; # Solve for temperature: quartz dissolution
&gt;&gt;&gt; # SiO2(quartz) = SiO2(aq)
&gt;&gt;&gt; result = unicurve(logK=-2.71, species=[&quot;quartz&quot;, &quot;SiO2&quot;],
...                   state=[&quot;cr&quot;, &quot;aq&quot;], coeff=[-1, 1],
...                   pressures=200, minT=1, maxT=350)
&gt;&gt;&gt; print(result.out[[&quot;P&quot;, &quot;T&quot;, &quot;logK&quot;]])
&gt;&gt;&gt;
&gt;&gt;&gt; # Solve for pressure: water dissociation
&gt;&gt;&gt; result = unicurve(logK=-14, species=[&quot;H2O&quot;, &quot;H+&quot;, &quot;OH-&quot;],
...                   state=[&quot;liq&quot;, &quot;aq&quot;, &quot;aq&quot;], coeff=[-1, 1, 1],
...                   temperatures=[25, 50, 75], solve=&quot;P&quot;,
...                   minP=1, maxP=1000)
&gt;&gt;&gt; print(result.out[[&quot;T&quot;, &quot;P&quot;, &quot;logK&quot;]])
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function uses scipy.optimize.brentq for root-finding, which provides:
- Guaranteed convergence if root is bracketed
- Typical convergence in 5-15 function evaluations
- ~100x speedup compared to custom binary search (1600 → 15 evaluations)
- Identical numerical results to original implementation</p>
<p>The algorithm also implements "warm start" optimization: when solving for
multiple pressures/temperatures, previous solutions are used to intelligently
bracket subsequent searches, further improving performance.</p>
<h2 id="references">References</h2>
<p>Based on univariant.r from pyCHNOSZ by Grayson Boyer
Optimized using Brent, R. P. (1973). Algorithms for Minimization without Derivatives.</p></div>
</dd>
<dt id="pychnosz.core.unicurve.univariant_TP"><code class="name flex">
<span>def <span class="ident">univariant_TP</span></span>(<span>logK: int | float | List[int | float],<br>species: str | List[str] | int | List[int],<br>coeff: int | float | List[int | float],<br>state: str | List[str],<br>Trange: List[float],<br>Prange: List[float],<br>IS: float = 0,<br>xlim: List[float] | None = None,<br>ylim: List[float] | None = None,<br>line_type: str = 'markers+lines',<br>tol: float | None = None,<br>title: str | None = None,<br>res: int = 10,<br>width: int = 500,<br>height: int = 400,<br>save_as: str | None = None,<br>save_format: str = 'png',<br>save_scale: float = 1,<br>show: bool = False,<br>messages: bool = False,<br>parallel: bool = True,<br>plot_it: bool = True) ‑> List[<a title="pychnosz.core.unicurve.UnivariantResult" href="#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def univariant_TP(logK: Union[float, int, List[Union[float, int]]],
                  species: Union[str, List[str], int, List[int]],
                  coeff: Union[int, float, List[Union[int, float]]],
                  state: Union[str, List[str]],
                  Trange: List[float],
                  Prange: List[float],
                  IS: float = 0,
                  xlim: Optional[List[float]] = None,
                  ylim: Optional[List[float]] = None,
                  line_type: str = &#34;markers+lines&#34;,
                  tol: Optional[float] = None,
                  title: Optional[str] = None,
                  res: int = 10,
                  width: int = 500,
                  height: int = 400,
                  save_as: Optional[str] = None,
                  save_format: str = &#34;png&#34;,
                  save_scale: float = 1,
                  show: bool = False,
                  messages: bool = False,
                  parallel: bool = True,
                  plot_it: bool = True) -&gt; List[UnivariantResult]:
    &#34;&#34;&#34;
    Solve for temperatures and pressures of equilibration for given logK value(s)
    and produce an interactive T-P diagram.

    This function calculates univariant curves in temperature-pressure (T-P) space
    for one or more logK values. For each pressure in a range, it solves for the
    temperature where the reaction achieves the target logK. The resulting curves
    show phase boundaries or equilibrium conditions in T-P space.

    Parameters
    ----------
    logK : float, int, or list
        Logarithm (base 10) of equilibrium constant(s). Multiple values produce
        multiple curves on the same plot.
    species : str, int, or list of str or int
        Name, formula, or database index of species involved in the reaction
    coeff : int, float, or list
        Reaction stoichiometric coefficients (negative for reactants, positive for products)
    state : str or list of str
        Physical state(s) of species: &#34;aq&#34;, &#34;cr&#34;, &#34;gas&#34;, &#34;liq&#34;
    Trange : list of two floats
        [min, max] temperature range (°C) to search for solutions
    Prange : list of two floats
        [min, max] pressure range (bar) to calculate along
    IS : float, default 0
        Ionic strength for activity corrections (mol/kg)
    xlim : list of two floats, optional
        [min, max] range for x-axis (temperature) in plot
    ylim : list of two floats, optional
        [min, max] range for y-axis (pressure) in plot
    line_type : str, default &#34;markers+lines&#34;
        Plotly line type: &#34;markers+lines&#34;, &#34;markers&#34;, or &#34;lines&#34;
    tol : float, optional
        Convergence tolerance. Default: 1/(10^(n+2)) where n is decimal places in logK
    title : str, optional
        Plot title. Default: auto-generated from reaction
    res : int, default 10
        Number of pressure points to calculate along the curve
    width : int, default 500
        Plot width in pixels
    height : int, default 400
        Plot height in pixels
    save_as : str, optional
        Filename to save plot (without extension)
    save_format : str, default &#34;png&#34;
        Save format: &#34;png&#34;, &#34;jpg&#34;, &#34;jpeg&#34;, &#34;webp&#34;, &#34;svg&#34;, &#34;pdf&#34;, &#34;html&#34;
    save_scale : float, default 1
        Scale factor for saved plot
    show : bool, default False
        Display subcrt result tables
    messages : bool, default False
        Print informational messages
    parallel : bool, default True
        Use parallel processing across multiple logK values for faster computation.
        Utilizes multiple CPU cores when processing multiple logK curves.
    plot_it : bool, default True
        Display the plot

    Returns
    -------
    list of UnivariantResult
        List of UnivariantResult objects, one for each logK value.
        Each contains reaction information and T-P curve data.

    Examples
    --------
    &gt;&gt;&gt; from pychnosz import univariant_TP, reset
    &gt;&gt;&gt; reset()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Calcite-aragonite phase boundary
    &gt;&gt;&gt; result = univariant_TP(
    ...     logK=0,
    ...     species=[&#34;calcite&#34;, &#34;aragonite&#34;],
    ...     state=[&#34;cr&#34;, &#34;cr&#34;],
    ...     coeff=[-1, 1],
    ...     Trange=[0, 700],
    ...     Prange=[2000, 16000]
    ... )
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Multiple curves for K-feldspar stability
    &gt;&gt;&gt; result = univariant_TP(
    ...     logK=[-8, -6, -4, -2],
    ...     species=[&#34;K-feldspar&#34;, &#34;kaolinite&#34;, &#34;H2O&#34;, &#34;SiO2&#34;, &#34;muscovite&#34;],
    ...     state=[&#34;cr&#34;, &#34;cr&#34;, &#34;liq&#34;, &#34;aq&#34;, &#34;cr&#34;],
    ...     coeff=[-1, -1, 1, 2, 1],
    ...     Trange=[0, 350],
    ...     Prange=[1, 5000],
    ...     res=20
    ... )

    Notes
    -----
    This function creates T-P diagrams by:
    1. Generating a range of pressures from Prange[0] to Prange[1]
    2. For each pressure, solving for T where logK matches the target
    3. Plotting the resulting T-P points as a curve

    For multiple logK values, each curve represents a different equilibrium
    condition. This is useful for:
    - Phase diagrams (e.g., mineral stability fields)
    - Isopleths (lines of constant logK)
    - Reaction boundaries

    Requires plotly for interactive plotting. If plotly is not installed,
    set plot_it=False to just return the data without plotting.

    References
    ----------
    Based on univariant_TP from pyCHNOSZ by Grayson Boyer
    &#34;&#34;&#34;

    # Check if plotly is available
    if plot_it and not PLOTLY_AVAILABLE:
        warnings.warn(&#34;plotly is not installed. Set plot_it=False to suppress this warning, &#34;
                     &#34;or install plotly with: pip install plotly&#34;)
        plot_it = False

    # Ensure logK is a list
    if not isinstance(logK, list):
        logK = [logK]

    # Create plotly figure
    if plot_it:
        fig = go.Figure()

    output = []

    # Generate pressure array
    pressures = np.linspace(Prange[0], Prange[1], res)

    # Process each logK value (in parallel if enabled)
    if parallel and len(logK) &gt; 1:
        # Parallel processing
        max_workers = min(len(logK), multiprocessing.cpu_count())

        # Prepare arguments for each logK value
        args_list = [
            (this_logK, species, state, coeff, pressures, Trange, IS, tol, show, messages)
            for this_logK in logK
        ]

        # Process in parallel
        with ProcessPoolExecutor(max_workers=max_workers) as executor:
            # Submit all tasks
            future_to_logK = {
                executor.submit(_process_single_logK, args): args[0]
                for args in args_list
            }

            # Collect results as they complete (maintains order via logK list)
            results_dict = {}
            for future in as_completed(future_to_logK):
                this_logK = future_to_logK[future]
                try:
                    out = future.result()
                    results_dict[this_logK] = out
                except Exception as e:
                    if messages:
                        print(f&#34;Error processing logK={this_logK}: {str(e)}&#34;)
                    # Create empty result
                    results_dict[this_logK] = None

            # Reorder results to match input logK order
            for this_logK in logK:
                out = results_dict.get(this_logK)
                if out is not None:
                    output.append(out)

                    # Add to plot if we have valid data
                    if plot_it and not out.out[&#39;T&#39;].isnull().all():
                        fig.add_trace(go.Scatter(
                            x=out.out[&#39;T&#39;],
                            y=out.out[&#39;P&#39;],
                            mode=line_type,
                            name=f&#34;logK={this_logK}&#34;,
                            text=[f&#34;logK={this_logK}&#34; for _ in range(len(out.out[&#39;T&#39;]))],
                            hovertemplate=&#39;%{text}&lt;br&gt;T, °C=%{x:.2f}&lt;br&gt;P, bar=%{y:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                        ))
                    elif out.out[&#39;T&#39;].isnull().all():
                        if messages:
                            print(f&#34;Could not find any T or P values in this range that correspond to a logK value of {this_logK}&#34;)

    else:
        # Sequential processing (original code)
        for this_logK in logK:
            # Set tolerance if not specified
            if tol is None:
                logK_str = str(float(this_logK))
                if &#39;.&#39; in logK_str:
                    n_decimals = len(logK_str.split(&#39;.&#39;)[1].rstrip(&#39;0&#39;))
                else:
                    n_decimals = 0
                this_tol = 10 ** (-(n_decimals + 2))
                if this_tol &gt; 1e-5:
                    this_tol = 1e-5
            else:
                this_tol = tol

            # Solve for T at each pressure
            out = unicurve(
                solve=&#34;T&#34;,
                logK=this_logK,
                species=species,
                state=state,
                coeff=coeff,
                pressures=list(pressures),
                minT=Trange[0],
                maxT=Trange[1],
                IS=IS,
                tol=this_tol,
                show=show,
                messages=messages,
                plot_it=False  # Don&#39;t plot individual curves - univariant_TP makes its own plot
            )

            # Add to plot if we have valid data
            if plot_it and not out.out[&#39;T&#39;].isnull().all():
                fig.add_trace(go.Scatter(
                    x=out.out[&#39;T&#39;],
                    y=out.out[&#39;P&#39;],
                    mode=line_type,
                    name=f&#34;logK={this_logK}&#34;,
                    text=[f&#34;logK={this_logK}&#34; for _ in range(len(out.out[&#39;T&#39;]))],
                    hovertemplate=&#39;%{text}&lt;br&gt;T, °C=%{x:.2f}&lt;br&gt;P, bar=%{y:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                ))
            elif out.out[&#39;T&#39;].isnull().all():
                if messages:
                    print(f&#34;Could not find any T or P values in this range that correspond to a logK value of {this_logK}&#34;)

            output.append(out)

    # Generate plot title if not specified
    if plot_it:
        if title is None and len(output) &gt; 0 and output[0].reaction is not None:
            react_grid = output[0].reaction

            # Build reaction string
            reactants = []
            products = []
            for i, row in react_grid.iterrows():
                coeff_val = row[&#39;coeff&#39;]
                name = row[&#39;name&#39;] if row[&#39;name&#39;] != &#39;water&#39; else &#39;H2O&#39;

                if coeff_val &lt; 0:
                    coeff_str = str(int(-coeff_val)) if -coeff_val != 1 else &#34;&#34;
                    reactants.append(f&#34;{coeff_str} {name}&#34;.strip())
                elif coeff_val &gt; 0:
                    coeff_str = str(int(coeff_val)) if coeff_val != 1 else &#34;&#34;
                    products.append(f&#34;{coeff_str} {name}&#34;.strip())

            title = &#34; + &#34;.join(reactants) + &#34; = &#34; + &#34; + &#34;.join(products)

        # Update layout
        fig.update_layout(
            template=&#34;simple_white&#34;,
            title=str(title) if title else &#34;&#34;,
            xaxis_title=&#34;T, °C&#34;,
            yaxis_title=&#34;P, bar&#34;,
            width=width,
            height=height,
            hoverlabel=dict(bgcolor=&#34;white&#34;),
        )

        # Set axis limits if specified
        if xlim is not None:
            fig.update_xaxes(range=xlim)
        if ylim is not None:
            fig.update_yaxes(range=ylim)

        # Configure plot controls
        config = {
            &#39;displaylogo&#39;: False,
            &#39;modeBarButtonsToRemove&#39;: [&#39;resetScale2d&#39;, &#39;toggleSpikelines&#39;],
            &#39;toImageButtonOptions&#39;: {
                &#39;format&#39;: save_format,
                &#39;filename&#39;: save_as if save_as else &#39;univariant_TP&#39;,
                &#39;height&#39;: height,
                &#39;width&#39;: width,
                &#39;scale&#39;: save_scale,
            },
        }

        # Save plot if requested
        if save_as is not None:
            full_filename = f&#34;{save_as}.{save_format}&#34;
            if save_format == &#39;html&#39;:
                fig.write_html(full_filename)
            else:
                fig.write_image(full_filename, format=save_format,
                              width=width, height=height, scale=save_scale)
            if messages:
                print(f&#34;Plot saved to {full_filename}&#34;)

        # Display plot
        fig.show(config=config)

        # Store figure in all result objects
        for out in output:
            out.fig = fig

    return output</code></pre>
</details>
<div class="desc"><p>Solve for temperatures and pressures of equilibration for given logK value(s)
and produce an interactive T-P diagram.</p>
<p>This function calculates univariant curves in temperature-pressure (T-P) space
for one or more logK values. For each pressure in a range, it solves for the
temperature where the reaction achieves the target logK. The resulting curves
show phase boundaries or equilibrium conditions in T-P space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logK</code></strong> :&ensp;<code>float, int,</code> or <code>list</code></dt>
<dd>Logarithm (base 10) of equilibrium constant(s). Multiple values produce
multiple curves on the same plot.</dd>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int,</code> or <code>list</code> of <code>str</code> or <code>int</code></dt>
<dd>Name, formula, or database index of species involved in the reaction</dd>
<dt><strong><code>coeff</code></strong> :&ensp;<code>int, float,</code> or <code>list</code></dt>
<dd>Reaction stoichiometric coefficients (negative for reactants, positive for products)</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Physical state(s) of species: "aq", "cr", "gas", "liq"</dd>
<dt><strong><code>Trange</code></strong> :&ensp;<code>list</code> of <code>two floats</code></dt>
<dd>[min, max] temperature range (°C) to search for solutions</dd>
<dt><strong><code>Prange</code></strong> :&ensp;<code>list</code> of <code>two floats</code></dt>
<dd>[min, max] pressure range (bar) to calculate along</dd>
<dt><strong><code>IS</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Ionic strength for activity corrections (mol/kg)</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>list</code> of <code>two floats</code>, optional</dt>
<dd>[min, max] range for x-axis (temperature) in plot</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>two floats</code>, optional</dt>
<dd>[min, max] range for y-axis (pressure) in plot</dd>
<dt><strong><code>line_type</code></strong> :&ensp;<code>str</code>, default <code>"markers+lines"</code></dt>
<dd>Plotly line type: "markers+lines", "markers", or "lines"</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Convergence tolerance. Default: 1/(10^(n+2)) where n is decimal places in logK</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Plot title. Default: auto-generated from reaction</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>int</code>, default <code>10</code></dt>
<dd>Number of pressure points to calculate along the curve</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, default <code>500</code></dt>
<dd>Plot width in pixels</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, default <code>400</code></dt>
<dd>Plot height in pixels</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filename to save plot (without extension)</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Save format: "png", "jpg", "jpeg", "webp", "svg", "pdf", "html"</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Scale factor for saved plot</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Display subcrt result tables</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Print informational messages</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Use parallel processing across multiple logK values for faster computation.
Utilizes multiple CPU cores when processing multiple logK curves.</dd>
<dt><strong><code>plot_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display the plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code><a title="pychnosz.core.unicurve.UnivariantResult" href="#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a></code></dt>
<dd>List of UnivariantResult objects, one for each logK value.
Each contains reaction information and T-P curve data.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz import univariant_TP, reset
&gt;&gt;&gt; reset()
&gt;&gt;&gt;
&gt;&gt;&gt; # Calcite-aragonite phase boundary
&gt;&gt;&gt; result = univariant_TP(
...     logK=0,
...     species=[&quot;calcite&quot;, &quot;aragonite&quot;],
...     state=[&quot;cr&quot;, &quot;cr&quot;],
...     coeff=[-1, 1],
...     Trange=[0, 700],
...     Prange=[2000, 16000]
... )
&gt;&gt;&gt;
&gt;&gt;&gt; # Multiple curves for K-feldspar stability
&gt;&gt;&gt; result = univariant_TP(
...     logK=[-8, -6, -4, -2],
...     species=[&quot;K-feldspar&quot;, &quot;kaolinite&quot;, &quot;H2O&quot;, &quot;SiO2&quot;, &quot;muscovite&quot;],
...     state=[&quot;cr&quot;, &quot;cr&quot;, &quot;liq&quot;, &quot;aq&quot;, &quot;cr&quot;],
...     coeff=[-1, -1, 1, 2, 1],
...     Trange=[0, 350],
...     Prange=[1, 5000],
...     res=20
... )
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function creates T-P diagrams by:
1. Generating a range of pressures from Prange[0] to Prange[1]
2. For each pressure, solving for T where logK matches the target
3. Plotting the resulting T-P points as a curve</p>
<p>For multiple logK values, each curve represents a different equilibrium
condition. This is useful for:
- Phase diagrams (e.g., mineral stability fields)
- Isopleths (lines of constant logK)
- Reaction boundaries</p>
<p>Requires plotly for interactive plotting. If plotly is not installed,
set plot_it=False to just return the data without plotting.</p>
<h2 id="references">References</h2>
<p>Based on univariant_TP from pyCHNOSZ by Grayson Boyer</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pychnosz.core.unicurve.UnivariantResult"><code class="flex name class">
<span>class <span class="ident">UnivariantResult</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnivariantResult:
    &#34;&#34;&#34;Result structure for univariant curve calculations.&#34;&#34;&#34;

    def __init__(self):
        self.reaction = None    # Reaction summary DataFrame
        self.out = None         # Results DataFrame with T/P and thermodynamic properties
        self.warnings = []      # Warning messages
        self.fig = None         # Plotly figure object (if plot_it=True)

    def __repr__(self):
        if self.out is not None:
            return f&#34;UnivariantResult with {len(self.out)} points&#34;
        return &#34;UnivariantResult (no calculations performed)&#34;

    def __getitem__(self, key):
        &#34;&#34;&#34;Allow dictionary-style access to attributes.&#34;&#34;&#34;
        return getattr(self, key)</code></pre>
</details>
<div class="desc"><p>Result structure for univariant curve calculations.</p></div>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pychnosz.core" href="index.html">pychnosz.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pychnosz.core.unicurve.unicurve" href="#pychnosz.core.unicurve.unicurve">unicurve</a></code></li>
<li><code><a title="pychnosz.core.unicurve.univariant_TP" href="#pychnosz.core.unicurve.univariant_TP">univariant_TP</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pychnosz.core.unicurve.UnivariantResult" href="#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
