<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pychnosz.data.add_obigt API documentation</title>
<meta name="description" content="Implementation of add_OBIGT() function for Python CHNOSZ …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pychnosz.data.add_obigt</code></h1>
</header>
<section id="section-intro">
<p>Implementation of add_OBIGT() function for Python CHNOSZ.</p>
<p>This function loads external OBIGT database files and replaces or adds
entries to the currently loaded thermodynamic database, mimicking the
behavior of R CHNOSZ add.OBIGT() function.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pychnosz.data.add_obigt.add_OBIGT"><code class="name flex">
<span>def <span class="ident">add_OBIGT</span></span>(<span>file: str | pandas.core.frame.DataFrame,<br>force: bool = True,<br>messages: bool = True) ‑> List[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_OBIGT(file: Union[str, pd.DataFrame], force: bool = True, messages: bool = True) -&gt; List[int]:
    &#34;&#34;&#34;
    Add or replace entries in the thermodynamic database from external files or DataFrames.

    This function replicates the behavior of R CHNOSZ add.OBIGT() by loading
    CSV files from inst/extdata/OBIGT/ or accepting pandas DataFrames directly,
    and replacing entries with matching names.

    Parameters
    ----------
    file : str or pd.DataFrame
        Either:
        - Name of the database file to load (e.g., &#34;SUPCRT92&#34;)
          The function will look for file.csv in inst/extdata/OBIGT/
        - Full path to a CSV file
        - A pandas DataFrame containing OBIGT data
    force : bool, default True
        If True, proceed even if some species are not found
    messages : bool, default True
        If True, print informational messages about additions/replacements
        If False, suppress all output (equivalent to R&#39;s suppressMessages())

    Returns
    -------
    list of int
        List of species indices (1-based) that were added or replaced

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Example 1: Load from file name
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; indices = pychnosz.add_OBIGT(&#34;SUPCRT92&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Example 2: Load from DataFrame
    &gt;&gt;&gt; thermo_df = pd.read_csv(&#34;thermodata.csv&#34;)
    &gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Example 3: Suppress messages
    &gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df, messages=False)

    Notes
    -----
    This function modifies the thermo() object in place, replacing entries
    with matching names and adding new entries for species not in the database.
    The behavior exactly matches R CHNOSZ add.OBIGT().
    &#34;&#34;&#34;

    # Get the thermo system
    thermo_sys = thermo()

    # Ensure the thermodynamic system is initialized
    if not thermo_sys.is_initialized() or thermo_sys.obigt is None:
        thermo_sys.reset()

    # Handle DataFrame input
    if isinstance(file, pd.DataFrame):
        new_data = file.copy()
        file_path = &#34;&lt;DataFrame&gt;&#34;
        file_basename = None
    else:
        # Handle string file path
        # If file is not an existing path, look for it in OBIGT directories
        if not os.path.exists(file):
            if not file.endswith(&#39;.csv&#39;):
                file_to_find = file + &#39;.csv&#39;
            else:
                file_to_find = file

            # Look for the file in the OBIGT data directory
            # Use package-relative path
            base_paths = [
                os.path.join(os.path.dirname(__file__), &#39;extdata&#39;, &#39;OBIGT&#39;),
            ]

            file_path = None
            for base_path in base_paths:
                potential_path = os.path.join(base_path, file_to_find)
                if os.path.exists(potential_path):
                    file_path = potential_path
                    break

            if file_path is None:
                raise FileNotFoundError(f&#34;Could not find OBIGT file: {file}&#34;)
        else:
            # Use the file path as provided
            file_path = file

        # Extract the basename for source_file column
        file_basename = os.path.basename(file_path)

        # Read the CSV file
        try:
            new_data = pd.read_csv(file_path)
        except Exception as e:
            raise ValueError(f&#34;Error reading {file_path}: {e}&#34;)

    if new_data.empty:
        raise ValueError(f&#34;No data found in {file_path if isinstance(file, str) else &#39;DataFrame&#39;}&#34;)

    # Validate columns before processing
    # Get the current OBIGT database to determine required columns
    to1 = thermo_sys.obigt

    # Define core required columns that all species must have
    # These are the fundamental columns needed for thermodynamic calculations
    # Model-specific columns (logK*, T*, P*, etc.) are optional
    core_required_columns = [
        &#39;name&#39;, &#39;abbrv&#39;, &#39;formula&#39;, &#39;state&#39;, &#39;ref1&#39;, &#39;ref2&#39;, &#39;date&#39;, &#39;E_units&#39;,
        &#39;G&#39;, &#39;H&#39;, &#39;S&#39;, &#39;Cp&#39;, &#39;V&#39;,
        &#39;a1.a&#39;, &#39;a2.b&#39;, &#39;a3.c&#39;, &#39;a4.d&#39;, &#39;c1.e&#39;, &#39;c2.f&#39;, &#39;omega.lambda&#39;, &#39;z.T&#39;
    ]

    # The &#39;model&#39; column is optional and will be auto-generated if missing
    # Filter to only include columns that exist in current OBIGT (for compatibility)
    required_columns = [col for col in core_required_columns if col in to1.columns]

    # Check for missing required columns
    missing_columns = [col for col in required_columns if col not in new_data.columns]

    if missing_columns:
        raise ValueError(
            f&#34;Missing required columns in input data: {&#39;, &#39;.join(missing_columns)}. &#34;
            f&#34;Please ensure the CSV file contains all necessary OBIGT database columns.&#34;
        )

    # Special handling for &#39;model&#39; column
    if &#39;model&#39; not in new_data.columns:
        # Create model column with proper values
        new_data = new_data.copy()  # Make a copy to avoid SettingWithCopyWarning

        # Assign model based on state:
        # - aqueous species (state == &#39;aq&#39;) get &#39;HKF&#39;
        # - non-aqueous species get &#39;CGL&#39;
        new_data[&#39;model&#39;] = new_data[&#39;state&#39;].apply(lambda x: &#39;HKF&#39; if x == &#39;aq&#39; else &#39;CGL&#39;)

        # Issue a warning to inform the user
        warnings.warn(
            &#34;The &#39;model&#39; column was not found in the input data. &#34;
            &#34;Auto-generating &#39;model&#39; column: &#39;HKF&#39; for aqueous species (state=&#39;aq&#39;), &#34;
            &#34;&#39;CGL&#39; for all other species.&#34;,
            UserWarning
        )

    # Get energy units from the file (all unique values)
    # Match R&#39;s behavior: unique values joined with &#34; and &#34;
    if &#39;E_units&#39; in new_data.columns:
        unique_units = new_data[&#39;E_units&#39;].dropna().unique().tolist()
        # Filter out non-energy unit values like &#34;CGL&#34; (which is a model, not energy unit)
        # Valid energy units are typically &#34;cal&#34; and &#34;J&#34;
        energy_unit_names = [str(u) for u in unique_units if str(u) in [&#39;cal&#39;, &#39;J&#39;]]
        # Join in the order they appear in the file (matching R&#39;s paste(unique(...), collapse = &#34; and &#34;))
        energy_units_str = &#39; and &#39;.join(energy_unit_names) if energy_unit_names else &#39;cal&#39;
    else:
        energy_units_str = &#39;cal&#39;

    # Create identifier strings for matching (name + state)
    id1 = to1[&#39;name&#39;].astype(str) + &#39; &#39; + to1[&#39;state&#39;].astype(str)
    id2 = new_data[&#39;name&#39;].astype(str) + &#39; &#39; + new_data[&#39;state&#39;].astype(str)

    # Track the indices we&#39;ve modified/added
    inew = []

    # Check which entries in new_data exist in current database
    # does_exist is a boolean array indicating which id2 entries are in id1
    does_exist = id2.isin(id1.values)

    # Get the indices in to1 where matches exist (matching R&#39;s match(id2, id1))
    # This gives us the positions in to1 for each id2 element
    ispecies_exist = []
    for i, id_val in enumerate(id2):
        if does_exist.iloc[i]:
            # Find the index in to1 where this matches
            match_idx = id1[id1 == id_val].index[0]
            ispecies_exist.append(match_idx)
        else:
            ispecies_exist.append(None)

    nexist = sum(does_exist)

    # Check if new_data has columns that to1 doesn&#39;t have, and add them
    # Use object dtype for new columns to match pandas default behavior and avoid FutureWarning
    for col in new_data.columns:
        if col not in to1.columns:
            # Determine dtype from new_data
            dtype = new_data[col].dtype
            # Use object dtype for string columns to avoid dtype incompatibility
            if dtype == object or pd.api.types.is_string_dtype(dtype):
                to1[col] = pd.Series(dtype=object)
            else:
                to1[col] = np.nan

    if force:
        # Replace existing entries
        if nexist &gt; 0:
            # Update rows in to1 for species that exist
            for i, idx in enumerate(ispecies_exist):
                if idx is not None:
                    # Replace the row in to1 with data from new_data
                    for col in new_data.columns:
                        # col should now be in to1 since we added missing columns above
                        to1.loc[idx, col] = new_data.iloc[i][col]
                    # Set source_file for replaced entries
                    if file_basename is not None:
                        to1.loc[idx, &#39;source_file&#39;] = file_basename

            # Add these indices to inew
            inew.extend([idx for idx in ispecies_exist if idx is not None])

            # Remove existing entries from new_data (to2 &lt;- to2[!does.exist, ])
            to2 = new_data[~does_exist].copy()
        else:
            to2 = new_data.copy()
    else:
        # Ignore any new entries that already exist
        to2 = new_data[~does_exist].copy()
        nexist = 0

    # Add new entries
    if len(to2) &gt; 0:
        # Store the starting index for new additions
        len_id1 = len(id1)

        # Ensure new entries have all required columns
        # Make a proper copy to avoid SettingWithCopyWarning
        to2 = to2.copy()
        for col in to1.columns:
            if col not in to2.columns:
                to2[col] = np.nan

        # Set source_file for new entries
        if file_basename is not None:
            to2[&#39;source_file&#39;] = file_basename

        # Reorder columns to match current OBIGT
        to2 = to2.reindex(columns=to1.columns)

        # Add to the database
        # Use concat with explicit future behavior to avoid FutureWarning
        to1 = pd.concat([to1, to2], ignore_index=True, sort=False)

        # Add new indices: (length(id1)+1):nrow(to1)
        new_indices = list(range(len_id1 + 1, len(to1) + 1))
        inew.extend(new_indices)

    # Reset rownames to 1:nrow (matching R&#39;s rownames(thermo$OBIGT) &lt;- 1:nrow(thermo$OBIGT))
    to1.index = range(1, len(to1) + 1)

    # Update the thermo system with modified database
    thermo_sys.obigt = to1

    # Update formula_ox if the column exists in the database
    if &#39;formula_ox&#39; in to1.columns:
        # Create a DataFrame with name and formula_ox columns
        # Keep the same index as the obigt DataFrame (1-based)
        formula_ox_df = pd.DataFrame({
            &#39;name&#39;: to1[&#39;name&#39;],
            &#39;formula_ox&#39;: to1[&#39;formula_ox&#39;]
        })
        # Preserve the 1-based index
        formula_ox_df.index = to1.index
        thermo_sys.formula_ox = formula_ox_df
    else:
        # If formula_ox column doesn&#39;t exist, set to None
        thermo_sys.formula_ox = None

    # Print summary (matching R CHNOSZ output)
    if messages:
        print(f&#34;add_OBIGT: read {len(new_data)} rows; made {nexist} replacements, {len(to2) if len(to2) &gt; 0 else 0} additions [energy units: {energy_units_str}]&#34;)

    return inew</code></pre>
</details>
<div class="desc"><p>Add or replace entries in the thermodynamic database from external files or DataFrames.</p>
<p>This function replicates the behavior of R CHNOSZ add.OBIGT() by loading
CSV files from inst/extdata/OBIGT/ or accepting pandas DataFrames directly,
and replacing entries with matching names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code> or <code>pd.DataFrame</code></dt>
<dd>Either:
- Name of the database file to load (e.g., "SUPCRT92")
The function will look for file.csv in inst/extdata/OBIGT/
- Full path to a CSV file
- A pandas DataFrame containing OBIGT data</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, proceed even if some species are not found</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, print informational messages about additions/replacements
If False, suppress all output (equivalent to R's suppressMessages())</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>int</code></dt>
<dd>List of species indices (1-based) that were added or replaced</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt;
&gt;&gt;&gt; # Example 1: Load from file name
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; indices = pychnosz.add_OBIGT(&quot;SUPCRT92&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; # Example 2: Load from DataFrame
&gt;&gt;&gt; thermo_df = pd.read_csv(&quot;thermodata.csv&quot;)
&gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df)
&gt;&gt;&gt;
&gt;&gt;&gt; # Example 3: Suppress messages
&gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df, messages=False)
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function modifies the thermo() object in place, replacing entries
with matching names and adding new entries for species not in the database.
The behavior exactly matches R CHNOSZ add.OBIGT().</p></div>
</dd>
<dt id="pychnosz.data.add_obigt.list_OBIGT_files"><code class="name flex">
<span>def <span class="ident">list_OBIGT_files</span></span>(<span>) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_OBIGT_files() -&gt; List[str]:
    &#34;&#34;&#34;
    List available OBIGT database files.
    
    Returns
    -------
    list of str
        List of available .csv files in the OBIGT directory
    &#34;&#34;&#34;
    
    # Use package-relative path
    base_paths = [
        os.path.join(os.path.dirname(__file__), &#39;extdata&#39;, &#39;OBIGT&#39;),
    ]
    
    files = []
    for base_path in base_paths:
        if os.path.exists(base_path):
            csv_files = [f[:-4] for f in os.listdir(base_path) if f.endswith(&#39;.csv&#39;)]
            files.extend(csv_files)
            break
    
    return sorted(list(set(files)))  # Remove duplicates and sort</code></pre>
</details>
<div class="desc"><p>List available OBIGT database files.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>str</code></dt>
<dd>List of available .csv files in the OBIGT directory</dd>
</dl></div>
</dd>
<dt id="pychnosz.data.add_obigt.reset_OBIGT"><code class="name flex">
<span>def <span class="ident">reset_OBIGT</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_OBIGT() -&gt; None:
    &#34;&#34;&#34;
    Reset OBIGT database to default state.
    
    This function reloads the default thermodynamic database,
    removing any modifications made by add_OBIGT().
    &#34;&#34;&#34;
    from ..utils.reset import reset
    reset()
    print(&#34;OBIGT database reset to default state&#34;)</code></pre>
</details>
<div class="desc"><p>Reset OBIGT database to default state.</p>
<p>This function reloads the default thermodynamic database,
removing any modifications made by add_OBIGT().</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pychnosz.data" href="index.html">pychnosz.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pychnosz.data.add_obigt.add_OBIGT" href="#pychnosz.data.add_obigt.add_OBIGT">add_OBIGT</a></code></li>
<li><code><a title="pychnosz.data.add_obigt.list_OBIGT_files" href="#pychnosz.data.add_obigt.list_OBIGT_files">list_OBIGT_files</a></code></li>
<li><code><a title="pychnosz.data.add_obigt.reset_OBIGT" href="#pychnosz.data.add_obigt.reset_OBIGT">reset_OBIGT</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
