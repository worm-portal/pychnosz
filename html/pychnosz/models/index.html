<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pychnosz.models API documentation</title>
<meta name="description" content="Equation of state models and water property models for CHNOSZ.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pychnosz.models</code></h1>
</header>
<section id="section-intro">
<p>Equation of state models and water property models for CHNOSZ.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pychnosz.models.archer_wang" href="archer_wang.html">pychnosz.models.archer_wang</a></code></dt>
<dd>
<div class="desc"><p>Archer &amp; Wang (1990) dielectric constant correlation for water …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.models.berman" href="berman.html">pychnosz.models.berman</a></code></dt>
<dd>
<div class="desc"><p>Berman mineral equations of state implementation …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.models.dew" href="dew.html">pychnosz.models.dew</a></code></dt>
<dd>
<div class="desc"><p>DEW (Deep Earth Water) model implementation …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.models.hkf_helpers" href="hkf_helpers.html">pychnosz.models.hkf_helpers</a></code></dt>
<dd>
<div class="desc"><p>Helper functions for HKF calculations, integrated from HKF_cgl.py …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.models.iapws95" href="iapws95.html">pychnosz.models.iapws95</a></code></dt>
<dd>
<div class="desc"><p>IAPWS-95 water model implementation …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.models.supcrt92_fortran" href="supcrt92_fortran.html">pychnosz.models.supcrt92_fortran</a></code></dt>
<dd>
<div class="desc"><p>SUPCRT92 water model with Fortran backend …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pychnosz.models.Berman"><code class="name flex">
<span>def <span class="ident">Berman</span></span>(<span>name: str,<br>T: float | List[float] = 298.15,<br>P: float | List[float] = 1,<br>check_G: bool = False,<br>calc_transition: bool = True,<br>calc_disorder: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Berman(name: str, T: Union[float, List[float]] = 298.15, P: Union[float, List[float]] = 1, 
           check_G: bool = False, calc_transition: bool = True, calc_disorder: bool = True) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate thermodynamic properties of minerals using Berman equations.
    
    Parameters
    ----------
    name : str
        Name of the mineral
    T : float or list, optional
        Temperature in Kelvin (default: 298.15)
    P : float or list, optional  
        Pressure in bar (default: 1)
    check_G : bool, optional
        Check consistency of G in data file (default: False)
    calc_transition : bool, optional
        Calculate polymorphic transition contributions (default: True)
    calc_disorder : bool, optional
        Calculate disorder contributions (default: True)
        
    Returns
    -------
    pd.DataFrame
        DataFrame with columns T, P, G, H, S, Cp, V
    &#34;&#34;&#34;
    
    # Reference temperature and pressure
    Pr = 1
    Tr = 298.15
    
    # Make T and P the same length
    if isinstance(T, (int, float)):
        T = [T]
    if isinstance(P, (int, float)):
        P = [P]

    # Convert to list if numpy array (to avoid element-wise multiplication bug)
    if isinstance(T, np.ndarray):
        T = T.tolist()
    if isinstance(P, np.ndarray):
        P = P.tolist()

    ncond = max(len(T), len(P))
    T = np.array(T * (ncond // len(T) + 1), dtype=float)[:ncond]
    P = np.array(P * (ncond // len(P) + 1), dtype=float)[:ncond]
    
    # Get parameters in the Berman equations
    # Start with thermodynamic parameters provided with CHNOSZ
    thermo_sys = thermo()
    if thermo_sys.Berman is None:
        raise RuntimeError(&#34;Berman data not loaded. Please run pychnosz.reset() first.&#34;)
    
    dat = thermo_sys.Berman.copy()
    
    # TODO: Handle user-supplied data file (thermo()$opt$Berman)
    # For now, just use the default data
    
    # Remove duplicates (only the first, i.e. most recent entry is kept)
    dat = dat.drop_duplicates(subset=[&#39;name&#39;], keep=&#39;first&#39;)
    
    # Remove the multipliers on volume parameters
    vcols = [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;, &#39;v4&#39;]  # columns with v1, v2, v3, v4
    multexp = [5, 5, 5, 8]
    for i, col in enumerate(vcols):
        if col in dat.columns:
            dat[col] = dat[col] / (10 ** multexp[i])
    
    # Which row has data for this mineral?
    matching_rows = dat[dat[&#39;name&#39;] == name]
    if len(matching_rows) == 0:
        raise ValueError(f&#34;Data for {name} not available in Berman database&#34;)
    
    dat_mineral = matching_rows.iloc[0]
    
    # Extract parameters for easier access
    GfPrTr = dat_mineral[&#39;GfPrTr&#39;]
    HfPrTr = dat_mineral[&#39;HfPrTr&#39;] 
    SPrTr = dat_mineral[&#39;SPrTr&#39;]
    VPrTr = dat_mineral[&#39;VPrTr&#39;]
    
    k0 = dat_mineral[&#39;k0&#39;]
    k1 = dat_mineral[&#39;k1&#39;] 
    k2 = dat_mineral[&#39;k2&#39;]
    k3 = dat_mineral[&#39;k3&#39;]
    k4 = dat_mineral[&#39;k4&#39;] if not pd.isna(dat_mineral[&#39;k4&#39;]) else 0
    k5 = dat_mineral[&#39;k5&#39;] if not pd.isna(dat_mineral[&#39;k5&#39;]) else 0
    k6 = dat_mineral[&#39;k6&#39;] if not pd.isna(dat_mineral[&#39;k6&#39;]) else 0
    
    v1 = dat_mineral[&#39;v1&#39;] if not pd.isna(dat_mineral[&#39;v1&#39;]) else 0
    v2 = dat_mineral[&#39;v2&#39;] if not pd.isna(dat_mineral[&#39;v2&#39;]) else 0
    v3 = dat_mineral[&#39;v3&#39;] if not pd.isna(dat_mineral[&#39;v3&#39;]) else 0
    v4 = dat_mineral[&#39;v4&#39;] if not pd.isna(dat_mineral[&#39;v4&#39;]) else 0
    
    # Transition parameters
    Tlambda = dat_mineral[&#39;Tlambda&#39;] if not pd.isna(dat_mineral[&#39;Tlambda&#39;]) else None
    Tref = dat_mineral[&#39;Tref&#39;] if not pd.isna(dat_mineral[&#39;Tref&#39;]) else None
    dTdP = dat_mineral[&#39;dTdP&#39;] if not pd.isna(dat_mineral[&#39;dTdP&#39;]) else None
    l1 = dat_mineral[&#39;l1&#39;] if not pd.isna(dat_mineral[&#39;l1&#39;]) else None
    l2 = dat_mineral[&#39;l2&#39;] if not pd.isna(dat_mineral[&#39;l2&#39;]) else None
    
    # Disorder parameters
    Tmin = dat_mineral[&#39;Tmin&#39;] if not pd.isna(dat_mineral[&#39;Tmin&#39;]) else None
    Tmax = dat_mineral[&#39;Tmax&#39;] if not pd.isna(dat_mineral[&#39;Tmax&#39;]) else None
    d0 = dat_mineral[&#39;d0&#39;] if not pd.isna(dat_mineral[&#39;d0&#39;]) else None
    d1 = dat_mineral[&#39;d1&#39;] if not pd.isna(dat_mineral[&#39;d1&#39;]) else None
    d2 = dat_mineral[&#39;d2&#39;] if not pd.isna(dat_mineral[&#39;d2&#39;]) else None
    d3 = dat_mineral[&#39;d3&#39;] if not pd.isna(dat_mineral[&#39;d3&#39;]) else None
    d4 = dat_mineral[&#39;d4&#39;] if not pd.isna(dat_mineral[&#39;d4&#39;]) else None
    Vad = dat_mineral[&#39;Vad&#39;] if not pd.isna(dat_mineral[&#39;Vad&#39;]) else None
    
    # Get the entropy of the elements using the chemical formula
    # Get formula from OBIGT and calculate using entropy() function like in R CHNOSZ
    SPrTr_elements = 0
    if thermo_sys.obigt is not None:
        obigt_match = thermo_sys.obigt[thermo_sys.obigt[&#39;name&#39;] == name]
        if len(obigt_match) &gt; 0:
            formula = obigt_match.iloc[0][&#39;formula&#39;]
            # Import entropy function and calculate SPrTr_elements properly
            from ..utils.formula import entropy
            SPrTr_elements = entropy(formula)
    
    # Check that G in data file follows Benson-Helgeson convention
    if check_G and not pd.isna(GfPrTr):
        GfPrTr_calc = HfPrTr - Tr * (SPrTr - SPrTr_elements)
        Gdiff = GfPrTr_calc - GfPrTr
        if abs(Gdiff) &gt;= 1000:
            warnings.warn(f&#34;{name}: GfPrTr(calc) - GfPrTr(table) is too big! == {round(Gdiff)} J/mol&#34;)
    
    ### Thermodynamic properties ###
    # Calculate Cp and V (Berman, 1988 Eqs. 4 and 5)
    # k4, k5, k6 terms from winTWQ documentation (doi:10.4095/223425)
    Cp = k0 + k1 * T**(-0.5) + k2 * T**(-2) + k3 * T**(-3) + k4 * T**(-1) + k5 * T + k6 * T**2
    
    P_Pr = P - Pr
    T_Tr = T - Tr
    V = VPrTr * (1 + v1 * T_Tr + v2 * T_Tr**2 + v3 * P_Pr + v4 * P_Pr**2)
    
    # Calculate Ha (symbolically integrated using sympy - expressions not simplified)
    intCp = (T*k0 - Tr*k0 + k2/Tr - k2/T + k3/(2*Tr**2) - k3/(2*T**2) + 2.0*k1*T**0.5 - 2.0*k1*Tr**0.5 + 
             k4*np.log(T) - k4*np.log(Tr) + k5*T**2/2 - k5*Tr**2/2 - k6*Tr**3/3 + k6*T**3/3)
    
    intVminusTdVdT = (-VPrTr + P*(VPrTr + VPrTr*v4 - VPrTr*v3 - Tr*VPrTr*v1 + VPrTr*v2*Tr**2 - VPrTr*v2*T**2) +
                      P**2*(VPrTr*v3/2 - VPrTr*v4) + VPrTr*v3/2 - VPrTr*v4/3 + Tr*VPrTr*v1 + 
                      VPrTr*v2*T**2 - VPrTr*v2*Tr**2 + VPrTr*v4*P**3/3)
    
    Ha = HfPrTr + intCp + intVminusTdVdT
    
    # Calculate S (also symbolically integrated)
    intCpoverT = (k0*np.log(T) - k0*np.log(Tr) - k3/(3*T**3) + k3/(3*Tr**3) + k2/(2*Tr**2) - k2/(2*T**2) + 
                  2.0*k1*Tr**(-0.5) - 2.0*k1*T**(-0.5) + k4/Tr - k4/T + T*k5 - Tr*k5 + k6*T**2/2 - k6*Tr**2/2)
    
    intdVdT = -VPrTr*(v1 + v2*(-2*Tr + 2*T)) + P*VPrTr*(v1 + v2*(-2*Tr + 2*T))
    
    S = SPrTr + intCpoverT - intdVdT
    
    # Calculate Ga --&gt; Berman-Brown convention (DG = DH - T*S, no S(element))
    Ga = Ha - T * S
    
    ### Polymorphic transition properties ###
    if (Tlambda is not None and Tref is not None and 
        not pd.isna(Tlambda) and not pd.isna(Tref) and 
        np.any(T &gt; Tref) and calc_transition):
        
        # Starting transition contributions are 0
        Cptr = np.zeros(ncond)
        Htr = np.zeros(ncond)
        Str = np.zeros(ncond)
        
        # Eq. 9: Tlambda at P
        Tlambda_P = Tlambda + dTdP * (P - 1)
        
        # Eq. 8a: Cp at P
        Td = Tlambda - Tlambda_P
        Tprime = T + Td
        
        # With the condition that Tref &lt; Tprime &lt; Tlambda(1bar)
        iTprime = (Tref &lt; Tprime) &amp; (Tprime &lt; Tlambda)
        # Handle NA values
        iTprime = iTprime &amp; ~np.isnan(Tprime)
        
        if np.any(iTprime):
            Tprime_valid = Tprime[iTprime]
            Cptr[iTprime] = Tprime_valid * (l1 + l2 * Tprime_valid)**2
        
        # We got Cp, now calculate the integrations for H and S
        iTtr = T &gt; Tref
        if np.any(iTtr):
            Ttr = T[iTtr].copy()
            Tlambda_P_tr = Tlambda_P[iTtr].copy()
            Td_tr = Td[iTtr] if hasattr(Td, &#39;__len__&#39;) else np.full_like(Ttr, Td)
            
            # Handle NA values
            Tlambda_P_tr[np.isnan(Tlambda_P_tr)] = np.inf
            
            # The upper integration limit is Tlambda_P
            Ttr[Ttr &gt;= Tlambda_P_tr] = Tlambda_P_tr[Ttr &gt;= Tlambda_P_tr]
            
            # Derived variables
            tref = Tref - Td_tr
            x1 = l1**2 * Td_tr + 2 * l1 * l2 * Td_tr**2 + l2**2 * Td_tr**3
            x2 = l1**2 + 4 * l1 * l2 * Td_tr + 3 * l2**2 * Td_tr**2
            x3 = 2 * l1 * l2 + 3 * l2**2 * Td_tr
            x4 = l2**2
            
            # Eqs. 10, 11, 12
            Htr[iTtr] = (x1 * (Ttr - tref) + x2/2 * (Ttr**2 - tref**2) + 
                        x3/3 * (Ttr**3 - tref**3) + x4/4 * (Ttr**4 - tref**4))
            Str[iTtr] = (x1 * (np.log(Ttr) - np.log(tref)) + x2 * (Ttr - tref) + 
                        x3/2 * (Ttr**2 - tref**2) + x4/3 * (Ttr**3 - tref**3))
        
        Gtr = Htr - T * Str
        
        # Apply the transition contributions
        Ga = Ga + Gtr
        Ha = Ha + Htr
        S = S + Str
        Cp = Cp + Cptr
    
    ### Disorder thermodynamic properties ###
    if (Tmin is not None and Tmax is not None and 
        not pd.isna(Tmin) and not pd.isna(Tmax) and 
        np.any(T &gt; Tmin) and calc_disorder):
        
        # Starting disorder contributions are 0
        Cpds = np.zeros(ncond)
        Hds = np.zeros(ncond)
        Sds = np.zeros(ncond)
        Vds = np.zeros(ncond)
        
        # The lower integration limit is Tmin
        iTds = T &gt; Tmin
        if np.any(iTds):
            Tds = T[iTds].copy()
            # The upper integration limit is Tmax
            Tds[Tds &gt; Tmax] = Tmax
            
            # Ber88 Eqs. 15, 16, 17
            Cpds[iTds] = d0 + d1*Tds**(-0.5) + d2*Tds**(-2) + d3*Tds + d4*Tds**2
            Hds[iTds] = (d0*(Tds - Tmin) + d1*(Tds**0.5 - Tmin**0.5)/0.5 +
                        d2*(Tds**(-1) - Tmin**(-1))/(-1) + d3*(Tds**2 - Tmin**2)/2 + d4*(Tds**3 - Tmin**3)/3)
            Sds[iTds] = (d0*(np.log(Tds) - np.log(Tmin)) + d1*(Tds**(-0.5) - Tmin**(-0.5))/(-0.5) +
                        d2*(Tds**(-2) - Tmin**(-2))/(-2) + d3*(Tds - Tmin) + d4*(Tds**2 - Tmin**2)/2)
        
        # Eq. 18; we can&#39;t do this if Vad == 0 (dolomite and gehlenite)
        if Vad is not None and not pd.isna(Vad) and Vad != 0:
            Vds = Hds / Vad
        
        # Include the Vds term with Hds
        Hds = Hds + Vds * (P - Pr)
        
        # Disordering properties above Tmax (Eq. 20)
        ihigh = T &gt; Tmax
        if np.any(ihigh):
            Hds[ihigh] = Hds[ihigh] - (T[ihigh] - Tmax) * Sds[ihigh]
        
        Gds = Hds - T * Sds
        
        # Apply the disorder contributions
        Ga = Ga + Gds
        Ha = Ha + Hds
        S = S + Sds
        V = V + Vds
        Cp = Cp + Cpds
    
    ### (for testing) Use G = H - TS to check that integrals for H and S are written correctly
    Ga_fromHminusTS = Ha - T * S
    if not np.allclose(Ga_fromHminusTS, Ga, atol=1e-6):
        raise RuntimeError(f&#34;{name}: incorrect integrals detected using DG = DH - T*S&#34;)
    
    ### Thermodynamic and unit conventions used in SUPCRT ###
    # Use entropy of the elements in calculation of G --&gt; Benson-Helgeson convention (DG = DH - T*DS)
    Gf = Ga + Tr * SPrTr_elements
    
    # The output will just have &#34;G&#34; and &#34;H&#34;
    G = Gf
    H = Ha
    
    # Convert J/bar to cm^3/mol
    V = V * 10
    
    return pd.DataFrame({
        &#39;T&#39;: T,
        &#39;P&#39;: P, 
        &#39;G&#39;: G,
        &#39;H&#39;: H,
        &#39;S&#39;: S,
        &#39;Cp&#39;: Cp,
        &#39;V&#39;: V
    })</code></pre>
</details>
<div class="desc"><p>Calculate thermodynamic properties of minerals using Berman equations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the mineral</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>list</code>, optional</dt>
<dd>Temperature in Kelvin (default: 298.15)</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float</code> or <code>list</code>, optional</dt>
<dd>Pressure in bar (default: 1)</dd>
<dt><strong><code>check_G</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Check consistency of G in data file (default: False)</dd>
<dt><strong><code>calc_transition</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Calculate polymorphic transition contributions (default: True)</dd>
<dt><strong><code>calc_disorder</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Calculate disorder contributions (default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>DataFrame with columns T, P, G, H, S, Cp, V</dd>
</dl></div>
</dd>
<dt id="pychnosz.models.G2logK"><code class="name flex">
<span>def <span class="ident">G2logK</span></span>(<span>G, Tc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def G2logK(G, Tc):
    # Gas constant R is in cal/mol K
    return G / (-math.log(10) * 1.9872 * (273.15+Tc))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.OBIGT2eos"><code class="name flex">
<span>def <span class="ident">OBIGT2eos</span></span>(<span>OBIGT, fixGHS=True, tocal=True, messages=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OBIGT2eos(OBIGT, fixGHS=True, tocal=True, messages=True):
    &#34;&#34;&#34;
    Convert OBIGT dataframe to equation of state parameters.

    This function processes the OBIGT thermodynamic database to prepare it for
    equation of state calculations. It handles energy unit conversions and
    optionally fills in missing G, H, or S values.

    Parameters
    ----------
    OBIGT : pd.DataFrame
        OBIGT thermodynamic database
    fixGHS : bool, default True
        Fill in one missing value among G, H, S using thermodynamic relations
    tocal : bool, default True
        Convert energy units from Joules to calories
    messages : bool, default True
        Print informational messages (currently not used, reserved for future)

    Returns
    -------
    pd.DataFrame
        Modified OBIGT dataframe with converted parameters
    &#34;&#34;&#34;
    OBIGT_out = OBIGT.copy()

    # Get column indices for named columns (to handle varying column positions)
    G_idx = OBIGT.columns.get_loc(&#39;G&#39;)
    H_idx = OBIGT.columns.get_loc(&#39;H&#39;)
    S_idx = OBIGT.columns.get_loc(&#39;S&#39;)
    Cp_idx = OBIGT.columns.get_loc(&#39;Cp&#39;)
    V_idx = OBIGT.columns.get_loc(&#39;V&#39;)
    omega_lambda_idx = OBIGT.columns.get_loc(&#39;omega.lambda&#39;)

    for i in range(0, OBIGT.shape[0]):

        # we only convert omega for aqueous species, not lambda for cgl species
        if tocal and OBIGT.iloc[i, :][&#34;E_units&#34;] == &#34;J&#34; and OBIGT.iloc[i, :][&#34;state&#34;] == &#34;aq&#34;:
            # Convert G, H, S, Cp
            OBIGT_out.iloc[i, G_idx:Cp_idx+1] = OBIGT.iloc[i, G_idx:Cp_idx+1]/4.184
            # Convert V through omega (includes omega for aq species)
            OBIGT_out.iloc[i, V_idx:omega_lambda_idx+1] = OBIGT.iloc[i, V_idx:omega_lambda_idx+1]/4.184
            OBIGT_out.iloc[i, OBIGT.columns.get_loc(&#39;E_units&#39;)] = &#34;cal&#34;

        elif tocal and OBIGT.iloc[i, :][&#34;E_units&#34;] == &#34;J&#34;:
            # Convert G, H, S, Cp
            OBIGT_out.iloc[i, G_idx:Cp_idx+1] = OBIGT.iloc[i, G_idx:Cp_idx+1]/4.184
            # Convert V through c2.f (exclude omega.lambda for non-aq species)
            OBIGT_out.iloc[i, V_idx:omega_lambda_idx] = OBIGT.iloc[i, V_idx:omega_lambda_idx]/4.184
            OBIGT_out.iloc[i, OBIGT.columns.get_loc(&#39;E_units&#39;)] = &#34;cal&#34;

        # fill in one of missing G, H, S
        # for use esp. by subcrt because NA for one of G, H or S
        # will preclude calculations at high T
        if fixGHS:
            # which entries are missing just one
            GHS_values = [OBIGT.iloc[i, G_idx], OBIGT.iloc[i, H_idx], OBIGT.iloc[i, S_idx]]
            imiss = [pd.isna(v) for v in GHS_values]
            if sum(imiss) == 1:

                ii = imiss.index(True)

                if ii == 0:  # G is missing
                    H = OBIGT_out.iloc[i, H_idx]
                    S = OBIGT_out.iloc[i, S_idx]
                    Selem = entropy(OBIGT_out.iloc[i, OBIGT_out.columns.get_loc(&#39;formula&#39;)])
                    T = 298.15
                    G = H - T*(S - Selem)
                    OBIGT_out.iloc[i, G_idx] = G
                elif ii == 1:  # H is missing
                    G = OBIGT_out.iloc[i, G_idx]
                    S = OBIGT_out.iloc[i, S_idx]
                    Selem = entropy(OBIGT_out.iloc[i, OBIGT_out.columns.get_loc(&#39;formula&#39;)])
                    T = 298.15
                    H = G + T*(S - Selem)
                    OBIGT_out.iloc[i, H_idx] = H
                elif ii == 2:  # S is missing
                    G = OBIGT_out.iloc[i, G_idx]
                    H = OBIGT_out.iloc[i, H_idx]
                    Selem = entropy(OBIGT_out.iloc[i, OBIGT_out.columns.get_loc(&#39;formula&#39;)])
                    T = 298.15
                    S = Selem + (H - G)/T
                    OBIGT_out.iloc[i, S_idx] = S

    return OBIGT_out</code></pre>
</details>
<div class="desc"><p>Convert OBIGT dataframe to equation of state parameters.</p>
<p>This function processes the OBIGT thermodynamic database to prepare it for
equation of state calculations. It handles energy unit conversions and
optionally fills in missing G, H, or S values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>OBIGT</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>OBIGT thermodynamic database</dd>
<dt><strong><code>fixGHS</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Fill in one missing value among G, H, S using thermodynamic relations</dd>
<dt><strong><code>tocal</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Convert energy units from Joules to calories</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Print informational messages (currently not used, reserved for future)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Modified OBIGT dataframe with converted parameters</dd>
</dl></div>
</dd>
<dt id="pychnosz.models.available_properties"><code class="name flex">
<span>def <span class="ident">available_properties</span></span>(<span>model: str = 'SUPCRT92') ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def available_properties(model: str = &#39;SUPCRT92&#39;) -&gt; List[str]:
    &#34;&#34;&#34;
    Get list of available properties for a water model.
    
    Parameters
    ----------
    model : str
        Water model name (&#39;SUPCRT92&#39;, &#39;IAPWS95&#39;, or &#39;DEW&#39;)
        
    Returns
    -------
    List[str]
        List of available property names
    &#34;&#34;&#34;
    model = model.upper()
    
    if model in [&#39;SUPCRT92&#39;, &#39;SUPCRT&#39;]:
        from .supcrt92 import supcrt92_water
        return supcrt92_water.available_properties()
    elif model in [&#39;IAPWS95&#39;, &#39;IAPWS&#39;]:
        from .iapws95 import iapws95_water
        return iapws95_water.available_properties()
    elif model == &#39;DEW&#39;:
        from .dew import dew_water
        return dew_water.available_properties()
    else:
        raise ValueError(f&#34;Unknown water model: {model}&#34;)</code></pre>
</details>
<div class="desc"><p>Get list of available properties for a water model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>str</code></dt>
<dd>Water model name ('SUPCRT92', 'IAPWS95', or 'DEW')</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of available property names</dd>
</dl></div>
</dd>
<dt id="pychnosz.models.calc_G_TP"><code class="name flex">
<span>def <span class="ident">calc_G_TP</span></span>(<span>OBIGT, Tc, P, water_model)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_G_TP(OBIGT, Tc, P, water_model):
    
    aq_out, H2O_Pt = hkf(property=[&#34;G&#34;], parameters=OBIGT,
                         T=273.15+Tc, P=P, contrib=[&#34;n&#34;, &#34;s&#34;, &#34;o&#34;],
                         H2O_props=[&#34;rho&#34;], water_model=water_model)
    
    cgl_out = cgl(property=[&#34;G&#34;], parameters=OBIGT, T=273.15+Tc, P=P)
    
    aq_col = pd.DataFrame.from_dict(aq_out, orient=&#34;index&#34;)
    cgl_col = pd.DataFrame.from_dict(cgl_out, orient=&#34;index&#34;)

    G_TP_df = pd.concat([aq_col, cgl_col], axis=1)
    G_TP_df.columns = [&#39;aq&#39;,&#39;cgl&#39;]
    
    OBIGT[&#34;G_TP&#34;] = G_TP_df[&#39;aq&#39;].combine_first(G_TP_df[&#39;cgl&#39;])
    
    rows_added = 0

    # add a row for water
    if &#34;H2O&#34; not in list(OBIGT[&#34;name&#34;]):
        # Set the water model (without printing messages)
        water(water_model, messages=False)
        # water() returns a scalar when called with single property and scalar T, P
        # The result is in J/mol, need to convert to cal/mol by dividing by 4.184
        G_water = water(&#34;G&#34;, T=Tc+273.15, P=P, messages=False)
        # Handle both scalar and DataFrame returns
        if isinstance(G_water, pd.DataFrame):
            G_water_cal = G_water.iloc[0][&#34;G&#34;] / 4.184
        else:
            G_water_cal = float(G_water) / 4.184
        OBIGT = pd.concat([OBIGT, pd.DataFrame({&#34;name&#34;: &#34;H2O&#34;, &#34;tag&#34;: &#34;nan&#34;, &#34;G_TP&#34;: G_water_cal}, index=[OBIGT.shape[0]])], ignore_index=True)
        rows_added += 1

    # add a row for protons
    if &#34;H+&#34; not in list(OBIGT[&#34;name&#34;]):
        OBIGT = pd.concat([OBIGT, pd.DataFrame({&#34;name&#34;: &#34;H+&#34;, &#34;tag&#34;: &#34;nan&#34;, &#34;G_TP&#34;: 0}, index=[OBIGT.shape[0]])], ignore_index=True)
        rows_added += 1

    return OBIGT, rows_added</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.calc_logK"><code class="name flex">
<span>def <span class="ident">calc_logK</span></span>(<span>OBIGT_df, Tc, P, TP_i, water_model)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_logK(OBIGT_df, Tc, P, TP_i, water_model):
    
    OBIGT_TP, rows_added = calc_G_TP(OBIGT_df, Tc, P, water_model)
    
    dissrxn2logK_out = []
    for i in OBIGT_TP.index:
        dissrxn2logK_out.append(dissrxn2logK(OBIGT_TP, i, Tc))
    assert len(dissrxn2logK_out) == OBIGT_TP.shape[0]
    
    OBIGT_TP[&#39;dissrxn_logK_&#39;+str(TP_i)] = dissrxn2logK_out
    
    # remove any rows added by calc_G_TP
    OBIGT_TP.drop(OBIGT_TP.tail(rows_added).index, inplace = True)
    
    return OBIGT_TP</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.cgl"><code class="name flex">
<span>def <span class="ident">cgl</span></span>(<span>property=None, parameters=None, T=298.15, P=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cgl(property = None, parameters = None, T = 298.15, P = 1):
    # calculate properties of crystalline, liquid (except H2O) and gas species
    Tr = 298.15
    Pr = 1

    # Convert T and P to arrays for vectorized operations
    T = np.atleast_1d(T)
    P = np.atleast_1d(P)

    # make T and P equal length
    if P.size &lt; T.size:
        P = np.full_like(T, P[0] if P.size == 1 else P)
    if T.size &lt; P.size:
        T = np.full_like(P, T[0] if T.size == 1 else T)

    n_conditions = T.size
    # initialize output dict
    out_dict = dict()
    # loop over each species
    
    # Iterate over each row by position to handle duplicate indices properly
    for i in range(len(parameters)):
        # Get the index label for this row
        k = parameters.index[i]
        # Get the row data by position (iloc) to avoid duplicate index issues
        PAR = parameters.iloc[i]

        if PAR[&#34;state&#34;] == &#34;aq&#34;:
            # For aqueous species processed by CGL, return NaN
            # (they should be processed by HKF instead)
            out_dict[k] = {p:float(&#39;NaN&#39;) for p in property}
        else:

            # OBIGT database stores G, H, S in calories (E_units = &#34;cal&#34;)
            # CGL calculations use calories (integrals intCpdT, intCpdlnT, intVdP are in cal)
            # Results are output in calories and converted to J in subcrt.py at line 959

            # Parameter scaling - SUPCRT92 data is already in correct units
            # PAR[&#34;a2.b&#34;] = copy.copy(PAR[&#34;a2.b&#34;]*10**-3)
            # PAR[&#34;a3.c&#34;] = copy.copy(PAR[&#34;a3.c&#34;]*10**5) 
            # PAR[&#34;c1.e&#34;] = copy.copy(PAR[&#34;c1.e&#34;]*10**-5)

            # Check if this is a Berman mineral (columns 9-21 are all NA in R indexing)
            # In Python/pandas, we check the relevant thermodynamic parameter columns
            # NOTE: A mineral is only Berman if it LACKS standard thermodynamic data (G,H,S)
            # If G,H,S are present, use regular CGL even if heat capacity coefficients are all zero
            berman_cols = [&#39;a1.a&#39;, &#39;a2.b&#39;, &#39;a3.c&#39;, &#39;a4.d&#39;, &#39;c1.e&#39;, &#39;c2.f&#39;, &#39;omega.lambda&#39;, &#39;z.T&#39;]
            has_standard_thermo = pd.notna(PAR.get(&#39;G&#39;, np.nan)) and pd.notna(PAR.get(&#39;H&#39;, np.nan)) and pd.notna(PAR.get(&#39;S&#39;, np.nan))
            all_coeffs_zero_or_na = all(pd.isna(PAR.get(col, np.nan)) or PAR.get(col, 0) == 0 for col in berman_cols)
            is_berman_mineral = all_coeffs_zero_or_na and not has_standard_thermo

            if is_berman_mineral:
                # Use Berman equations (parameters not in thermo()$OBIGT)
                from .berman import Berman
                try:
                    # Berman is already vectorized - pass T and P arrays directly
                    properties_df = Berman(PAR[&#34;name&#34;], T=T, P=P)
                    # Extract the requested properties as arrays
                    values = {}
                    for prop in property:
                        if prop in properties_df.columns:
                            # Get all values as an array
                            prop_values = properties_df[prop].values

                            # IMPORTANT: Berman function returns values in J/mol (Joules)
                            # but CGL returns values in cal/mol (calories)
                            # Convert Berman results from J/mol to cal/mol for consistency
                            # Energy properties that need conversion: G, H, S, Cp
                            # Volume (V) and other properties don&#39;t need conversion
                            energy_props = [&#39;G&#39;, &#39;H&#39;, &#39;S&#39;, &#39;Cp&#39;]
                            if prop in energy_props:
                                # Convert J/mol to cal/mol by dividing by 4.184
                                prop_values = prop_values / 4.184

                            values[prop] = prop_values
                        else:
                            values[prop] = np.full(n_conditions, float(&#39;NaN&#39;))
                except Exception as e:
                    # If Berman calculation fails, fall back to NaN arrays
                    values = {prop: np.full(n_conditions, float(&#39;NaN&#39;)) for prop in property}
            else:
                # Use regular CGL equations
                
                # in CHNOSZ, we have
                # 1 cm^3 bar --&gt; convert(1, &#34;calories&#34;) == 0.02390057 cal
                # but REAC92D.F in SUPCRT92 uses
                cm3bar_to_cal = 0.023901488 # cal
                # start with NA values
                values = dict()
                # a test for availability of heat capacity coefficients (a, b, c, d, e, f)
                # based on the column assignments in thermo()$OBIGT

                # Check for heat capacity coefficients, handling both NaN and non-numeric values
                # Heat capacity coefficients are at positions 14-19 (a1.a through c2.f)
                # Position 13 is V (volume), not a heat capacity coefficient
                has_hc_coeffs = False
                try:
                    hc_values = list(PAR.iloc[14:20])
                    has_hc_coeffs = any([pd.notna(p) and p != 0 for p in hc_values if pd.api.types.is_numeric_dtype(type(p))])

                    # DEBUG
                    if False and PAR[&#34;name&#34;] == &#34;rhomboclase&#34;:
                        print(f&#34;DEBUG for rhomboclase:&#34;)
                        print(f&#34;  hc_values (iloc[14:20]): {hc_values}&#34;)
                        print(f&#34;  has_hc_coeffs: {has_hc_coeffs}&#34;)
                except Exception as e:
                    has_hc_coeffs = False

                if has_hc_coeffs:
                    # we have at least one of the heat capacity coefficients;
                    # zero out any NA&#39;s in the rest (leave lambda and T of transition (columns 20-21) alone)
                    for i in range(14, 20):
                        if pd.isna(PAR.iloc[i]) or not pd.api.types.is_numeric_dtype(type(PAR.iloc[i])):
                            PAR.iloc[i] = 0.0
                    # calculate the heat capacity and its integrals (vectorized)
                    Cp = PAR[&#34;a1.a&#34;] + PAR[&#34;a2.b&#34;]*T + PAR[&#34;a3.c&#34;]*T**-2 + PAR[&#34;a4.d&#34;]*T**-0.5 + PAR[&#34;c1.e&#34;]*T**2 + PAR[&#34;c2.f&#34;]*T**PAR[&#34;omega.lambda&#34;]
                    intCpdT = PAR[&#34;a1.a&#34;]*(T - Tr) + PAR[&#34;a2.b&#34;]*(T**2 - Tr**2)/2 + PAR[&#34;a3.c&#34;]*(1/T - 1/Tr)/-1 + PAR[&#34;a4.d&#34;]*(T**0.5 - Tr**0.5)/0.5 + PAR[&#34;c1.e&#34;]*(T**3-Tr**3)/3
                    intCpdlnT = PAR[&#34;a1.a&#34;]*np.log(T / Tr) + PAR[&#34;a2.b&#34;]*(T - Tr) + PAR[&#34;a3.c&#34;]*(T**-2 - Tr**-2)/-2 + PAR[&#34;a4.d&#34;]*(T**-0.5 - Tr**-0.5)/-0.5  + PAR[&#34;c1.e&#34;]*(T**2 - Tr**2)/2

                    # do we also have the lambda parameter (Cp term with adjustable exponent on T)?
                    if pd.notna(PAR[&#34;omega.lambda&#34;]) and PAR[&#34;omega.lambda&#34;] != 0:
                        # equations for lambda adapted from Helgeson et al., 1998 (doi:10.1016/S0016-7037(97)00219-6)
                        if PAR[&#34;omega.lambda&#34;] == -1:
                            intCpdT = intCpdT + PAR[&#34;c2.f&#34;]*np.log(T/Tr)
                        else:
                            intCpdT = intCpdT - PAR[&#34;c2.f&#34;]*( T**(PAR[&#34;omega.lambda&#34;] + 1) - Tr**(PAR[&#34;omega.lambda&#34;] + 1) ) / (PAR[&#34;omega.lambda&#34;] + 1)
                        intCpdlnT = intCpdlnT + PAR[&#34;c2.f&#34;]*(T**PAR[&#34;omega.lambda&#34;] - Tr**PAR[&#34;omega.lambda&#34;]) / PAR[&#34;omega.lambda&#34;]

                else:
                    # use constant heat capacity if the coefficients are not available (vectorized)
                    # If Cp is NA/NaN, use 0 (matching R CHNOSZ behavior)
                    Cp_value = PAR[&#34;Cp&#34;] if pd.notna(PAR[&#34;Cp&#34;]) else 0.0
                    Cp = np.full(n_conditions, Cp_value)
                    intCpdT = Cp_value*(T - Tr)
                    intCpdlnT = Cp_value*np.log(T / Tr)
                    # in case Cp is listed as NA, set the integrals to 0 at Tr
                    at_Tr = (T == Tr)
                    intCpdT = np.where(at_Tr, 0, intCpdT)
                    intCpdlnT = np.where(at_Tr, 0, intCpdlnT)


                # volume and its integrals (vectorized)
                if PAR[&#34;name&#34;] in [&#34;quartz&#34;, &#34;coesite&#34;]:
                    # volume calculations for quartz and coesite
                    qtz = quartz_coesite(PAR, T, P)
                    V = qtz[&#34;V&#34;]
                    intVdP = qtz[&#34;intVdP&#34;]
                    intdVdTdP = qtz[&#34;intdVdTdP&#34;]

                else:
                    # for other minerals, volume is constant (Helgeson et al., 1978)
                    V = np.full(n_conditions, PAR[&#34;V&#34;])
                    # if the volume is NA, set its integrals to zero
                    if pd.isna(PAR[&#34;V&#34;]):
                        intVdP = np.zeros(n_conditions)
                        intdVdTdP = np.zeros(n_conditions)
                    else:
                        intVdP = PAR[&#34;V&#34;]*(P - Pr) * cm3bar_to_cal
                        intdVdTdP = np.zeros(n_conditions)

                # get the values of each of the requested thermodynamic properties (vectorized)
                for i,prop in enumerate(property):
                    if prop == &#34;Cp&#34;: values[&#34;Cp&#34;] = Cp
                    if prop == &#34;V&#34;: values[&#34;V&#34;] = V
                    if prop == &#34;E&#34;: values[&#34;E&#34;] = np.full(n_conditions, float(&#39;NaN&#39;))
                    if prop == &#34;kT&#34;: values[&#34;kT&#34;] = np.full(n_conditions, float(&#39;NaN&#39;))
                    if prop == &#34;G&#34;:
                        # calculate S * (T - Tr), but set it to 0 at Tr (in case S is NA)
                        Sterm = PAR[&#34;S&#34;]*(T - Tr)
                        Sterm = np.where(T == Tr, 0, Sterm)

                        # DEBUG
                        if False and PAR[&#34;name&#34;] == &#34;iron&#34; and PAR.get(&#34;state&#34;) == &#34;cr4&#34;:
                            print(f&#34;DEBUG G calculation for {PAR[&#39;name&#39;]} {PAR.get(&#39;state&#39;, &#39;unknown&#39;)}:&#34;)
                            print(f&#34;  PAR[&#39;G&#39;] = {PAR[&#39;G&#39;]}&#34;)
                            print(f&#34;  PAR[&#39;S&#39;] = {PAR[&#39;S&#39;]}&#34;)
                            print(f&#34;  model = {PAR.get(&#39;model&#39;, &#39;unknown&#39;)}&#34;)
                            print(f&#34;  Sterm[0] = {Sterm[0] if hasattr(Sterm, &#39;__len__&#39;) else Sterm}&#34;)
                            print(f&#34;  intCpdT[0] = {intCpdT[0] if hasattr(intCpdT, &#39;__len__&#39;) else intCpdT}&#34;)
                            print(f&#34;  T[0]*intCpdlnT[0] = {(T[0]*intCpdlnT[0]) if hasattr(intCpdlnT, &#39;__len__&#39;) else T*intCpdlnT}&#34;)
                            print(f&#34;  intVdP[0] = {intVdP[0] if hasattr(intVdP, &#39;__len__&#39;) else intVdP}&#34;)
                            G_calc = PAR[&#39;G&#39;] - Sterm + intCpdT - T*intCpdlnT + intVdP
                            print(f&#34;  G[0] (before subcrt conversion) = {G_calc[0] if hasattr(G_calc, &#39;__len__&#39;) else G_calc}&#34;)

                        values[&#34;G&#34;] = PAR[&#34;G&#34;] - Sterm + intCpdT - T*intCpdlnT + intVdP
                    if prop == &#34;H&#34;:
                        values[&#34;H&#34;] = PAR[&#34;H&#34;] + intCpdT + intVdP - T*intdVdTdP
                    if prop == &#34;S&#34;: values[&#34;S&#34;] = PAR[&#34;S&#34;] + intCpdlnT - intdVdTdP

            out_dict[k] = values # species have to be numbered instead of named because of name repeats (e.g., cr polymorphs)

    return out_dict</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.compare_models"><code class="name flex">
<span>def <span class="ident">compare_models</span></span>(<span>property: str,<br>T: float | numpy.ndarray = 298.15,<br>P: float | numpy.ndarray = 1.0) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_models(property: str, 
                   T: Union[float, np.ndarray] = 298.15,
                   P: Union[float, np.ndarray] = 1.0) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Compare water property calculations across different models.
    
    Parameters
    ----------
    property : str
        Property to compare
    T : float or array
        Temperature in Kelvin
    P : float or array
        Pressure in bar
        
    Returns
    -------
    pd.DataFrame
        Comparison of property values from different models
    &#34;&#34;&#34;
    T = np.atleast_1d(np.asarray(T, dtype=float))
    P = np.atleast_1d(np.asarray(P, dtype=float))
    
    results = {}
    models = [&#39;SUPCRT92&#39;, &#39;IAPWS95&#39;, &#39;DEW&#39;]
    
    for model in models:
        try:
            if model == &#39;SUPCRT92&#39;:
                result = water_SUPCRT92(property, T, P)
            elif model == &#39;IAPWS95&#39;:
                # Convert bar to kPa for IAPWS95
                result = water_IAPWS95(property, T, P * 100.0)
                # Convert units back if needed
                if property == &#39;rho&#39;:
                    result = result / 1000.0  # kg/m³ to g/cm³
            elif model == &#39;DEW&#39;:
                result = water_DEW(property, T, P)
            
            results[model] = result
            
        except Exception as e:
            print(f&#34;Error with {model}: {e}&#34;)
            results[model] = np.full_like(T, np.nan)
    
    # Create DataFrame
    if len(T) == 1 and len(P) == 1:
        # Single point
        data = {model: [results[model]] if np.isscalar(results[model]) else results[model] 
                for model in models}
        df = pd.DataFrame(data, index=[f&#34;T={T[0]:.1f}K, P={P[0]:.1f}bar&#34;])
    else:
        # Multiple points
        data = {model: results[model] for model in models}
        index = [f&#34;T={t:.1f}K, P={p:.1f}bar&#34; for t, p in zip(T, P)]
        df = pd.DataFrame(data, index=index)
    
    return df</code></pre>
</details>
<div class="desc"><p>Compare water property calculations across different models.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>str</code></dt>
<dd>Property to compare</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>Temperature in Kelvin</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>Pressure in bar</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Comparison of property values from different models</dd>
</dl></div>
</dd>
<dt id="pychnosz.models.convert_cm3bar"><code class="name flex">
<span>def <span class="ident">convert_cm3bar</span></span>(<span>value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_cm3bar(value):
    return value*4.184 * 10</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.dissrxn2logK"><code class="name flex">
<span>def <span class="ident">dissrxn2logK</span></span>(<span>OBIGT, i, Tc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dissrxn2logK(OBIGT, i, Tc):
    
    this_dissrxn = OBIGT.iloc[i, OBIGT.columns.get_loc(&#39;dissrxn&#39;)]
    
    if this_dissrxn == &#34;nan&#34;:
        this_dissrxn = OBIGT.iloc[i, OBIGT.columns.get_loc(&#39;regenerate_dissrxn&#39;)]
    
#     print(OBIGT[&#34;name&#34;][i], this_dissrxn)
    
    try:
        this_dissrxn = this_dissrxn.strip()
        split_dissrxn = this_dissrxn.split(&#34; &#34;)
    except:
        return float(&#39;NaN&#39;)
    
    
    
    coeff = [float(n) for n in split_dissrxn[::2]]
    species = split_dissrxn[1::2]
    try:
        G = sum([float(c*OBIGT.loc[OBIGT[&#34;name&#34;]==sp, &#34;G_TP&#34;].iloc[0]) for c,sp in zip(coeff, species)])
    except:
        G_list = []
        for ii, sp in enumerate(species):
            G_TP = OBIGT.loc[OBIGT[&#34;name&#34;]==sp, &#34;G_TP&#34;]
            if len(G_TP) == 1:
                G_list.append(float(coeff[ii]*OBIGT.loc[OBIGT[&#34;name&#34;]==sp, &#34;G_TP&#34;]))
            else:
                ### check valid polymorph T

                # get polymorph entries of OBIGT that match mineral
                poly_df = copy.copy(OBIGT.loc[OBIGT[&#34;name&#34;]==sp,:])
                # ensure polymorph df is sorted according to cr, cr2, cr3... etc.
                poly_df = poly_df.sort_values(&#34;state&#34;)

                z_Ts = list(poly_df.loc[poly_df[&#34;name&#34;]==sp, &#34;z.T&#34;])

                last_t = float(&#39;-inf&#39;)
                appended=False
                for iii,t in enumerate(z_Ts):

                    if Tc+273.15 &gt; last_t and Tc+273.15 &lt; t:
                        G_list.append(float(coeff[ii]*list(poly_df.loc[poly_df[&#34;name&#34;]==sp, &#34;G_TP&#34;])[iii]))
                        appended=True
                    if not appended and z_Ts[-1] == t:
                        G_list.append(float(coeff[ii]*list(poly_df.loc[poly_df[&#34;name&#34;]==sp, &#34;G_TP&#34;])[iii]))
                    last_t = t

        G = sum(G_list)

    return G2logK(G, Tc)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.get_water_models"><code class="name flex">
<span>def <span class="ident">get_water_models</span></span>(<span>) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_water_models() -&gt; List[str]:
    &#34;&#34;&#34;
    Get list of available water models.
    
    Returns
    -------
    List[str]
        List of available water model names
    &#34;&#34;&#34;
    return [&#39;SUPCRT92&#39;, &#39;IAPWS95&#39;, &#39;DEW&#39;]</code></pre>
</details>
<div class="desc"><p>Get list of available water models.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of available water model names</dd>
</dl></div>
</dd>
<dt id="pychnosz.models.gfun"><code class="name flex">
<span>def <span class="ident">gfun</span></span>(<span>rhohat, Tc, P, alpha, daldT, beta)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gfun(rhohat, Tc, P, alpha, daldT, beta):
    ## g and f functions for describing effective electrostatic radii of ions
    ## split from hkf() 20120123 jmd
    ## based on equations in
    ## Shock EL, Oelkers EH, Johnson JW, Sverjensky DA, Helgeson HC, 1992
    ## Calculation of the Thermodynamic Properties of Aqueous Species at High Pressures
    ## and Temperatures: Effective Electrostatic Radii, Dissociation Constants and
    ## Standard Partial Molal Properties to 1000 degrees C and 5 kbar
    ## J. Chem. Soc. Faraday Trans., 88(6), 803-826  doi:10.1039/FT9928800803
    # rhohat - density of water in g/cm3
    # Tc - temperature in degrees Celsius
    # P - pressure in bars

    # Vectorized version - handle both scalars and arrays
    rhohat = np.atleast_1d(rhohat)
    Tc = np.atleast_1d(Tc)
    P = np.atleast_1d(P)
    alpha = np.atleast_1d(alpha)
    daldT = np.atleast_1d(daldT)
    beta = np.atleast_1d(beta)

    # Broadcast to same shape
    shape = np.broadcast_shapes(rhohat.shape, Tc.shape, P.shape, alpha.shape, daldT.shape, beta.shape)
    rhohat = np.broadcast_to(rhohat, shape)
    Tc = np.broadcast_to(Tc, shape)
    P = np.broadcast_to(P, shape)
    alpha = np.broadcast_to(alpha, shape)
    daldT = np.broadcast_to(daldT, shape)
    beta = np.broadcast_to(beta, shape)

    # Initialize output arrays
    g = np.zeros(shape)
    dgdT = np.zeros(shape)
    d2gdT2 = np.zeros(shape)
    dgdP = np.zeros(shape)

    # only rhohat less than 1 will give results other than zero
    mask = rhohat &lt; 1
    if not np.any(mask):
        return {&#34;g&#34;: g, &#34;dgdT&#34;: dgdT, &#34;d2gdT2&#34;: d2gdT2, &#34;dgdP&#34;: dgdP}

    # eta in Eq. 1
    eta = 1.66027E5
    # Table 3
    ag1 = -2.037662
    ag2 = 5.747000E-3
    ag3 = -6.557892E-6
    bg1 = 6.107361
    bg2 = -1.074377E-2
    bg3 = 1.268348E-5

    # Work only with masked values
    Tc_m = Tc[mask]
    P_m = P[mask]
    rhohat_m = rhohat[mask]
    alpha_m = alpha[mask]
    daldT_m = daldT[mask]
    beta_m = beta[mask]

    # Eq. 25
    ag = ag1 + ag2 * Tc_m + ag3 * Tc_m ** 2
    # Eq. 26
    bg = bg1 + bg2 * Tc_m + bg3 * Tc_m ** 2
    # Eq. 24
    g_m = ag * (1 - rhohat_m) ** bg

    # Table 4
    af1 = 0.3666666E2
    af2 = -0.1504956E-9
    af3 = 0.5017997E-13

    # Eq. 33
    f = ( ((Tc_m - 155) / 300) ** 4.8 + af1 * ((Tc_m - 155) / 300) ** 16 ) * \
        ( af2 * (1000 - P_m) ** 3 + af3 * (1000 - P_m) ** 4 )

    # limits of the f function (region II of Fig. 6)
    ifg = (Tc_m &gt; 155) &amp; (P_m &lt; 1000) &amp; (Tc_m &lt; 355)

    # Eq. 32 - apply f correction where ifg is True
    # Check for complex values
    f_is_real = ~np.iscomplex(f)
    apply_f = ifg &amp; f_is_real
    g_m = np.where(apply_f, g_m - f.real, g_m)

    # at P &gt; 6000 bar (in DEW calculations), g is zero 20170926
    g_m = np.where(P_m &gt; 6000, 0, g_m)

    ## now we have g at P, T
    # put the results in their right place (where rhohat &lt; 1)
    g[mask] = g_m
    
    ## the rest is to get its partial derivatives with pressure and temperature
    ## after Johnson et al., 1992
    # alpha - coefficient of isobaric expansivity (K^-1)
    # daldT - temperature derivative of coefficient of isobaric expansivity (K^-2)
    # beta - coefficient of isothermal compressibility (bar^-1)

    # Eqn. 76
    d2fdT2 = (0.0608/300*((Tc_m-155)/300)**2.8 + af1/375*((Tc_m-155)/300)**14) * (af2*(1000-P_m)**3 + af3*(1000-P_m)**4)
    # Eqn. 75
    dfdT = (0.016*((Tc_m-155)/300)**3.8 + 16*af1/300*((Tc_m-155)/300)**15) * \
        (af2*(1000-P_m)**3 + af3*(1000-P_m)**4)
    # Eqn. 74
    dfdP = -(((Tc_m-155)/300)**4.8 + af1*((Tc_m-155)/300)**16) * \
        (3*af2*(1000-P_m)**2 + 4*af3*(1000-P_m)**3)
    d2bdT2 = 2 * bg3  # Eqn. 73
    d2adT2 = 2 * ag3  # Eqn. 72
    dbdT = bg2 + 2*bg3*Tc_m  # Eqn. 71
    dadT = ag2 + 2*ag3*Tc_m  # Eqn. 70

    # Convert complex to NaN
    d2fdT2 = np.where(np.iscomplex(d2fdT2), np.nan, np.real(d2fdT2))
    dfdT = np.where(np.iscomplex(dfdT), np.nan, np.real(dfdT))
    dfdP = np.where(np.iscomplex(dfdP), np.nan, np.real(dfdP))

    # Initialize derivative arrays for masked region
    dgdT_m = np.zeros_like(g_m)
    d2gdT2_m = np.zeros_like(g_m)
    dgdP_m = np.zeros_like(g_m)

    # Calculate derivatives where alpha and daldT are not NaN
    alpha_valid = ~np.isnan(alpha_m) &amp; ~np.isnan(daldT_m)
    if np.any(alpha_valid):
        # Work with valid subset
        av_idx = alpha_valid
        bg_av = bg[av_idx]
        rhohat_av = rhohat_m[av_idx]
        alpha_av = alpha_m[av_idx]
        daldT_av = daldT_m[av_idx]
        g_av = g_m[av_idx]
        ag_av = ag[av_idx]
        Tc_av = Tc_m[av_idx]
        dbdT_av = dbdT[av_idx]
        dadT_av = dadT[av_idx]

        # Handle log of (1-rhohat) safely
        with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
            log_term = np.log(1 - rhohat_av)
            log_term = np.where(np.isfinite(log_term), log_term, 0)

        # Eqn. 69
        dgadT = bg_av*rhohat_av*alpha_av*(1-rhohat_av)**(bg_av-1) + log_term*g_av/ag_av*dbdT_av
        D = rhohat_av

        # transcribed from SUPCRT92/reac92.f
        dDdT = -D * alpha_av
        dDdTT = -D * (daldT_av - alpha_av**2)
        Db = (1-D)**bg_av
        dDbdT = -bg_av*(1-D)**(bg_av-1)*dDdT + log_term*Db*dbdT_av
        dDbdTT = -(bg_av*(1-D)**(bg_av-1)*dDdTT + (1-D)**(bg_av-1)*dDdT*dbdT_av + \
            bg_av*dDdT*(-(bg_av-1)*(1-D)**(bg_av-2)*dDdT + log_term*(1-D)**(bg_av-1)*dbdT_av)) + \
            log_term*(1-D)**bg_av*d2bdT2 - (1-D)**bg_av*dbdT_av*dDdT/(1-D) + log_term*dbdT_av*dDbdT
        d2gdT2_calc = ag_av*dDbdTT + 2*dDbdT*dadT_av + Db*d2adT2

        # Apply f correction where ifg is True
        ifg_av = ifg[av_idx]
        d2fdT2_av = d2fdT2[av_idx]
        dfdT_av = dfdT[av_idx]
        d2gdT2_calc = np.where(ifg_av, d2gdT2_calc - d2fdT2_av, d2gdT2_calc)

        dgdT_calc = g_av/ag_av*dadT_av + ag_av*dgadT  # Eqn. 67
        dgdT_calc = np.where(ifg_av, dgdT_calc - dfdT_av, dgdT_calc)

        dgdT_m[av_idx] = dgdT_calc
        d2gdT2_m[av_idx] = d2gdT2_calc

    # Calculate dgdP where beta is not NaN
    beta_valid = ~np.isnan(beta_m)
    if np.any(beta_valid):
        bv_idx = beta_valid
        bg_bv = bg[bv_idx]
        rhohat_bv = rhohat_m[bv_idx]
        beta_bv = beta_m[bv_idx]
        g_bv = g_m[bv_idx]

        dgdP_calc = -bg_bv*rhohat_bv*beta_bv*g_bv*(1-rhohat_bv)**-1  # Eqn. 66
        ifg_bv = ifg[bv_idx]
        dfdP_bv = dfdP[bv_idx]
        dgdP_calc = np.where(ifg_bv, dgdP_calc - dfdP_bv, dgdP_calc)
        dgdP_m[bv_idx] = dgdP_calc

    # Put results back into full arrays
    dgdT[mask] = dgdT_m
    d2gdT2[mask] = d2gdT2_m
    dgdP[mask] = dgdP_m

    return {&#34;g&#34;: g, &#34;dgdT&#34;: dgdT, &#34;d2gdT2&#34;: d2gdT2, &#34;dgdP&#34;: dgdP}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.hkf"><code class="name flex">
<span>def <span class="ident">hkf</span></span>(<span>property=None,<br>parameters=None,<br>T=298.15,<br>P=1,<br>contrib=['n', 's', 'o'],<br>H2O_props=['rho'],<br>water_model='SUPCRT92')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hkf(property=None, parameters=None, T=298.15, P=1,
    contrib = [&#34;n&#34;, &#34;s&#34;, &#34;o&#34;], H2O_props=[&#34;rho&#34;], water_model=&#34;SUPCRT92&#34;):
    # calculate G, H, S, Cp, V, kT, and/or E using
    # the revised HKF equations of state
    # H2O_props - H2O properties needed for subcrt() output
    # constants
    Tr = 298.15 # K
    Pr = 1      # bar
    Theta = 228 # K
    Psi = 2600  # bar

    # Convert T and P to arrays for vectorized operations
    T = np.atleast_1d(T)
    P = np.atleast_1d(P)

    # DEBUG
    if False:
        print(f&#34;\nDEBUG HKF input:&#34;)
        print(f&#34;  T (K): {T}&#34;)
        print(f&#34;  P (bar): {P}&#34;)

    # make T and P equal length
    if P.size &lt; T.size:
        P = np.full_like(T, P[0] if P.size == 1 else P)
    if T.size &lt; P.size:
        T = np.full_like(P, T[0] if T.size == 1 else T)

    n_conditions = T.size
    
    # GB conversion note: handle error messages later
#     # nonsolvation, solvation, and origination contribution
#     notcontrib &lt;- ! contrib %in% c(&#34;n&#34;, &#34;s&#34;, &#34;o&#34;)
#     if(TRUE %in% notcontrib) stop(paste(&#34;contrib must be in c(&#39;n&#39;, &#39;s&#39;, &#39;o); got&#34;, c2s(contrib[notcontrib])))
    
    # get water properties
    # rho - for subcrt() output and g function
    # Born functions and epsilon - for HKF calculations
    H2O_props += [&#34;QBorn&#34;, &#34;XBorn&#34;, &#34;YBorn&#34;, &#34;epsilon&#34;]

    if water_model == &#34;SUPCRT92&#34;:
      # using H2O92D.f from SUPCRT92: alpha, daldT, beta - for partial derivatives of omega (g function)
      H2O_props += [&#34;alpha&#34;, &#34;daldT&#34;, &#34;beta&#34;]
    
    elif water_model == &#34;IAPWS95&#34;:
      # using IAPWS-95: NBorn, UBorn - for compressibility, expansibility
      H2O_props += [&#34;alpha&#34;, &#34;daldT&#34;, &#34;beta&#34;, &#34;NBorn&#34;, &#34;UBorn&#34;]
    
    elif water_model == &#34;DEW&#34;:
      # using DEW model: get beta to calculate dgdP
      H2O_props += [&#34;alpha&#34;, &#34;daldT&#34;, &#34;beta&#34;]

    # DEBUG: Print T and P being passed to water
    if False:
        print(f&#34;DEBUG HKF calling water():&#34;)
        print(f&#34;  T type: {type(T)}, T: {T}&#34;)
        print(f&#34;  P type: {type(P)}, P: {P}&#34;)
        print(f&#34;  H2O_props: {H2O_props}&#34;)

    H2O_PrTr = water(H2O_props, T=Tr, P=Pr)
    H2O_PT = water(H2O_props, T=T, P=P)

    # DEBUG: Print what water returned
    if False:
        print(f&#34;DEBUG HKF water() returned:&#34;)
        print(f&#34;  H2O_PT type: {type(H2O_PT)}&#34;)
        if isinstance(H2O_PT, dict):
            print(f&#34;  H2O_PT keys: {H2O_PT.keys()}&#34;)
            print(f&#34;  epsilon: {H2O_PT.get(&#39;epsilon&#39;, &#39;NOT FOUND&#39;)}&#34;)

    # Handle dict output from water function
    def get_water_prop(water_dict, prop):
        &#34;&#34;&#34;Helper function to get water property from dict or DataFrame&#34;&#34;&#34;
        if isinstance(water_dict, dict):
            return water_dict[prop]
        else:
            return water_dict.loc[&#34;1&#34;, prop]

    # Get epsilon values and handle potential zeros
    epsilon_PT = get_water_prop(H2O_PT, &#34;epsilon&#34;)
    epsilon_PrTr = get_water_prop(H2O_PrTr, &#34;epsilon&#34;)

    # Check for zero or very small epsilon values and warn
    if np.any(epsilon_PT == 0) or np.any(np.abs(epsilon_PT) &lt; 1e-10):
        warnings.warn(f&#34;HKF: epsilon at P,T is zero or very small: {epsilon_PT}. H2O_PT keys: {H2O_PT.keys() if isinstance(H2O_PT, dict) else &#39;not dict&#39;}&#34;)

    with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
        ZBorn = -1 / epsilon_PT
        ZBorn_PrTr = -1 / epsilon_PrTr
    
    # a class to store the result
    out_dict = {} # dictionary to store output
    
    for k in parameters.index:
        
        if parameters[&#34;state&#34;][k] != &#34;aq&#34;:
            out_dict[k] = {p:float(&#39;NaN&#39;) for p in property}
        else:
            sp = parameters[&#34;name&#34;][k]

            # loop over each species
            PAR = copy.copy(parameters.loc[k, :])

            PAR[&#34;a1.a&#34;] = copy.copy(PAR[&#34;a1.a&#34;]*10**-1)
            PAR[&#34;a2.b&#34;] = copy.copy(PAR[&#34;a2.b&#34;]*10**2)
            PAR[&#34;a4.d&#34;] = copy.copy(PAR[&#34;a4.d&#34;]*10**4)
            PAR[&#34;c2.f&#34;] = copy.copy(PAR[&#34;c2.f&#34;]*10**4)
            PAR[&#34;omega.lambda&#34;] = copy.copy(PAR[&#34;omega.lambda&#34;]*10**5)

            # substitute Cp and V for missing EoS parameters
            # here we assume that the parameters are in the same position as in thermo()$OBIGT
            # we don&#39;t need this if we&#39;re just looking at solvation properties (Cp_s_var, V_s_var)

            # GB conversion note: this block checks various things about EOS parameters.
            # for now, just set hasEOS to True
            hasEOS = True # delete this once the following block is converted to python
    #         if &#34;n&#34; in contrib:
    #             # put the heat capacity in for c1 if both c1 and c2 are missing
    #             if all(is.na(PAR[, 18:19])):
    #                 PAR[, 18] = PAR[&#34;Cp&#34;]
    #             # put the volume in for a1 if a1, a2, a3 and a4 are missing
    #             if all(is.na(PAR[, 14:17])):
    #                 PAR[, 14] = convert(PAR[&#34;V&#34;], &#34;calories&#34;)
    #             # test for availability of the EoS parameters
    #             hasEOS = any(!is.na(PAR[, 14:21]))
    #             # if at least one of the EoS parameters is available, zero out any NA&#39;s in the rest
    #             if hasEOS:
    #                 PAR[, 14:21][, is.na(PAR[, 14:21])] = 0

            # compute values of omega(P,T) from those of omega(Pr,Tr)
            # using g function etc. (Shock et al., 1992 and others)
            omega = PAR[&#34;omega.lambda&#34;]  # omega_PrTr
            # its derivatives are zero unless the g function kicks in
            dwdP = np.zeros(n_conditions)
            dwdT = np.zeros(n_conditions)
            d2wdT2 = np.zeros(n_conditions)
            Z = PAR[&#34;z.T&#34;]

            omega_PT = np.full(n_conditions, PAR[&#34;omega.lambda&#34;])
            if Z != 0 and Z != &#34;NA&#34; and PAR[&#34;name&#34;] != &#34;H+&#34;:
                # compute derivatives of omega: g and f functions (Shock et al., 1992; Johnson et al., 1992)
                rhohat = get_water_prop(H2O_PT, &#34;rho&#34;)/1000  # just converting kg/m3 to g/cm3

                # temporarily filter out Python&#39;s warnings about dividing by zero, which is possible
                # with the equations in the gfunction
                # Possible complex output is acounted for in gfun().
                with warnings.catch_warnings():
                    warnings.simplefilter(&#39;ignore&#39;)
                    g = gfun(rhohat, T-273.15, P, get_water_prop(H2O_PT, &#34;alpha&#34;), get_water_prop(H2O_PT, &#34;daldT&#34;), get_water_prop(H2O_PT, &#34;beta&#34;))

                # after SUPCRT92/reac92.f
                eta = 1.66027E5
                reref = (Z**2) / (omega/eta + Z/(3.082 + 0))
                re = reref + abs(Z) * g[&#34;g&#34;]
                omega_PT = eta * (Z**2/re - Z/(3.082 + g[&#34;g&#34;]))
                Z3 = abs(Z**3)/re**2 - Z/(3.082 + g[&#34;g&#34;])**2
                Z4 = abs(Z**4)/re**3 - Z/(3.082 + g[&#34;g&#34;])**3
                dwdP = (-eta * Z3 * g[&#34;dgdP&#34;])
                dwdT = (-eta * Z3 * g[&#34;dgdT&#34;])
                d2wdT2 = (2 * eta * Z4 * g[&#34;dgdT&#34;]**2 - eta * Z3 * g[&#34;d2gdT2&#34;])

            # loop over each property
            w = float(&#39;NaN&#39;)
            for i,PROP in enumerate(property) :

                # over nonsolvation, solvation, or origination contributions - vectorized
                hkf_p = np.zeros(n_conditions)

                for icontrib in contrib :
                    # various contributions to the properties
                    if icontrib == &#34;n&#34;:
                        # nonsolvation ghs equations
                        if PROP == &#34;H&#34;:
                            p_c = PAR[&#34;c1.e&#34;]*(T-Tr) - PAR[&#34;c2.f&#34;]*(1/(T-Theta)-1/(Tr-Theta))
                            p_a = PAR[&#34;a1.a&#34;]*(P-Pr) + PAR[&#34;a2.b&#34;]*np.log((Psi+P)/(Psi+Pr)) + \
                              ((2*T-Theta)/(T-Theta)**2)*(PAR[&#34;a3.c&#34;]*(P-Pr)+PAR[&#34;a4.d&#34;]*np.log((Psi+P)/(Psi+Pr)))
                            p = p_c + p_a
                        elif PROP == &#34;S&#34;:
                            p_c = PAR[&#34;c1.e&#34;]*np.log(T/Tr) - \
                              (PAR[&#34;c2.f&#34;]/Theta)*( 1/(T-Theta)-1/(Tr-Theta) + \
                              np.log( (Tr*(T-Theta))/(T*(Tr-Theta)) )/Theta )
                            p_a = (T-Theta)**(-2)*(PAR[&#34;a3.c&#34;]*(P-Pr)+PAR[&#34;a4.d&#34;]*np.log((Psi+P)/(Psi+Pr)))
                            p = p_c + p_a
                        elif PROP == &#34;G&#34;:
                            p_c = -PAR[&#34;c1.e&#34;]*(T*np.log(T/Tr)-T+Tr) - \
                              PAR[&#34;c2.f&#34;]*( (1/(T-Theta)-1/(Tr-Theta))*((Theta-T)/Theta) - \
                              (T/Theta**2)*np.log((Tr*(T-Theta))/(T*(Tr-Theta))) )
                            p_a = PAR[&#34;a1.a&#34;]*(P-Pr) + PAR[&#34;a2.b&#34;]*np.log((Psi+P)/(Psi+Pr)) + \
                              (PAR[&#34;a3.c&#34;]*(P-Pr) + PAR[&#34;a4.d&#34;]*np.log((Psi+P)/(Psi+Pr)))/(T-Theta)
                            p = p_c + p_a
                            # at Tr,Pr, if the origination contribution is not NA, ensure the solvation contribution is 0, not NA
                            if not np.isnan(PAR[&#34;G&#34;]):
                                p = np.where((T==Tr) &amp; (P==Pr), 0, p)
                        # nonsolvation cp v kt e equations
                        elif PROP == &#34;Cp&#34;:
                            p = PAR[&#34;c1.e&#34;] + PAR[&#34;c2.f&#34;] * ( T - Theta ) ** (-2)
                        elif PROP == &#34;V&#34;:
                            p = convert_cm3bar(PAR[&#34;a1.a&#34;]) + \
                              convert_cm3bar(PAR[&#34;a2.b&#34;]) / (Psi + P) + \
                              (convert_cm3bar(PAR[&#34;a3.c&#34;]) + convert_cm3bar(PAR[&#34;a4.d&#34;]) / (Psi + P)) / (T - Theta)
#                         elif PROP == &#34;kT&#34;:
#                             p = (convert(PAR[&#34;a2.b&#34;], &#34;cm3bar&#34;) + \
#                               convert(PAR[&#34;a4.d&#34;], &#34;cm3bar&#34;) / (T - Theta)) * (Psi + P) ** (-2)
#                         elif PROP == &#34;E&#34;:
#                             p = convert( - (PAR[&#34;a3.c&#34;] + PAR[&#34;a4.d&#34;] / convert((Psi + P), &#34;calories&#34;)) * \
#                               (T - Theta) ** (-2), &#34;cm3bar&#34;)
                        else:
                            print(&#34;BAD&#34;)

                    if icontrib == &#34;s&#34;:
                        # solvation ghs equations
                        if PROP == &#34;G&#34;:
                            p = -omega_PT*(ZBorn+1) + omega*(ZBorn_PrTr+1) + omega*get_water_prop(H2O_PrTr, &#34;YBorn&#34;)*(T-Tr)
                            # at Tr,Pr, if the origination contribution is not NA, ensure the solvation contribution is 0, not NA
                            if(np.isnan(PAR[&#34;G&#34;])):
                                p = np.where((T==Tr) &amp; (P==Pr), 0, p)
                        if PROP == &#34;H&#34;:
                            p = -omega_PT*(ZBorn+1) + omega_PT*T*get_water_prop(H2O_PT, &#34;YBorn&#34;) + T*(ZBorn+1)*dwdT + \
                                   omega*(ZBorn_PrTr+1) - omega*Tr*get_water_prop(H2O_PrTr, &#34;YBorn&#34;)
                        if PROP == &#34;S&#34;:
                            p = omega_PT*get_water_prop(H2O_PT, &#34;YBorn&#34;) + (ZBorn+1)*dwdT - omega*get_water_prop(H2O_PrTr, &#34;YBorn&#34;)
                        # solvation cp v kt e equations
                        if PROP == &#34;Cp&#34;:
                            p = omega_PT*T*get_water_prop(H2O_PT, &#34;XBorn&#34;) + 2*T*get_water_prop(H2O_PT, &#34;YBorn&#34;)*dwdT + T*(ZBorn+1)*d2wdT2
                        if PROP == &#34;V&#34;:
                            term1 = -convert_cm3bar(omega_PT) * get_water_prop(H2O_PT, &#34;QBorn&#34;)
                            term2 = convert_cm3bar(dwdP) * (-ZBorn - 1)
                            p = term1 + term2

                            # DEBUG
                            if False:
                                print(f&#34;\nDEBUG solvation V terms:&#34;)
                                print(f&#34;  omega_PT: {omega_PT}&#34;)
                                print(f&#34;  QBorn: {get_water_prop(H2O_PT, &#39;QBorn&#39;)}&#34;)
                                print(f&#34;  dwdP: {dwdP}&#34;)
                                print(f&#34;  ZBorn: {ZBorn}&#34;)
                                print(f&#34;  term1 (-ω*QBorn): {term1}&#34;)
                                print(f&#34;  term2 (dwdP*(-Z-1)): {term2}&#34;)
                                print(f&#34;  total p: {p}&#34;)
                        # TODO: the partial derivatives of omega are not included here here for kt and e
                        # (to do it, see p. 820 of SOJ+92 ... but kt requires d2wdP2 which we don&#34;t have yet)
                        if PROP == &#34;kT&#34;:
                            p = convert_cm3bar(omega) * get_water_prop(H2O_PT, &#34;NBorn&#34;)
                        if PROP == &#34;E&#34;:
                            p = -convert_cm3bar(omega) * get_water_prop(H2O_PT, &#34;UBorn&#34;)

                    if icontrib == &#34;o&#34;:
                        # origination ghs equations
                        if PROP == &#34;G&#34;:
                            p = PAR[&#34;G&#34;] - PAR[&#34;S&#34;] * (T-Tr)
                            # don&#34;t inherit NA from PAR$S at Tr
                            p = np.where(T == Tr, PAR[&#34;G&#34;], p)
                        elif PROP == &#34;H&#34;:
                            p = np.full(n_conditions, PAR[&#34;H&#34;])
                        elif PROP == &#34;S&#34;:
                            p = np.full(n_conditions, PAR[&#34;S&#34;])
                        # origination eos equations (Cp, V, kT, E): senseless
                        else:
                            p = np.zeros(n_conditions)

                    # accumulate the contribution
                    hkf_p = hkf_p + p

                    # DEBUG
                    if False and PROP == &#34;V&#34;:
                        print(f&#34;\nDEBUG HKF V calculation (species {k}, contrib={icontrib}):&#34;)
                        print(f&#34;  T: {T}&#34;)
                        print(f&#34;  P: {P}&#34;)
                        print(f&#34;  contribution p: {p}&#34;)
                        print(f&#34;  accumulated hkf_p: {hkf_p}&#34;)

                # species have to be numbered (k) instead of named because of name repeats in db (e.g., cr polymorphs)
                if i &gt; 0:
                    out_dict[k][PROP] = hkf_p
                else:
                    out_dict[k] = {PROP:hkf_p}

                # DEBUG
                if False and PROP == &#34;V&#34;:
                    print(f&#34;\nDEBUG HKF final V for species {k}: {hkf_p}&#34;)

    return(out_dict, H2O_PT)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.quartz_coesite"><code class="name flex">
<span>def <span class="ident">quartz_coesite</span></span>(<span>PAR, T, P)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quartz_coesite(PAR, T, P):
    # the corrections are 0 for anything other than quartz and coesite
    if not PAR[&#34;name&#34;] in [&#34;quartz&#34;, &#34;coesite&#34;]:
        n = T.size if isinstance(T, np.ndarray) else 1
        return(dict(G=np.zeros(n), H=np.zeros(n), S=np.zeros(n), V=np.zeros(n)))

    # Vectorized version
    T = np.atleast_1d(T)
    P = np.atleast_1d(P)

    # Tr, Pr and TtPr (transition temperature at Pr)
    Pr = 1      # bar
    Tr = 298.15 # K
    TtPr = 848  # K
    # constants from SUP92D.f
    aa = 549.824
    ba = 0.65995
    ca = -0.4973e-4
    VPtTta = 23.348
    VPrTtb = 23.72
    Stran = 0.342
    # constants from REAC92D.f
    VPrTra = 22.688 # VPrTr(a-quartz)
    Vdiff = 2.047   # VPrTr(a-quartz) - VPrTr(coesite)
    k = 38.5       # dPdTtr(a/b-quartz)
    #k &lt;- 38.45834    # calculated in CHNOSZ: dPdTtr(info(&#34;quartz&#34;))
    # code adapted from REAC92D.f
    qphase = PAR[&#34;state&#34;].replace(&#34;cr&#34;, &#34;&#34;)

    if qphase == &#34;2&#34;:
        Pstar = P.copy()
        Sstar = np.zeros_like(T)
        V = np.full_like(T, VPrTtb)
    else:
        Pstar = Pr + k * (T - TtPr)
        Sstar = np.full_like(T, Stran)
        V = VPrTra + ca*(P-Pr) + (VPtTta - VPrTra - ca*(P-Pr))*(T-Tr) / (TtPr + (P-Pr)/k - Tr)

    # Apply condition: if T &lt; TtPr
    below_transition = T &lt; TtPr
    Pstar = np.where(below_transition, Pr, Pstar)
    Sstar = np.where(below_transition, 0, Sstar)

    if PAR[&#34;name&#34;] == &#34;coesite&#34;:
        VPrTra = VPrTra - Vdiff
        VPrTtb = VPrTtb - Vdiff
        V = V - Vdiff

    cm3bar_to_cal = 0.023901488

    # Vectorized log calculation
    with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
        log_term = np.log((aa + P/k) / (aa + Pstar/k))
        log_term = np.where(np.isfinite(log_term), log_term, 0)

    GVterm = cm3bar_to_cal * (VPrTra * (P - Pstar) + VPrTtb * (Pstar - Pr) - \
        0.5 * ca * (2 * Pr * (P - Pstar) - (P**2 - Pstar**2)) - \
        ca * k * (T - Tr) * (P - Pstar) + \
        k * (ba + aa * ca * k) * (T - Tr) * log_term)
    SVterm = cm3bar_to_cal * (-k * (ba + aa * ca * k) * log_term + ca * k * (P - Pstar)) - Sstar

    # note the minus sign on &#34;SVterm&#34; in order that intdVdTdP has the correct sign
    return dict(intVdP=GVterm, intdVdTdP=-SVterm, V=V)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.models.water"><code class="name flex">
<span>def <span class="ident">water</span></span>(<span>property: str | List[str] | None = None,<br>T: float | numpy.ndarray | List[float] = 298.15,<br>P: float | List[float] | numpy.ndarray | str = 1.0,<br>Psat_floor: float | None = 1.0,<br>model: str | None = None,<br>messages: bool = True) ‑> str | float | numpy.ndarray | Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def water(property: Optional[Union[str, List[str]]] = None,
          T: Union[float, np.ndarray, List[float]] = 298.15,
          P: Union[float, np.ndarray, List[float], str] = 1.0,
          Psat_floor: Union[float, None] = 1.0,
          model: Optional[str] = None,
          messages: bool = True) -&gt; Union[str, float, np.ndarray, Dict[str, Any]]:
    &#34;&#34;&#34;
    Calculate thermodynamic and electrostatic properties of liquid H2O.
    
    This is the main water function that provides the same interface as the
    R CHNOSZ water() function, with support for multiple water models.
    
    Parameters
    ----------
    property : str, list of str, or None
        Properties to calculate. If None, returns current water model.
        If water model name (SUPCRT92, IAPWS95, DEW), sets the water model.
        Available properties depend on the water model used.
    T : float or array-like
        Temperature in Kelvin
    P : float, array-like, or &#34;Psat&#34;
        Pressure in bar, or &#34;Psat&#34; for saturation pressure
    Psat_floor : float or None
        Minimum pressure floor for Psat calculations (SUPCRT92 only)
    model : str, optional
        Override the default water model for this calculation
    messages : bool, default True
        Whether to print informational messages

    Returns
    -------
    str, float, array, or dict
        Current water model name, single property value, array of values,
        or dictionary with calculated properties
        
    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Get current water model
    &gt;&gt;&gt; model = pychnosz.water()
    &gt;&gt;&gt; print(model)  # &#39;SUPCRT92&#39;
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Set water model
    &gt;&gt;&gt; old_model = pychnosz.water(&#39;IAPWS95&#39;)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Calculate single property
    &gt;&gt;&gt; density = pychnosz.water(&#39;rho&#39;, T=298.15, P=1.0)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Calculate multiple properties
    &gt;&gt;&gt; props = pychnosz.water([&#39;rho&#39;, &#39;epsilon&#39;], T=298.15, P=1.0)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Temperature array
    &gt;&gt;&gt; temps = np.array([273.15, 298.15, 373.15])
    &gt;&gt;&gt; densities = pychnosz.water(&#39;rho&#39;, T=temps, P=1.0)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Saturation pressure
    &gt;&gt;&gt; psat = pychnosz.water(&#39;Psat&#39;, T=373.15)
    &#34;&#34;&#34;
    
    # Get thermo system
    thermo_system = thermo()

    # Ensure thermo is initialized before accessing/setting options
    # This prevents reset() from clearing options later
    if not thermo_system.is_initialized():
        thermo_system.reset(messages=False)

    # Case 1: Query current water model
    if property is None:
        return thermo_system.get_option(&#39;water&#39;, &#39;SUPCRT92&#39;)

    # Case 2: Set water model
    if isinstance(property, str) and property.upper() in [&#39;SUPCRT92&#39;, &#39;SUPCRT&#39;, &#39;IAPWS95&#39;, &#39;IAPWS&#39;, &#39;DEW&#39;]:
        old_model = thermo_system.get_option(&#39;water&#39;, &#39;SUPCRT92&#39;)

        # Normalize model name
        if property.upper() in [&#39;SUPCRT92&#39;, &#39;SUPCRT&#39;]:
            new_model = &#39;SUPCRT92&#39;
        elif property.upper() in [&#39;IAPWS95&#39;, &#39;IAPWS&#39;]:
            new_model = &#39;IAPWS95&#39;
        elif property.upper() == &#39;DEW&#39;:
            new_model = &#39;DEW&#39;

        thermo_system.set_option(&#39;water&#39;, new_model)
        if messages:
            print(f&#34;water: setting water model to {new_model}&#34;)
        return  # Return None instead of the old model
    
    # Case 3: Calculate properties
    # Determine which model to use
    if model is not None:
        water_model = model.upper()
    else:
        water_model = thermo_system.get_option(&#39;water&#39;, &#39;SUPCRT92&#39;).upper()
    
    # Normalize model names
    if water_model in [&#39;SUPCRT92&#39;, &#39;SUPCRT&#39;]:
        water_model = &#39;SUPCRT92&#39;
    elif water_model in [&#39;IAPWS95&#39;, &#39;IAPWS&#39;]:
        water_model = &#39;IAPWS95&#39;
    elif water_model == &#39;DEW&#39;:
        water_model = &#39;DEW&#39;
    else:
        warnings.warn(f&#34;Unknown water model &#39;{water_model}&#39;, using SUPCRT92&#34;)
        water_model = &#39;SUPCRT92&#39;
    
    # Convert inputs
    T = np.atleast_1d(np.asarray(T, dtype=float))
    
    if isinstance(P, str):
        P_input = P
    else:
        P_input = np.atleast_1d(np.asarray(P, dtype=float))
        # Make T and P same length
        if len(P_input) &lt; len(T):
            P_input = np.resize(P_input, len(T))
        elif len(T) &lt; len(P_input):
            T = np.resize(T, len(P_input))
    
    # Call appropriate water model
    try:
        if water_model == &#39;SUPCRT92&#39;:
            result = _call_supcrt92(property, T, P_input, Psat_floor)
        elif water_model == &#39;IAPWS95&#39;:
            result = _call_iapws95(property, T, P_input, Psat_floor)  
        elif water_model == &#39;DEW&#39;:
            result = _call_dew(property, T, P_input)
        else:
            raise ValueError(f&#34;Unsupported water model: {water_model}&#34;)
            
    except Exception as e:
        raise WaterModelError(f&#34;Error calculating water properties with {water_model} model: {e}&#34;)
    
    # Apply Psat rounding to match R CHNOSZ behavior
    # Round Psat values to 4 decimal places (round up to ensure liquid phase)
    result = _apply_psat_rounding(result, property)
    
    return result</code></pre>
</details>
<div class="desc"><p>Calculate thermodynamic and electrostatic properties of liquid H2O.</p>
<p>This is the main water function that provides the same interface as the
R CHNOSZ water() function, with support for multiple water models.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>None</code></dt>
<dd>Properties to calculate. If None, returns current water model.
If water model name (SUPCRT92, IAPWS95, DEW), sets the water model.
Available properties depend on the water model used.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>array-like</code></dt>
<dd>Temperature in Kelvin</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float, array-like,</code> or <code>"Psat"</code></dt>
<dd>Pressure in bar, or "Psat" for saturation pressure</dd>
<dt><strong><code>Psat_floor</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>Minimum pressure floor for Psat calculations (SUPCRT92 only)</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Override the default water model for this calculation</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str, float, array,</code> or <code>dict</code></dt>
<dd>Current water model name, single property value, array of values,
or dictionary with calculated properties</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Get current water model
&gt;&gt;&gt; model = pychnosz.water()
&gt;&gt;&gt; print(model)  # 'SUPCRT92'
&gt;&gt;&gt; 
&gt;&gt;&gt; # Set water model
&gt;&gt;&gt; old_model = pychnosz.water('IAPWS95')
&gt;&gt;&gt; 
&gt;&gt;&gt; # Calculate single property
&gt;&gt;&gt; density = pychnosz.water('rho', T=298.15, P=1.0)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Calculate multiple properties
&gt;&gt;&gt; props = pychnosz.water(['rho', 'epsilon'], T=298.15, P=1.0)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Temperature array
&gt;&gt;&gt; temps = np.array([273.15, 298.15, 373.15])
&gt;&gt;&gt; densities = pychnosz.water('rho', T=temps, P=1.0)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Saturation pressure
&gt;&gt;&gt; psat = pychnosz.water('Psat', T=373.15)
</code></pre></div>
</dd>
<dt id="pychnosz.models.water_SUPCRT92"><code class="name flex">
<span>def <span class="ident">water_SUPCRT92</span></span>(<span>property: str | List[str],<br>T: float | numpy.ndarray = 298.15,<br>P: float | str | numpy.ndarray = 1.0,<br>**kwargs) ‑> float | numpy.ndarray | Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def water_SUPCRT92(property: Union[str, List[str]], 
                   T: Union[float, np.ndarray] = 298.15,
                   P: Union[float, np.ndarray, str] = 1.0,
                   **kwargs) -&gt; Union[float, np.ndarray, Dict[str, Any]]:
    &#34;&#34;&#34;
    Calculate water properties using SUPCRT92 model.
    
    This function provides the same interface as the original Python
    implementation but with Fortran backend support for high accuracy.
    
    Parameters
    ----------
    property : str or list of str
        Property or list of properties to calculate
    T : float or array
        Temperature in Kelvin
    P : float, array, or &#39;Psat&#39;
        Pressure in bar, or &#39;Psat&#39; for saturation pressure
    **kwargs
        Additional options (e.g., Psat_floor)
    
    Returns
    -------
    float, array, or dict
        Calculated properties
        
    Examples
    --------
    &gt;&gt;&gt; # Basic usage
    &gt;&gt;&gt; rho = water_SUPCRT92(&#39;rho&#39;, 298.15, 1.0)
    &gt;&gt;&gt; print(f&#34;Density: {rho:.3f} g/cm³&#34;)
    
    &gt;&gt;&gt; # Multiple properties  
    &gt;&gt;&gt; props = water_SUPCRT92([&#39;rho&#39;, &#39;epsilon&#39;], 298.15, 1.0)
    &gt;&gt;&gt; print(f&#34;ρ = {props[&#39;rho&#39;]:.3f}, ε = {props[&#39;epsilon&#39;]:.1f}&#34;)
    
    &gt;&gt;&gt; # Saturation pressure
    &gt;&gt;&gt; Psat = water_SUPCRT92(&#39;Psat&#39;, 373.15, &#39;Psat&#39;)
    &gt;&gt;&gt; print(f&#34;Psat at 100°C: {Psat:.2f} bar&#34;)
    &#34;&#34;&#34;
    return supcrt92_water.calculate(property, T, P, **kwargs)</code></pre>
</details>
<div class="desc"><p>Calculate water properties using SUPCRT92 model.</p>
<p>This function provides the same interface as the original Python
implementation but with Fortran backend support for high accuracy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Property or list of properties to calculate</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>Temperature in Kelvin</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float, array,</code> or <code>'Psat'</code></dt>
<dd>Pressure in bar, or 'Psat' for saturation pressure</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional options (e.g., Psat_floor)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float, array,</code> or <code>dict</code></dt>
<dd>Calculated properties</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Basic usage
&gt;&gt;&gt; rho = water_SUPCRT92('rho', 298.15, 1.0)
&gt;&gt;&gt; print(f&quot;Density: {rho:.3f} g/cm³&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Multiple properties  
&gt;&gt;&gt; props = water_SUPCRT92(['rho', 'epsilon'], 298.15, 1.0)
&gt;&gt;&gt; print(f&quot;ρ = {props['rho']:.3f}, ε = {props['epsilon']:.1f}&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Saturation pressure
&gt;&gt;&gt; Psat = water_SUPCRT92('Psat', 373.15, 'Psat')
&gt;&gt;&gt; print(f&quot;Psat at 100°C: {Psat:.2f} bar&quot;)
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pychnosz.models.SUPCRT92Water"><code class="flex name class">
<span>class <span class="ident">SUPCRT92Water</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SUPCRT92Water:
    &#34;&#34;&#34;
    SUPCRT92 water model with Fortran backend.
    
    This class provides an interface to the original SUPCRT92 Fortran
    subroutines for calculating water properties. If the Fortran library
    is not available, it falls back to Python approximations.
    
    The Fortran implementation gives exact compatibility with R CHNOSZ
    and includes all 23+ thermodynamic properties.
    &#34;&#34;&#34;
    
    def __init__(self):
        &#34;&#34;&#34;
        Initialize SUPCRT92 water model.
        
        SUPCRT92 requires the compiled FORTRAN interface for accuracy and 
        compatibility with R CHNOSZ. No pure Python fallback is provided.
        &#34;&#34;&#34;
        if not HAS_FORTRAN:
            raise ImportError(
                f&#34;SUPCRT92 water model requires compiled FORTRAN interface. &#34;
                f&#34;Error: {_fortran_error}. &#34;
                f&#34;Please compile the FORTRAN subroutines using: &#34;
                f&#34;python compile_fortran.py. &#34;
                f&#34;See setup_fortran_instructions.md for details.&#34;
            )
        
        # Initialize Fortran interface (required)
        try:
            self._fortran_interface = get_h2o92_interface()
        except Exception as e:
            raise RuntimeError(f&#34;Failed to initialize FORTRAN interface: {e}&#34;) from e
    
    def calculate(self, 
                  properties: Union[str, List[str]], 
                  T: Union[float, np.ndarray] = 298.15,
                  P: Union[float, np.ndarray, str] = 1.0,
                  **kwargs) -&gt; Union[float, np.ndarray, Dict[str, Any]]:
        &#34;&#34;&#34;
        Calculate water properties using SUPCRT92 model.
        
        Parameters
        ----------
        properties : str or list of str
            Property or list of properties to calculate
        T : float or array
            Temperature in Kelvin
        P : float, array, or &#39;Psat&#39;
            Pressure in bar, or &#39;Psat&#39; for saturation pressure
        **kwargs
            Additional options (e.g., Psat_floor)
        
        Returns
        -------
        float, array, or dict
            Calculated properties
        &#34;&#34;&#34;
        
        # Handle input types
        if isinstance(properties, str):
            properties = [properties]
            single_prop = True
        else:
            single_prop = False
            
        # Convert inputs to arrays
        T = np.atleast_1d(np.asarray(T, dtype=float))
        
        # Always use FORTRAN backend (no fallback)
        return self._calculate_fortran(properties, T, P, single_prop, **kwargs)
    
    def _calculate_fortran(self, properties: List[str], T: np.ndarray,
                          P: Union[np.ndarray, str], single_prop: bool,
                          **kwargs) -&gt; Union[float, np.ndarray, Dict[str, Any]]:
        &#34;&#34;&#34;Calculate properties using Fortran backend.&#34;&#34;&#34;

        # Handle pressure input
        if isinstance(P, str) and P == &#39;Psat&#39;:
            P_vals = &#39;Psat&#39;
        else:
            P = np.atleast_1d(np.asarray(P, dtype=float))
            if len(P) &lt; len(T):
                P = np.resize(P, len(T))
            elif len(T) &lt; len(P):
                T = np.resize(T, len(P))
            P_vals = P

        # Use batched calculation for better performance
        try:
            results = self._fortran_interface.calculate_properties_batch(
                T, P_vals, properties
            )
        except Exception as e:
            warnings.warn(f&#34;Batch Fortran calculation failed: {e}&#34;)
            # Fallback to individual calculations if batch fails
            results = {}
            for prop in properties:
                results[prop] = np.full_like(T, np.nan)

            for i in range(len(T)):
                T_i = T[i]

                # Skip invalid points
                if np.isnan(T_i):
                    continue

                if isinstance(P_vals, str):
                    P_i = P_vals
                else:
                    P_i = P_vals[i]
                    if np.isnan(P_i):
                        continue

                try:
                    # Call Fortran interface
                    props_i = self._fortran_interface.calculate_properties(
                        T_i, P_i, properties
                    )

                    # Store results
                    for prop in properties:
                        if prop in props_i:
                            results[prop][i] = props_i[prop]

                except Exception as e:
                    warnings.warn(f&#34;Fortran calculation failed at T={T_i:.1f}K, P={P_i}: {e}&#34;)
                    continue

        # Handle Psat_floor for saturation pressure
        if &#39;Psat&#39; in results and &#39;Psat_floor&#39; in kwargs:
            Psat_floor = kwargs[&#39;Psat_floor&#39;]
            if Psat_floor is not None:
                results[&#39;Psat&#39;] = np.maximum(results[&#39;Psat&#39;], Psat_floor)
        
        # Return results
        if single_prop:
            result = results[properties[0]]
            return result[0] if len(result) == 1 else result
        else:
            # Convert single-element arrays to scalars if appropriate
            if len(T) == 1:
                for key in results:
                    if len(results[key]) == 1:
                        results[key] = results[key][0]
            return results
    
    def available_properties(self) -&gt; List[str]:
        &#34;&#34;&#34;
        Get list of available properties.
        
        Returns
        -------
        List[str]
            List of available property names
        &#34;&#34;&#34;
        if self._use_fortran:
            return self._fortran_interface.available_properties()
        else:
            return self._python_backend.available_properties()
    
    @property
    def backend(self) -&gt; str:
        &#34;&#34;&#34;Get the active backend (&#39;fortran&#39; or &#39;python&#39;).&#34;&#34;&#34;
        return &#39;fortran&#39; if self._use_fortran else &#39;python&#39;
    
    @property
    def has_fortran(self) -&gt; bool:
        &#34;&#34;&#34;Check if Fortran backend is available.&#34;&#34;&#34;
        return HAS_FORTRAN</code></pre>
</details>
<div class="desc"><p>SUPCRT92 water model with Fortran backend.</p>
<p>This class provides an interface to the original SUPCRT92 Fortran
subroutines for calculating water properties. If the Fortran library
is not available, it falls back to Python approximations.</p>
<p>The Fortran implementation gives exact compatibility with R CHNOSZ
and includes all 23+ thermodynamic properties.</p>
<p>Initialize SUPCRT92 water model.</p>
<p>SUPCRT92 requires the compiled FORTRAN interface for accuracy and
compatibility with R CHNOSZ. No pure Python fallback is provided.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="pychnosz.models.SUPCRT92Water.backend"><code class="name">prop <span class="ident">backend</span> : str</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def backend(self) -&gt; str:
    &#34;&#34;&#34;Get the active backend (&#39;fortran&#39; or &#39;python&#39;).&#34;&#34;&#34;
    return &#39;fortran&#39; if self._use_fortran else &#39;python&#39;</code></pre>
</details>
<div class="desc"><p>Get the active backend ('fortran' or 'python').</p></div>
</dd>
<dt id="pychnosz.models.SUPCRT92Water.has_fortran"><code class="name">prop <span class="ident">has_fortran</span> : bool</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_fortran(self) -&gt; bool:
    &#34;&#34;&#34;Check if Fortran backend is available.&#34;&#34;&#34;
    return HAS_FORTRAN</code></pre>
</details>
<div class="desc"><p>Check if Fortran backend is available.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pychnosz.models.SUPCRT92Water.available_properties"><code class="name flex">
<span>def <span class="ident">available_properties</span></span>(<span>self) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def available_properties(self) -&gt; List[str]:
    &#34;&#34;&#34;
    Get list of available properties.
    
    Returns
    -------
    List[str]
        List of available property names
    &#34;&#34;&#34;
    if self._use_fortran:
        return self._fortran_interface.available_properties()
    else:
        return self._python_backend.available_properties()</code></pre>
</details>
<div class="desc"><p>Get list of available properties.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>List of available property names</dd>
</dl></div>
</dd>
<dt id="pychnosz.models.SUPCRT92Water.calculate"><code class="name flex">
<span>def <span class="ident">calculate</span></span>(<span>self,<br>properties: str | List[str],<br>T: float | numpy.ndarray = 298.15,<br>P: float | str | numpy.ndarray = 1.0,<br>**kwargs) ‑> float | numpy.ndarray | Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate(self, 
              properties: Union[str, List[str]], 
              T: Union[float, np.ndarray] = 298.15,
              P: Union[float, np.ndarray, str] = 1.0,
              **kwargs) -&gt; Union[float, np.ndarray, Dict[str, Any]]:
    &#34;&#34;&#34;
    Calculate water properties using SUPCRT92 model.
    
    Parameters
    ----------
    properties : str or list of str
        Property or list of properties to calculate
    T : float or array
        Temperature in Kelvin
    P : float, array, or &#39;Psat&#39;
        Pressure in bar, or &#39;Psat&#39; for saturation pressure
    **kwargs
        Additional options (e.g., Psat_floor)
    
    Returns
    -------
    float, array, or dict
        Calculated properties
    &#34;&#34;&#34;
    
    # Handle input types
    if isinstance(properties, str):
        properties = [properties]
        single_prop = True
    else:
        single_prop = False
        
    # Convert inputs to arrays
    T = np.atleast_1d(np.asarray(T, dtype=float))
    
    # Always use FORTRAN backend (no fallback)
    return self._calculate_fortran(properties, T, P, single_prop, **kwargs)</code></pre>
</details>
<div class="desc"><p>Calculate water properties using SUPCRT92 model.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>properties</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Property or list of properties to calculate</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>array</code></dt>
<dd>Temperature in Kelvin</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float, array,</code> or <code>'Psat'</code></dt>
<dd>Pressure in bar, or 'Psat' for saturation pressure</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional options (e.g., Psat_floor)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float, array,</code> or <code>dict</code></dt>
<dd>Calculated properties</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="pychnosz.models.WaterModelError"><code class="flex name class">
<span>class <span class="ident">WaterModelError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WaterModelError(Exception):
    &#34;&#34;&#34;Exception raised for water model calculation errors.&#34;&#34;&#34;
    pass</code></pre>
</details>
<div class="desc"><p>Exception raised for water model calculation errors.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pychnosz" href="../index.html">pychnosz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pychnosz.models.archer_wang" href="archer_wang.html">pychnosz.models.archer_wang</a></code></li>
<li><code><a title="pychnosz.models.berman" href="berman.html">pychnosz.models.berman</a></code></li>
<li><code><a title="pychnosz.models.dew" href="dew.html">pychnosz.models.dew</a></code></li>
<li><code><a title="pychnosz.models.hkf_helpers" href="hkf_helpers.html">pychnosz.models.hkf_helpers</a></code></li>
<li><code><a title="pychnosz.models.iapws95" href="iapws95.html">pychnosz.models.iapws95</a></code></li>
<li><code><a title="pychnosz.models.supcrt92_fortran" href="supcrt92_fortran.html">pychnosz.models.supcrt92_fortran</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pychnosz.models.Berman" href="#pychnosz.models.Berman">Berman</a></code></li>
<li><code><a title="pychnosz.models.G2logK" href="#pychnosz.models.G2logK">G2logK</a></code></li>
<li><code><a title="pychnosz.models.OBIGT2eos" href="#pychnosz.models.OBIGT2eos">OBIGT2eos</a></code></li>
<li><code><a title="pychnosz.models.available_properties" href="#pychnosz.models.available_properties">available_properties</a></code></li>
<li><code><a title="pychnosz.models.calc_G_TP" href="#pychnosz.models.calc_G_TP">calc_G_TP</a></code></li>
<li><code><a title="pychnosz.models.calc_logK" href="#pychnosz.models.calc_logK">calc_logK</a></code></li>
<li><code><a title="pychnosz.models.cgl" href="#pychnosz.models.cgl">cgl</a></code></li>
<li><code><a title="pychnosz.models.compare_models" href="#pychnosz.models.compare_models">compare_models</a></code></li>
<li><code><a title="pychnosz.models.convert_cm3bar" href="#pychnosz.models.convert_cm3bar">convert_cm3bar</a></code></li>
<li><code><a title="pychnosz.models.dissrxn2logK" href="#pychnosz.models.dissrxn2logK">dissrxn2logK</a></code></li>
<li><code><a title="pychnosz.models.get_water_models" href="#pychnosz.models.get_water_models">get_water_models</a></code></li>
<li><code><a title="pychnosz.models.gfun" href="#pychnosz.models.gfun">gfun</a></code></li>
<li><code><a title="pychnosz.models.hkf" href="#pychnosz.models.hkf">hkf</a></code></li>
<li><code><a title="pychnosz.models.quartz_coesite" href="#pychnosz.models.quartz_coesite">quartz_coesite</a></code></li>
<li><code><a title="pychnosz.models.water" href="#pychnosz.models.water">water</a></code></li>
<li><code><a title="pychnosz.models.water_SUPCRT92" href="#pychnosz.models.water_SUPCRT92">water_SUPCRT92</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pychnosz.models.SUPCRT92Water" href="#pychnosz.models.SUPCRT92Water">SUPCRT92Water</a></code></h4>
<ul class="">
<li><code><a title="pychnosz.models.SUPCRT92Water.available_properties" href="#pychnosz.models.SUPCRT92Water.available_properties">available_properties</a></code></li>
<li><code><a title="pychnosz.models.SUPCRT92Water.backend" href="#pychnosz.models.SUPCRT92Water.backend">backend</a></code></li>
<li><code><a title="pychnosz.models.SUPCRT92Water.calculate" href="#pychnosz.models.SUPCRT92Water.calculate">calculate</a></code></li>
<li><code><a title="pychnosz.models.SUPCRT92Water.has_fortran" href="#pychnosz.models.SUPCRT92Water.has_fortran">has_fortran</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pychnosz.models.WaterModelError" href="#pychnosz.models.WaterModelError">WaterModelError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
