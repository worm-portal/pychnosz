<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>pychnosz API documentation</title>
<meta name="description" content="pyCHNOSZ: Thermodynamic Calculations and Diagrams for Geochemistry …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pychnosz</code></h1>
</header>
<section id="section-intro">
<p>pyCHNOSZ: Thermodynamic Calculations and Diagrams for Geochemistry</p>
<p>An integrated set of tools for thermodynamic calculations in aqueous geochemistry
and geobiochemistry. Functions are provided for writing balanced reactions to form
species from user-selected basis species and for calculating the standard molal
properties of species and reactions, including the standard Gibbs energy and
equilibrium constant.</p>
<p>Python port of the CHNOSZ package for R. The original CHNOSZ package belongs to Dr. Jeffrey Dick.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pychnosz.biomolecules" href="biomolecules/index.html">pychnosz.biomolecules</a></code></dt>
<dd>
<div class="desc"><p>Biomolecule thermodynamics package for CHNOSZ …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.core" href="core/index.html">pychnosz.core</a></code></dt>
<dd>
<div class="desc"><p>Core thermodynamic calculation functions for CHNOSZ.</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.data" href="data/index.html">pychnosz.data</a></code></dt>
<dd>
<div class="desc"><p>Data management and access for CHNOSZ thermodynamic database.</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.fortran" href="fortran/index.html">pychnosz.fortran</a></code></dt>
<dd>
<div class="desc"><p>CHNOSZ Fortran interface package …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.geochemistry" href="geochemistry/index.html">pychnosz.geochemistry</a></code></dt>
<dd>
<div class="desc"><p>Geochemistry package for CHNOSZ …</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.models" href="models/index.html">pychnosz.models</a></code></dt>
<dd>
<div class="desc"><p>Equation of state models and water property models for CHNOSZ.</p></div>
</dd>
<dt><code class="name"><a title="pychnosz.utils" href="utils/index.html">pychnosz.utils</a></code></dt>
<dd>
<div class="desc"><p>Utility functions for CHNOSZ calculations.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pychnosz.Berman"><code class="name flex">
<span>def <span class="ident">Berman</span></span>(<span>name: str,<br>T: float | List[float] = 298.15,<br>P: float | List[float] = 1,<br>check_G: bool = False,<br>calc_transition: bool = True,<br>calc_disorder: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Berman(name: str, T: Union[float, List[float]] = 298.15, P: Union[float, List[float]] = 1, 
           check_G: bool = False, calc_transition: bool = True, calc_disorder: bool = True) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate thermodynamic properties of minerals using Berman equations.
    
    Parameters
    ----------
    name : str
        Name of the mineral
    T : float or list, optional
        Temperature in Kelvin (default: 298.15)
    P : float or list, optional  
        Pressure in bar (default: 1)
    check_G : bool, optional
        Check consistency of G in data file (default: False)
    calc_transition : bool, optional
        Calculate polymorphic transition contributions (default: True)
    calc_disorder : bool, optional
        Calculate disorder contributions (default: True)
        
    Returns
    -------
    pd.DataFrame
        DataFrame with columns T, P, G, H, S, Cp, V
    &#34;&#34;&#34;
    
    # Reference temperature and pressure
    Pr = 1
    Tr = 298.15
    
    # Make T and P the same length
    if isinstance(T, (int, float)):
        T = [T]
    if isinstance(P, (int, float)):
        P = [P]

    # Convert to list if numpy array (to avoid element-wise multiplication bug)
    if isinstance(T, np.ndarray):
        T = T.tolist()
    if isinstance(P, np.ndarray):
        P = P.tolist()

    ncond = max(len(T), len(P))
    T = np.array(T * (ncond // len(T) + 1), dtype=float)[:ncond]
    P = np.array(P * (ncond // len(P) + 1), dtype=float)[:ncond]
    
    # Get parameters in the Berman equations
    # Start with thermodynamic parameters provided with CHNOSZ
    thermo_sys = thermo()
    if thermo_sys.Berman is None:
        raise RuntimeError(&#34;Berman data not loaded. Please run pychnosz.reset() first.&#34;)
    
    dat = thermo_sys.Berman.copy()
    
    # TODO: Handle user-supplied data file (thermo()$opt$Berman)
    # For now, just use the default data
    
    # Remove duplicates (only the first, i.e. most recent entry is kept)
    dat = dat.drop_duplicates(subset=[&#39;name&#39;], keep=&#39;first&#39;)
    
    # Remove the multipliers on volume parameters
    vcols = [&#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;, &#39;v4&#39;]  # columns with v1, v2, v3, v4
    multexp = [5, 5, 5, 8]
    for i, col in enumerate(vcols):
        if col in dat.columns:
            dat[col] = dat[col] / (10 ** multexp[i])
    
    # Which row has data for this mineral?
    matching_rows = dat[dat[&#39;name&#39;] == name]
    if len(matching_rows) == 0:
        raise ValueError(f&#34;Data for {name} not available in Berman database&#34;)
    
    dat_mineral = matching_rows.iloc[0]
    
    # Extract parameters for easier access
    GfPrTr = dat_mineral[&#39;GfPrTr&#39;]
    HfPrTr = dat_mineral[&#39;HfPrTr&#39;] 
    SPrTr = dat_mineral[&#39;SPrTr&#39;]
    VPrTr = dat_mineral[&#39;VPrTr&#39;]
    
    k0 = dat_mineral[&#39;k0&#39;]
    k1 = dat_mineral[&#39;k1&#39;] 
    k2 = dat_mineral[&#39;k2&#39;]
    k3 = dat_mineral[&#39;k3&#39;]
    k4 = dat_mineral[&#39;k4&#39;] if not pd.isna(dat_mineral[&#39;k4&#39;]) else 0
    k5 = dat_mineral[&#39;k5&#39;] if not pd.isna(dat_mineral[&#39;k5&#39;]) else 0
    k6 = dat_mineral[&#39;k6&#39;] if not pd.isna(dat_mineral[&#39;k6&#39;]) else 0
    
    v1 = dat_mineral[&#39;v1&#39;] if not pd.isna(dat_mineral[&#39;v1&#39;]) else 0
    v2 = dat_mineral[&#39;v2&#39;] if not pd.isna(dat_mineral[&#39;v2&#39;]) else 0
    v3 = dat_mineral[&#39;v3&#39;] if not pd.isna(dat_mineral[&#39;v3&#39;]) else 0
    v4 = dat_mineral[&#39;v4&#39;] if not pd.isna(dat_mineral[&#39;v4&#39;]) else 0
    
    # Transition parameters
    Tlambda = dat_mineral[&#39;Tlambda&#39;] if not pd.isna(dat_mineral[&#39;Tlambda&#39;]) else None
    Tref = dat_mineral[&#39;Tref&#39;] if not pd.isna(dat_mineral[&#39;Tref&#39;]) else None
    dTdP = dat_mineral[&#39;dTdP&#39;] if not pd.isna(dat_mineral[&#39;dTdP&#39;]) else None
    l1 = dat_mineral[&#39;l1&#39;] if not pd.isna(dat_mineral[&#39;l1&#39;]) else None
    l2 = dat_mineral[&#39;l2&#39;] if not pd.isna(dat_mineral[&#39;l2&#39;]) else None
    
    # Disorder parameters
    Tmin = dat_mineral[&#39;Tmin&#39;] if not pd.isna(dat_mineral[&#39;Tmin&#39;]) else None
    Tmax = dat_mineral[&#39;Tmax&#39;] if not pd.isna(dat_mineral[&#39;Tmax&#39;]) else None
    d0 = dat_mineral[&#39;d0&#39;] if not pd.isna(dat_mineral[&#39;d0&#39;]) else None
    d1 = dat_mineral[&#39;d1&#39;] if not pd.isna(dat_mineral[&#39;d1&#39;]) else None
    d2 = dat_mineral[&#39;d2&#39;] if not pd.isna(dat_mineral[&#39;d2&#39;]) else None
    d3 = dat_mineral[&#39;d3&#39;] if not pd.isna(dat_mineral[&#39;d3&#39;]) else None
    d4 = dat_mineral[&#39;d4&#39;] if not pd.isna(dat_mineral[&#39;d4&#39;]) else None
    Vad = dat_mineral[&#39;Vad&#39;] if not pd.isna(dat_mineral[&#39;Vad&#39;]) else None
    
    # Get the entropy of the elements using the chemical formula
    # Get formula from OBIGT and calculate using entropy() function like in R CHNOSZ
    SPrTr_elements = 0
    if thermo_sys.obigt is not None:
        obigt_match = thermo_sys.obigt[thermo_sys.obigt[&#39;name&#39;] == name]
        if len(obigt_match) &gt; 0:
            formula = obigt_match.iloc[0][&#39;formula&#39;]
            # Import entropy function and calculate SPrTr_elements properly
            from ..utils.formula import entropy
            SPrTr_elements = entropy(formula)
    
    # Check that G in data file follows Benson-Helgeson convention
    if check_G and not pd.isna(GfPrTr):
        GfPrTr_calc = HfPrTr - Tr * (SPrTr - SPrTr_elements)
        Gdiff = GfPrTr_calc - GfPrTr
        if abs(Gdiff) &gt;= 1000:
            warnings.warn(f&#34;{name}: GfPrTr(calc) - GfPrTr(table) is too big! == {round(Gdiff)} J/mol&#34;)
    
    ### Thermodynamic properties ###
    # Calculate Cp and V (Berman, 1988 Eqs. 4 and 5)
    # k4, k5, k6 terms from winTWQ documentation (doi:10.4095/223425)
    Cp = k0 + k1 * T**(-0.5) + k2 * T**(-2) + k3 * T**(-3) + k4 * T**(-1) + k5 * T + k6 * T**2
    
    P_Pr = P - Pr
    T_Tr = T - Tr
    V = VPrTr * (1 + v1 * T_Tr + v2 * T_Tr**2 + v3 * P_Pr + v4 * P_Pr**2)
    
    # Calculate Ha (symbolically integrated using sympy - expressions not simplified)
    intCp = (T*k0 - Tr*k0 + k2/Tr - k2/T + k3/(2*Tr**2) - k3/(2*T**2) + 2.0*k1*T**0.5 - 2.0*k1*Tr**0.5 + 
             k4*np.log(T) - k4*np.log(Tr) + k5*T**2/2 - k5*Tr**2/2 - k6*Tr**3/3 + k6*T**3/3)
    
    intVminusTdVdT = (-VPrTr + P*(VPrTr + VPrTr*v4 - VPrTr*v3 - Tr*VPrTr*v1 + VPrTr*v2*Tr**2 - VPrTr*v2*T**2) +
                      P**2*(VPrTr*v3/2 - VPrTr*v4) + VPrTr*v3/2 - VPrTr*v4/3 + Tr*VPrTr*v1 + 
                      VPrTr*v2*T**2 - VPrTr*v2*Tr**2 + VPrTr*v4*P**3/3)
    
    Ha = HfPrTr + intCp + intVminusTdVdT
    
    # Calculate S (also symbolically integrated)
    intCpoverT = (k0*np.log(T) - k0*np.log(Tr) - k3/(3*T**3) + k3/(3*Tr**3) + k2/(2*Tr**2) - k2/(2*T**2) + 
                  2.0*k1*Tr**(-0.5) - 2.0*k1*T**(-0.5) + k4/Tr - k4/T + T*k5 - Tr*k5 + k6*T**2/2 - k6*Tr**2/2)
    
    intdVdT = -VPrTr*(v1 + v2*(-2*Tr + 2*T)) + P*VPrTr*(v1 + v2*(-2*Tr + 2*T))
    
    S = SPrTr + intCpoverT - intdVdT
    
    # Calculate Ga --&gt; Berman-Brown convention (DG = DH - T*S, no S(element))
    Ga = Ha - T * S
    
    ### Polymorphic transition properties ###
    if (Tlambda is not None and Tref is not None and 
        not pd.isna(Tlambda) and not pd.isna(Tref) and 
        np.any(T &gt; Tref) and calc_transition):
        
        # Starting transition contributions are 0
        Cptr = np.zeros(ncond)
        Htr = np.zeros(ncond)
        Str = np.zeros(ncond)
        
        # Eq. 9: Tlambda at P
        Tlambda_P = Tlambda + dTdP * (P - 1)
        
        # Eq. 8a: Cp at P
        Td = Tlambda - Tlambda_P
        Tprime = T + Td
        
        # With the condition that Tref &lt; Tprime &lt; Tlambda(1bar)
        iTprime = (Tref &lt; Tprime) &amp; (Tprime &lt; Tlambda)
        # Handle NA values
        iTprime = iTprime &amp; ~np.isnan(Tprime)
        
        if np.any(iTprime):
            Tprime_valid = Tprime[iTprime]
            Cptr[iTprime] = Tprime_valid * (l1 + l2 * Tprime_valid)**2
        
        # We got Cp, now calculate the integrations for H and S
        iTtr = T &gt; Tref
        if np.any(iTtr):
            Ttr = T[iTtr].copy()
            Tlambda_P_tr = Tlambda_P[iTtr].copy()
            Td_tr = Td[iTtr] if hasattr(Td, &#39;__len__&#39;) else np.full_like(Ttr, Td)
            
            # Handle NA values
            Tlambda_P_tr[np.isnan(Tlambda_P_tr)] = np.inf
            
            # The upper integration limit is Tlambda_P
            Ttr[Ttr &gt;= Tlambda_P_tr] = Tlambda_P_tr[Ttr &gt;= Tlambda_P_tr]
            
            # Derived variables
            tref = Tref - Td_tr
            x1 = l1**2 * Td_tr + 2 * l1 * l2 * Td_tr**2 + l2**2 * Td_tr**3
            x2 = l1**2 + 4 * l1 * l2 * Td_tr + 3 * l2**2 * Td_tr**2
            x3 = 2 * l1 * l2 + 3 * l2**2 * Td_tr
            x4 = l2**2
            
            # Eqs. 10, 11, 12
            Htr[iTtr] = (x1 * (Ttr - tref) + x2/2 * (Ttr**2 - tref**2) + 
                        x3/3 * (Ttr**3 - tref**3) + x4/4 * (Ttr**4 - tref**4))
            Str[iTtr] = (x1 * (np.log(Ttr) - np.log(tref)) + x2 * (Ttr - tref) + 
                        x3/2 * (Ttr**2 - tref**2) + x4/3 * (Ttr**3 - tref**3))
        
        Gtr = Htr - T * Str
        
        # Apply the transition contributions
        Ga = Ga + Gtr
        Ha = Ha + Htr
        S = S + Str
        Cp = Cp + Cptr
    
    ### Disorder thermodynamic properties ###
    if (Tmin is not None and Tmax is not None and 
        not pd.isna(Tmin) and not pd.isna(Tmax) and 
        np.any(T &gt; Tmin) and calc_disorder):
        
        # Starting disorder contributions are 0
        Cpds = np.zeros(ncond)
        Hds = np.zeros(ncond)
        Sds = np.zeros(ncond)
        Vds = np.zeros(ncond)
        
        # The lower integration limit is Tmin
        iTds = T &gt; Tmin
        if np.any(iTds):
            Tds = T[iTds].copy()
            # The upper integration limit is Tmax
            Tds[Tds &gt; Tmax] = Tmax
            
            # Ber88 Eqs. 15, 16, 17
            Cpds[iTds] = d0 + d1*Tds**(-0.5) + d2*Tds**(-2) + d3*Tds + d4*Tds**2
            Hds[iTds] = (d0*(Tds - Tmin) + d1*(Tds**0.5 - Tmin**0.5)/0.5 +
                        d2*(Tds**(-1) - Tmin**(-1))/(-1) + d3*(Tds**2 - Tmin**2)/2 + d4*(Tds**3 - Tmin**3)/3)
            Sds[iTds] = (d0*(np.log(Tds) - np.log(Tmin)) + d1*(Tds**(-0.5) - Tmin**(-0.5))/(-0.5) +
                        d2*(Tds**(-2) - Tmin**(-2))/(-2) + d3*(Tds - Tmin) + d4*(Tds**2 - Tmin**2)/2)
        
        # Eq. 18; we can&#39;t do this if Vad == 0 (dolomite and gehlenite)
        if Vad is not None and not pd.isna(Vad) and Vad != 0:
            Vds = Hds / Vad
        
        # Include the Vds term with Hds
        Hds = Hds + Vds * (P - Pr)
        
        # Disordering properties above Tmax (Eq. 20)
        ihigh = T &gt; Tmax
        if np.any(ihigh):
            Hds[ihigh] = Hds[ihigh] - (T[ihigh] - Tmax) * Sds[ihigh]
        
        Gds = Hds - T * Sds
        
        # Apply the disorder contributions
        Ga = Ga + Gds
        Ha = Ha + Hds
        S = S + Sds
        V = V + Vds
        Cp = Cp + Cpds
    
    ### (for testing) Use G = H - TS to check that integrals for H and S are written correctly
    Ga_fromHminusTS = Ha - T * S
    if not np.allclose(Ga_fromHminusTS, Ga, atol=1e-6):
        raise RuntimeError(f&#34;{name}: incorrect integrals detected using DG = DH - T*S&#34;)
    
    ### Thermodynamic and unit conventions used in SUPCRT ###
    # Use entropy of the elements in calculation of G --&gt; Benson-Helgeson convention (DG = DH - T*DS)
    Gf = Ga + Tr * SPrTr_elements
    
    # The output will just have &#34;G&#34; and &#34;H&#34;
    G = Gf
    H = Ha
    
    # Convert J/bar to cm^3/mol
    V = V * 10
    
    return pd.DataFrame({
        &#39;T&#39;: T,
        &#39;P&#39;: P, 
        &#39;G&#39;: G,
        &#39;H&#39;: H,
        &#39;S&#39;: S,
        &#39;Cp&#39;: Cp,
        &#39;V&#39;: V
    })</code></pre>
</details>
<div class="desc"><p>Calculate thermodynamic properties of minerals using Berman equations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the mineral</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>list</code>, optional</dt>
<dd>Temperature in Kelvin (default: 298.15)</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float</code> or <code>list</code>, optional</dt>
<dd>Pressure in bar (default: 1)</dd>
<dt><strong><code>check_G</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Check consistency of G in data file (default: False)</dd>
<dt><strong><code>calc_transition</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Calculate polymorphic transition contributions (default: True)</dd>
<dt><strong><code>calc_disorder</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Calculate disorder contributions (default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>DataFrame with columns T, P, G, H, S, Cp, V</dd>
</dl></div>
</dd>
<dt id="pychnosz.G2logK"><code class="name flex">
<span>def <span class="ident">G2logK</span></span>(<span>G, Tc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def G2logK(G, Tc):
    # Gas constant R is in cal/mol K
    return G / (-math.log(10) * 1.9872 * (273.15+Tc))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.OBIGT2eos"><code class="name flex">
<span>def <span class="ident">OBIGT2eos</span></span>(<span>OBIGT, fixGHS=True, tocal=True, messages=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OBIGT2eos(OBIGT, fixGHS=True, tocal=True, messages=True):
    &#34;&#34;&#34;
    Convert OBIGT dataframe to equation of state parameters.

    This function processes the OBIGT thermodynamic database to prepare it for
    equation of state calculations. It handles energy unit conversions and
    optionally fills in missing G, H, or S values.

    Parameters
    ----------
    OBIGT : pd.DataFrame
        OBIGT thermodynamic database
    fixGHS : bool, default True
        Fill in one missing value among G, H, S using thermodynamic relations
    tocal : bool, default True
        Convert energy units from Joules to calories
    messages : bool, default True
        Print informational messages (currently not used, reserved for future)

    Returns
    -------
    pd.DataFrame
        Modified OBIGT dataframe with converted parameters
    &#34;&#34;&#34;
    OBIGT_out = OBIGT.copy()

    # Get column indices for named columns (to handle varying column positions)
    G_idx = OBIGT.columns.get_loc(&#39;G&#39;)
    H_idx = OBIGT.columns.get_loc(&#39;H&#39;)
    S_idx = OBIGT.columns.get_loc(&#39;S&#39;)
    Cp_idx = OBIGT.columns.get_loc(&#39;Cp&#39;)
    V_idx = OBIGT.columns.get_loc(&#39;V&#39;)
    omega_lambda_idx = OBIGT.columns.get_loc(&#39;omega.lambda&#39;)

    for i in range(0, OBIGT.shape[0]):

        # we only convert omega for aqueous species, not lambda for cgl species
        if tocal and OBIGT.iloc[i, :][&#34;E_units&#34;] == &#34;J&#34; and OBIGT.iloc[i, :][&#34;state&#34;] == &#34;aq&#34;:
            # Convert G, H, S, Cp
            OBIGT_out.iloc[i, G_idx:Cp_idx+1] = OBIGT.iloc[i, G_idx:Cp_idx+1]/4.184
            # Convert V through omega (includes omega for aq species)
            OBIGT_out.iloc[i, V_idx:omega_lambda_idx+1] = OBIGT.iloc[i, V_idx:omega_lambda_idx+1]/4.184
            OBIGT_out.iloc[i, OBIGT.columns.get_loc(&#39;E_units&#39;)] = &#34;cal&#34;

        elif tocal and OBIGT.iloc[i, :][&#34;E_units&#34;] == &#34;J&#34;:
            # Convert G, H, S, Cp
            OBIGT_out.iloc[i, G_idx:Cp_idx+1] = OBIGT.iloc[i, G_idx:Cp_idx+1]/4.184
            # Convert V through c2.f (exclude omega.lambda for non-aq species)
            OBIGT_out.iloc[i, V_idx:omega_lambda_idx] = OBIGT.iloc[i, V_idx:omega_lambda_idx]/4.184
            OBIGT_out.iloc[i, OBIGT.columns.get_loc(&#39;E_units&#39;)] = &#34;cal&#34;

        # fill in one of missing G, H, S
        # for use esp. by subcrt because NA for one of G, H or S
        # will preclude calculations at high T
        if fixGHS:
            # which entries are missing just one
            GHS_values = [OBIGT.iloc[i, G_idx], OBIGT.iloc[i, H_idx], OBIGT.iloc[i, S_idx]]
            imiss = [pd.isna(v) for v in GHS_values]
            if sum(imiss) == 1:

                ii = imiss.index(True)

                if ii == 0:  # G is missing
                    H = OBIGT_out.iloc[i, H_idx]
                    S = OBIGT_out.iloc[i, S_idx]
                    Selem = entropy(OBIGT_out.iloc[i, OBIGT_out.columns.get_loc(&#39;formula&#39;)])
                    T = 298.15
                    G = H - T*(S - Selem)
                    OBIGT_out.iloc[i, G_idx] = G
                elif ii == 1:  # H is missing
                    G = OBIGT_out.iloc[i, G_idx]
                    S = OBIGT_out.iloc[i, S_idx]
                    Selem = entropy(OBIGT_out.iloc[i, OBIGT_out.columns.get_loc(&#39;formula&#39;)])
                    T = 298.15
                    H = G + T*(S - Selem)
                    OBIGT_out.iloc[i, H_idx] = H
                elif ii == 2:  # S is missing
                    G = OBIGT_out.iloc[i, G_idx]
                    H = OBIGT_out.iloc[i, H_idx]
                    Selem = entropy(OBIGT_out.iloc[i, OBIGT_out.columns.get_loc(&#39;formula&#39;)])
                    T = 298.15
                    S = Selem + (H - G)/T
                    OBIGT_out.iloc[i, S_idx] = S

    return OBIGT_out</code></pre>
</details>
<div class="desc"><p>Convert OBIGT dataframe to equation of state parameters.</p>
<p>This function processes the OBIGT thermodynamic database to prepare it for
equation of state calculations. It handles energy unit conversions and
optionally fills in missing G, H, or S values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>OBIGT</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>OBIGT thermodynamic database</dd>
<dt><strong><code>fixGHS</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Fill in one missing value among G, H, S using thermodynamic relations</dd>
<dt><strong><code>tocal</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Convert energy units from Joules to calories</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Print informational messages (currently not used, reserved for future)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Modified OBIGT dataframe with converted parameters</dd>
</dl></div>
</dd>
<dt id="pychnosz.ZC"><code class="name flex">
<span>def <span class="ident">ZC</span></span>(<span>formula: str | int | List[str | int]) ‑> float | List[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ZC(formula: Union[str, int, List[Union[str, int]]]) -&gt; Union[float, List[float]]:
    &#34;&#34;&#34;
    Calculate average oxidation state of carbon in chemical formulas.
    
    Parameters
    ----------
    formula : str, int, or list
        Chemical formula(s) or species index(es)
        
    Returns
    -------
    float or list of float
        Average oxidation state(s) of carbon
    &#34;&#34;&#34;
    # Get elemental compositions
    compositions = makeup(formula, count_zero=False)
    if not isinstance(compositions, list):
        compositions = [compositions]
    
    results = []
    
    # Nominal charges of elements
    known_elements = [&#39;H&#39;, &#39;N&#39;, &#39;O&#39;, &#39;S&#39;, &#39;Z&#39;]
    charges = [-1, 3, 2, 2, 1]
    
    for comp in compositions:
        if comp is None or &#39;C&#39; not in comp:
            results.append(np.nan)
            continue
        
        # Calculate total charge from known elements
        total_charge = 0
        unknown_elements = []
        
        for element, count in comp.items():
            if element == &#39;C&#39;:
                continue
            elif element in known_elements:
                idx = known_elements.index(element)
                total_charge += count * charges[idx]
            else:
                unknown_elements.append(element)
        
        if unknown_elements:
            warnings.warn(f&#34;element(s) {&#39; &#39;.join(unknown_elements)} not in &#34;
                         f&#34;{&#39; &#39;.join(known_elements)} so not included in ZC calculation&#34;)
        
        # Calculate carbon oxidation state
        n_carbon = comp[&#39;C&#39;]
        zc = total_charge / n_carbon
        results.append(zc)
    
    if len(results) == 1:
        return results[0]
    else:
        return results</code></pre>
</details>
<div class="desc"><p>Calculate average oxidation state of carbon in chemical formulas.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formula</code></strong> :&ensp;<code>str, int,</code> or <code>list</code></dt>
<dd>Chemical formula(s) or species index(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>list</code> of <code>float</code></dt>
<dd>Average oxidation state(s) of carbon</dd>
</dl></div>
</dd>
<dt id="pychnosz.add_OBIGT"><code class="name flex">
<span>def <span class="ident">add_OBIGT</span></span>(<span>file: str | pandas.core.frame.DataFrame,<br>force: bool = True,<br>messages: bool = True) ‑> List[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_OBIGT(file: Union[str, pd.DataFrame], force: bool = True, messages: bool = True) -&gt; List[int]:
    &#34;&#34;&#34;
    Add or replace entries in the thermodynamic database from external files or DataFrames.

    This function replicates the behavior of R CHNOSZ add.OBIGT() by loading
    CSV files from inst/extdata/OBIGT/ or accepting pandas DataFrames directly,
    and replacing entries with matching names.

    Parameters
    ----------
    file : str or pd.DataFrame
        Either:
        - Name of the database file to load (e.g., &#34;SUPCRT92&#34;)
          The function will look for file.csv in inst/extdata/OBIGT/
        - Full path to a CSV file
        - A pandas DataFrame containing OBIGT data
    force : bool, default True
        If True, proceed even if some species are not found
    messages : bool, default True
        If True, print informational messages about additions/replacements
        If False, suppress all output (equivalent to R&#39;s suppressMessages())

    Returns
    -------
    list of int
        List of species indices (1-based) that were added or replaced

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Example 1: Load from file name
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; indices = pychnosz.add_OBIGT(&#34;SUPCRT92&#34;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Example 2: Load from DataFrame
    &gt;&gt;&gt; thermo_df = pd.read_csv(&#34;thermodata.csv&#34;)
    &gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Example 3: Suppress messages
    &gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df, messages=False)

    Notes
    -----
    This function modifies the thermo() object in place, replacing entries
    with matching names and adding new entries for species not in the database.
    The behavior exactly matches R CHNOSZ add.OBIGT().
    &#34;&#34;&#34;

    # Get the thermo system
    thermo_sys = thermo()

    # Ensure the thermodynamic system is initialized
    if not thermo_sys.is_initialized() or thermo_sys.obigt is None:
        thermo_sys.reset()

    # Handle DataFrame input
    if isinstance(file, pd.DataFrame):
        new_data = file.copy()
        file_path = &#34;&lt;DataFrame&gt;&#34;
        file_basename = None
    else:
        # Handle string file path
        # If file is not an existing path, look for it in OBIGT directories
        if not os.path.exists(file):
            if not file.endswith(&#39;.csv&#39;):
                file_to_find = file + &#39;.csv&#39;
            else:
                file_to_find = file

            # Look for the file in the OBIGT data directory
            # Use package-relative path
            base_paths = [
                os.path.join(os.path.dirname(__file__), &#39;extdata&#39;, &#39;OBIGT&#39;),
            ]

            file_path = None
            for base_path in base_paths:
                potential_path = os.path.join(base_path, file_to_find)
                if os.path.exists(potential_path):
                    file_path = potential_path
                    break

            if file_path is None:
                raise FileNotFoundError(f&#34;Could not find OBIGT file: {file}&#34;)
        else:
            # Use the file path as provided
            file_path = file

        # Extract the basename for source_file column
        file_basename = os.path.basename(file_path)

        # Read the CSV file
        try:
            new_data = pd.read_csv(file_path)
        except Exception as e:
            raise ValueError(f&#34;Error reading {file_path}: {e}&#34;)

    if new_data.empty:
        raise ValueError(f&#34;No data found in {file_path if isinstance(file, str) else &#39;DataFrame&#39;}&#34;)

    # Validate columns before processing
    # Get the current OBIGT database to determine required columns
    to1 = thermo_sys.obigt

    # Define core required columns that all species must have
    # These are the fundamental columns needed for thermodynamic calculations
    # Model-specific columns (logK*, T*, P*, etc.) are optional
    core_required_columns = [
        &#39;name&#39;, &#39;abbrv&#39;, &#39;formula&#39;, &#39;state&#39;, &#39;ref1&#39;, &#39;ref2&#39;, &#39;date&#39;, &#39;E_units&#39;,
        &#39;G&#39;, &#39;H&#39;, &#39;S&#39;, &#39;Cp&#39;, &#39;V&#39;,
        &#39;a1.a&#39;, &#39;a2.b&#39;, &#39;a3.c&#39;, &#39;a4.d&#39;, &#39;c1.e&#39;, &#39;c2.f&#39;, &#39;omega.lambda&#39;, &#39;z.T&#39;
    ]

    # The &#39;model&#39; column is optional and will be auto-generated if missing
    # Filter to only include columns that exist in current OBIGT (for compatibility)
    required_columns = [col for col in core_required_columns if col in to1.columns]

    # Check for missing required columns
    missing_columns = [col for col in required_columns if col not in new_data.columns]

    if missing_columns:
        raise ValueError(
            f&#34;Missing required columns in input data: {&#39;, &#39;.join(missing_columns)}. &#34;
            f&#34;Please ensure the CSV file contains all necessary OBIGT database columns.&#34;
        )

    # Special handling for &#39;model&#39; column
    if &#39;model&#39; not in new_data.columns:
        # Create model column with proper values
        new_data = new_data.copy()  # Make a copy to avoid SettingWithCopyWarning

        # Assign model based on state:
        # - aqueous species (state == &#39;aq&#39;) get &#39;HKF&#39;
        # - non-aqueous species get &#39;CGL&#39;
        new_data[&#39;model&#39;] = new_data[&#39;state&#39;].apply(lambda x: &#39;HKF&#39; if x == &#39;aq&#39; else &#39;CGL&#39;)

        # Issue a warning to inform the user
        warnings.warn(
            &#34;The &#39;model&#39; column was not found in the input data. &#34;
            &#34;Auto-generating &#39;model&#39; column: &#39;HKF&#39; for aqueous species (state=&#39;aq&#39;), &#34;
            &#34;&#39;CGL&#39; for all other species.&#34;,
            UserWarning
        )

    # Get energy units from the file (all unique values)
    # Match R&#39;s behavior: unique values joined with &#34; and &#34;
    if &#39;E_units&#39; in new_data.columns:
        unique_units = new_data[&#39;E_units&#39;].dropna().unique().tolist()
        # Filter out non-energy unit values like &#34;CGL&#34; (which is a model, not energy unit)
        # Valid energy units are typically &#34;cal&#34; and &#34;J&#34;
        energy_unit_names = [str(u) for u in unique_units if str(u) in [&#39;cal&#39;, &#39;J&#39;]]
        # Join in the order they appear in the file (matching R&#39;s paste(unique(...), collapse = &#34; and &#34;))
        energy_units_str = &#39; and &#39;.join(energy_unit_names) if energy_unit_names else &#39;cal&#39;
    else:
        energy_units_str = &#39;cal&#39;

    # Create identifier strings for matching (name + state)
    id1 = to1[&#39;name&#39;].astype(str) + &#39; &#39; + to1[&#39;state&#39;].astype(str)
    id2 = new_data[&#39;name&#39;].astype(str) + &#39; &#39; + new_data[&#39;state&#39;].astype(str)

    # Track the indices we&#39;ve modified/added
    inew = []

    # Check which entries in new_data exist in current database
    # does_exist is a boolean array indicating which id2 entries are in id1
    does_exist = id2.isin(id1.values)

    # Get the indices in to1 where matches exist (matching R&#39;s match(id2, id1))
    # This gives us the positions in to1 for each id2 element
    ispecies_exist = []
    for i, id_val in enumerate(id2):
        if does_exist.iloc[i]:
            # Find the index in to1 where this matches
            match_idx = id1[id1 == id_val].index[0]
            ispecies_exist.append(match_idx)
        else:
            ispecies_exist.append(None)

    nexist = sum(does_exist)

    # Check if new_data has columns that to1 doesn&#39;t have, and add them
    # Use object dtype for new columns to match pandas default behavior and avoid FutureWarning
    for col in new_data.columns:
        if col not in to1.columns:
            # Determine dtype from new_data
            dtype = new_data[col].dtype
            # Use object dtype for string columns to avoid dtype incompatibility
            if dtype == object or pd.api.types.is_string_dtype(dtype):
                to1[col] = pd.Series(dtype=object)
            else:
                to1[col] = np.nan

    if force:
        # Replace existing entries
        if nexist &gt; 0:
            # Update rows in to1 for species that exist
            for i, idx in enumerate(ispecies_exist):
                if idx is not None:
                    # Replace the row in to1 with data from new_data
                    for col in new_data.columns:
                        # col should now be in to1 since we added missing columns above
                        to1.loc[idx, col] = new_data.iloc[i][col]
                    # Set source_file for replaced entries
                    if file_basename is not None:
                        to1.loc[idx, &#39;source_file&#39;] = file_basename

            # Add these indices to inew
            inew.extend([idx for idx in ispecies_exist if idx is not None])

            # Remove existing entries from new_data (to2 &lt;- to2[!does.exist, ])
            to2 = new_data[~does_exist].copy()
        else:
            to2 = new_data.copy()
    else:
        # Ignore any new entries that already exist
        to2 = new_data[~does_exist].copy()
        nexist = 0

    # Add new entries
    if len(to2) &gt; 0:
        # Store the starting index for new additions
        len_id1 = len(id1)

        # Ensure new entries have all required columns
        # Make a proper copy to avoid SettingWithCopyWarning
        to2 = to2.copy()
        for col in to1.columns:
            if col not in to2.columns:
                to2[col] = np.nan

        # Set source_file for new entries
        if file_basename is not None:
            to2[&#39;source_file&#39;] = file_basename

        # Reorder columns to match current OBIGT
        to2 = to2.reindex(columns=to1.columns)

        # Add to the database
        # Use concat with explicit future behavior to avoid FutureWarning
        to1 = pd.concat([to1, to2], ignore_index=True, sort=False)

        # Add new indices: (length(id1)+1):nrow(to1)
        new_indices = list(range(len_id1 + 1, len(to1) + 1))
        inew.extend(new_indices)

    # Reset rownames to 1:nrow (matching R&#39;s rownames(thermo$OBIGT) &lt;- 1:nrow(thermo$OBIGT))
    to1.index = range(1, len(to1) + 1)

    # Update the thermo system with modified database
    thermo_sys.obigt = to1

    # Update formula_ox if the column exists in the database
    if &#39;formula_ox&#39; in to1.columns:
        # Create a DataFrame with name and formula_ox columns
        # Keep the same index as the obigt DataFrame (1-based)
        formula_ox_df = pd.DataFrame({
            &#39;name&#39;: to1[&#39;name&#39;],
            &#39;formula_ox&#39;: to1[&#39;formula_ox&#39;]
        })
        # Preserve the 1-based index
        formula_ox_df.index = to1.index
        thermo_sys.formula_ox = formula_ox_df
    else:
        # If formula_ox column doesn&#39;t exist, set to None
        thermo_sys.formula_ox = None

    # Print summary (matching R CHNOSZ output)
    if messages:
        print(f&#34;add_OBIGT: read {len(new_data)} rows; made {nexist} replacements, {len(to2) if len(to2) &gt; 0 else 0} additions [energy units: {energy_units_str}]&#34;)

    return inew</code></pre>
</details>
<div class="desc"><p>Add or replace entries in the thermodynamic database from external files or DataFrames.</p>
<p>This function replicates the behavior of R CHNOSZ add.OBIGT() by loading
CSV files from inst/extdata/OBIGT/ or accepting pandas DataFrames directly,
and replacing entries with matching names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code> or <code>pd.DataFrame</code></dt>
<dd>Either:
- Name of the database file to load (e.g., "SUPCRT92")
The function will look for file.csv in inst/extdata/OBIGT/
- Full path to a CSV file
- A pandas DataFrame containing OBIGT data</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, proceed even if some species are not found</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, print informational messages about additions/replacements
If False, suppress all output (equivalent to R's suppressMessages())</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>int</code></dt>
<dd>List of species indices (1-based) that were added or replaced</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt;
&gt;&gt;&gt; # Example 1: Load from file name
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; indices = pychnosz.add_OBIGT(&quot;SUPCRT92&quot;)
&gt;&gt;&gt;
&gt;&gt;&gt; # Example 2: Load from DataFrame
&gt;&gt;&gt; thermo_df = pd.read_csv(&quot;thermodata.csv&quot;)
&gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df)
&gt;&gt;&gt;
&gt;&gt;&gt; # Example 3: Suppress messages
&gt;&gt;&gt; indices = pychnosz.add_OBIGT(thermo_df, messages=False)
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function modifies the thermo() object in place, replacing entries
with matching names and adding new entries for species not in the database.
The behavior exactly matches R CHNOSZ add.OBIGT().</p></div>
</dd>
<dt id="pychnosz.add_legend"><code class="name flex">
<span>def <span class="ident">add_legend</span></span>(<span>ax,<br>labels: list = None,<br>loc: str = 'best',<br>frameon: bool = False,<br>fontsize: float = 9,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_legend(ax, labels: list = None, loc: str = &#39;best&#39;,
              frameon: bool = False, fontsize: float = 9, **kwargs):
    &#34;&#34;&#34;
    Add a legend to a diagram with matplotlib or Plotly formatting.

    This is a convenience function that adds a legend with sensible
    defaults matching R CHNOSZ legend styling. Works with both matplotlib
    and Plotly figures.

    Parameters
    ----------
    ax : matplotlib.axes.Axes or plotly.graph_objs.Figure
        Axes/Figure object to add legend to. For interactive diagrams,
        pass the figure from d[&#39;fig&#39;] or d[&#39;ax&#39;].
    labels : list of str
        Legend labels (can be from describe_property, describe_basis, etc.)
    loc : str, default &#39;best&#39;
        Legend location. Options: &#39;best&#39;, &#39;upper left&#39;, &#39;upper right&#39;,
        &#39;lower left&#39;, &#39;lower right&#39;, &#39;right&#39;, &#39;center left&#39;, &#39;center right&#39;,
        &#39;lower center&#39;, &#39;upper center&#39;, &#39;center&#39;
        For Plotly: &#39;best&#39; defaults to &#39;lower right&#39;
    frameon : bool, default False
        Whether to draw a frame around the legend (R bty=&#34;n&#34; equivalent)
    fontsize : float, default 9
        Font size for legend text (R cex=0.9 equivalent)
    **kwargs
        Additional arguments passed to matplotlib legend() or Plotly annotation

    Returns
    -------
    matplotlib.legend.Legend or plotly.graph_objs.Figure
        The legend object (matplotlib) or the figure (Plotly)

    Examples
    --------
    &gt;&gt;&gt; from pychnosz.utils.expression import add_legend, describe_property
    &gt;&gt;&gt; # Matplotlib diagram with plot_it=False
    &gt;&gt;&gt; d1 = diagram(a, interactive=False, plot_it=False)
    &gt;&gt;&gt; dprop = describe_property([&#34;T&#34;, &#34;P&#34;], [300, 1000])
    &gt;&gt;&gt; add_legend(d1[&#39;ax&#39;], dprop, loc=&#39;lower right&#39;)
    &gt;&gt;&gt; # Display the figure in Jupyter:
    &gt;&gt;&gt; from IPython.display import display
    &gt;&gt;&gt; display(d1[&#39;fig&#39;])
    &gt;&gt;&gt; # Or save it:
    &gt;&gt;&gt; d1[&#39;fig&#39;].savefig(&#39;diagram.png&#39;)

    &gt;&gt;&gt; # Plotly diagram
    &gt;&gt;&gt; d1 = diagram(a, interactive=True, plot_it=False)
    &gt;&gt;&gt; dprop = describe_property([&#34;T&#34;, &#34;P&#34;], [300, 1000])
    &gt;&gt;&gt; add_legend(d1[&#39;fig&#39;], dprop, loc=&#39;lower right&#39;)
    &gt;&gt;&gt; d1[&#39;fig&#39;].show()

    Notes
    -----
    Common R legend locations and their matplotlib equivalents:
    - &#34;bottomright&#34; → &#34;lower right&#34;
    - &#34;topleft&#34; → &#34;upper left&#34;
    - &#34;topright&#34; → &#34;upper right&#34;
    - &#34;bottomleft&#34; → &#34;lower left&#34;

    When using plot_it=False, you need to explicitly display the figure after
    adding legends. In Jupyter notebooks, use display(d[&#39;fig&#39;]) or d[&#39;fig&#39;].show()
    for Plotly diagrams. Outside Jupyter, use plt.show() or save with d[&#39;fig&#39;].savefig().
    &#34;&#34;&#34;
    if labels is None:
        raise ValueError(&#34;labels must be provided&#34;)

    # Detect if this is a Plotly figure
    is_plotly = _is_plotly_figure(ax)

    if is_plotly:
        return _add_plotly_legend(ax, labels, loc, frameon, fontsize, **kwargs)
    else:
        return _add_matplotlib_legend(ax, labels, loc, frameon, fontsize, **kwargs)</code></pre>
</details>
<div class="desc"><p>Add a legend to a diagram with matplotlib or Plotly formatting.</p>
<p>This is a convenience function that adds a legend with sensible
defaults matching R CHNOSZ legend styling. Works with both matplotlib
and Plotly figures.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>matplotlib.axes.Axes</code> or <code>plotly.graph_objs.Figure</code></dt>
<dd>Axes/Figure object to add legend to. For interactive diagrams,
pass the figure from d['fig'] or d['ax'].</dd>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Legend labels (can be from describe_property, describe_basis, etc.)</dd>
<dt><strong><code>loc</code></strong> :&ensp;<code>str</code>, default <code>'best'</code></dt>
<dd>Legend location. Options: 'best', 'upper left', 'upper right',
'lower left', 'lower right', 'right', 'center left', 'center right',
'lower center', 'upper center', 'center'
For Plotly: 'best' defaults to 'lower right'</dd>
<dt><strong><code>frameon</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Whether to draw a frame around the legend (R bty="n" equivalent)</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, default <code>9</code></dt>
<dd>Font size for legend text (R cex=0.9 equivalent)</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to matplotlib legend() or Plotly annotation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.legend.Legend</code> or <code>plotly.graph_objs.Figure</code></dt>
<dd>The legend object (matplotlib) or the figure (Plotly)</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz.utils.expression import add_legend, describe_property
&gt;&gt;&gt; # Matplotlib diagram with plot_it=False
&gt;&gt;&gt; d1 = diagram(a, interactive=False, plot_it=False)
&gt;&gt;&gt; dprop = describe_property([&quot;T&quot;, &quot;P&quot;], [300, 1000])
&gt;&gt;&gt; add_legend(d1['ax'], dprop, loc='lower right')
&gt;&gt;&gt; # Display the figure in Jupyter:
&gt;&gt;&gt; from IPython.display import display
&gt;&gt;&gt; display(d1['fig'])
&gt;&gt;&gt; # Or save it:
&gt;&gt;&gt; d1['fig'].savefig('diagram.png')
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Plotly diagram
&gt;&gt;&gt; d1 = diagram(a, interactive=True, plot_it=False)
&gt;&gt;&gt; dprop = describe_property([&quot;T&quot;, &quot;P&quot;], [300, 1000])
&gt;&gt;&gt; add_legend(d1['fig'], dprop, loc='lower right')
&gt;&gt;&gt; d1['fig'].show()
</code></pre>
<h2 id="notes">Notes</h2>
<p>Common R legend locations and their matplotlib equivalents:
- "bottomright" → "lower right"
- "topleft" → "upper left"
- "topright" → "upper right"
- "bottomleft" → "lower left"</p>
<p>When using plot_it=False, you need to explicitly display the figure after
adding legends. In Jupyter notebooks, use display(d['fig']) or d['fig'].show()
for Plotly diagrams. Outside Jupyter, use plt.show() or save with d['fig'].savefig().</p></div>
</dd>
<dt id="pychnosz.add_protein"><code class="name flex">
<span>def <span class="ident">add_protein</span></span>(<span>aa: pandas.core.frame.DataFrame, as_residue: bool = False) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_protein(aa: pd.DataFrame, as_residue: bool = False) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Add protein amino acid compositions to thermo().protein.

    Parameters
    ----------
    aa : DataFrame
        DataFrame with protein amino acid compositions.
        Must have same columns as thermo().protein
    as_residue : bool, default False
        Normalize amino acid counts by protein length

    Returns
    -------
    array
        Row numbers of added/updated proteins in thermo().protein

    Examples
    --------
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; from pychnosz import *
    &gt;&gt;&gt; aa = pd.read_csv(&#34;POLG.csv&#34;)
    &gt;&gt;&gt; iprotein = add_protein(aa)
    &#34;&#34;&#34;
    t = thermo()

    if t.protein is None:
        raise RuntimeError(&#34;Protein database not loaded. Run reset() first.&#34;)

    # Check that columns match
    if list(aa.columns) != list(t.protein.columns):
        raise ValueError(&#34;&#39;aa&#39; does not have the same columns as thermo().protein&#34;)

    # Check that new protein IDs are unique
    po = aa[&#39;protein&#39;] + &#39;_&#39; + aa[&#39;organism&#39;]
    idup = po.duplicated()
    if idup.any():
        dup_proteins = po[idup].unique()
        raise ValueError(f&#34;some protein IDs are duplicated: {&#39; &#39;.join(dup_proteins)}&#34;)

    # Normalize by protein length if as_residue = True
    if as_residue:
        pl = protein_length(aa)
        aa.iloc[:, 4:24] = aa.iloc[:, 4:24].div(pl, axis=0)

    # Find any protein IDs that are already present
    ip = pinfo(po.tolist())
    if isinstance(ip, (int, np.integer)):
        ip = np.array([ip])
    elif not isinstance(ip, np.ndarray):
        ip = np.array([ip])

    ip_present = ~np.isnan(ip)

    # Now we&#39;re ready to go
    tp_new = t.protein.copy()

    # Add new proteins
    if not all(ip_present):
        new_proteins = aa[~ip_present].copy()
        tp_new = pd.concat([tp_new, new_proteins], ignore_index=True)

    # Update existing proteins
    if any(ip_present):
        valid_ip = ip[ip_present].astype(int)
        tp_new.iloc[valid_ip] = aa[ip_present].values

    # Update the protein database
    tp_new.reset_index(drop=True, inplace=True)
    t.protein = tp_new

    # Return the new row numbers
    ip_new = pinfo(po.tolist())
    if isinstance(ip_new, (int, np.integer)):
        ip_new = np.array([ip_new])

    # Print messages
    n_added = sum(~ip_present)
    n_replaced = sum(ip_present)

    if n_added &gt; 0:
        print(f&#34;add_protein: added {n_added} new protein(s) to thermo().protein&#34;)
    if n_replaced &gt; 0:
        print(f&#34;add_protein: replaced {n_replaced} existing protein(s) in thermo().protein&#34;)

    return ip_new</code></pre>
</details>
<div class="desc"><p>Add protein amino acid compositions to thermo().protein.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>aa</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>DataFrame with protein amino acid compositions.
Must have same columns as thermo().protein</dd>
<dt><strong><code>as_residue</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Normalize amino acid counts by protein length</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>Row numbers of added/updated proteins in thermo().protein</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from pychnosz import *
&gt;&gt;&gt; aa = pd.read_csv(&quot;POLG.csv&quot;)
&gt;&gt;&gt; iprotein = add_protein(aa)
</code></pre></div>
</dd>
<dt id="pychnosz.affinity"><code class="name flex">
<span>def <span class="ident">affinity</span></span>(<span>messages: bool = True,<br>basis: pandas.core.frame.DataFrame | None = None,<br>species: pandas.core.frame.DataFrame | None = None,<br>iprotein: int | List[int] | numpy.ndarray | None = None,<br>loga_protein: float | List[float] = 0.0,<br>**kwargs) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affinity(messages: bool = True, basis: Optional[pd.DataFrame] = None,
             species: Optional[pd.DataFrame] = None, iprotein: Optional[Union[int, List[int], np.ndarray]] = None,
             loga_protein: Union[float, List[float]] = 0.0, **kwargs) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Calculate affinities of formation reactions.

    This function calculates chemical affinities for the formation reactions of
    species of interest from user-selected basis species. The affinities are
    calculated as A/2.303RT where A is the chemical affinity.

    Parameters
    ----------
    messages : bool, default True
        Whether to print informational messages
    basis : pd.DataFrame, optional
        Basis species definition to use (if not using global basis)
    species : pd.DataFrame, optional
        Species definition to use (if not using global species)
    iprotein : int, list of int, or array, optional
        Build proteins from residues (row numbers in thermo().protein)
    loga_protein : float or list of float, default 0.0
        Activity of proteins (log scale)
    **kwargs : dict
        Variable arguments defining calculation conditions:
        - Basis species names (e.g., CO2=[-60, 20, 5]): Variable basis species activities
        - T : float or list, Temperature in °C
        - P : float or list, Pressure in bar
        - property : str, Property to calculate (&#34;A&#34;, &#34;logK&#34;, &#34;G&#34;, etc.)
        - exceed_Ttr : bool, Allow extrapolation beyond transition temperatures
        - exceed_rhomin : bool, Allow calculations below minimum water density
        - return_buffer : bool, Return buffer activities
        - balance : str, Balance method for protein buffers

    Returns
    -------
    dict
        Dictionary containing:
        - fun : str, Function name (&#34;affinity&#34;)
        - args : dict, Arguments used in calculation
        - sout : dict, Subcrt calculation results
        - property : str, Property calculated
        - basis : pd.DataFrame, Basis species definition
        - species : pd.DataFrame, Species of interest definition
        - T : float or array, Temperature(s) in Kelvin
        - P : float or array, Pressure(s) in bar
        - vars : list, Variable names
        - vals : dict, Variable values
        - values : dict, Calculated affinity values by species

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; pychnosz.basis([&#34;CO2&#34;, &#34;H2O&#34;, &#34;NH3&#34;, &#34;H2S&#34;, &#34;H+&#34;, &#34;O2&#34;])
    &gt;&gt;&gt; pychnosz.species([&#34;glycine&#34;, &#34;tyrosine&#34;, &#34;serine&#34;, &#34;methionine&#34;])
    &gt;&gt;&gt; result = pychnosz.affinity(CO2=[-60, 20, 5], T=350, P=2000)
    &gt;&gt;&gt; print(result[&#39;values&#39;][1566])  # Glycine affinities

    &gt;&gt;&gt; # With proteins
    &gt;&gt;&gt; import pandas as pd
    &gt;&gt;&gt; aa = pd.read_csv(&#34;POLG.csv&#34;)
    &gt;&gt;&gt; iprotein = pychnosz.add_protein(aa)
    &gt;&gt;&gt; pychnosz.basis(&#34;CHNOSe&#34;)
    &gt;&gt;&gt; a = pychnosz.affinity(iprotein=iprotein, pH=[2, 14], Eh=[-1, 1])

    Notes
    -----
    This implementation maintains complete fidelity to R CHNOSZ affinity():
    - Identical argument processing including dynamic basis species parameters
    - Same variable expansion and multi-dimensional calculations
    - Exact energy() function behavior for property calculations
    - Identical output structure and formatting
    - Support for protein calculations via iprotein parameter
    &#34;&#34;&#34;

    # Get thermo object for protein handling
    thermo_obj = thermo()

    # Handle iprotein parameter
    ires = None
    original_species = None
    if iprotein is not None:
        # Convert to array
        if isinstance(iprotein, (int, np.integer)):
            iprotein = np.array([iprotein])
        elif isinstance(iprotein, list):
            iprotein = np.array(iprotein)

        # Check all proteins are available
        if np.any(np.isnan(iprotein)):
            raise AffinityError(&#34;`iprotein` has some NA values&#34;)
        if thermo_obj.protein is None or not np.all(iprotein &lt; len(thermo_obj.protein)):
            raise AffinityError(&#34;some value(s) of `iprotein` are not rownumbers of thermo().protein&#34;)

        # Add protein residues to the species list
        # Amino acids in 3-letter code
        aminoacids_3 = [&#34;Ala&#34;, &#34;Cys&#34;, &#34;Asp&#34;, &#34;Glu&#34;, &#34;Phe&#34;, &#34;Gly&#34;, &#34;His&#34;, &#34;Ile&#34;, &#34;Lys&#34;, &#34;Leu&#34;,
                        &#34;Met&#34;, &#34;Asn&#34;, &#34;Pro&#34;, &#34;Gln&#34;, &#34;Arg&#34;, &#34;Ser&#34;, &#34;Thr&#34;, &#34;Val&#34;, &#34;Trp&#34;, &#34;Tyr&#34;]

        # Use _RESIDUE notation (matches R CHNOSZ affinity.R line 84)
        resnames_residue = [&#34;H2O_RESIDUE&#34;] + [f&#34;{aa}_RESIDUE&#34; for aa in aminoacids_3]

        # Save original species
        from .species import species as species_func
        original_species = get_species() if is_species_defined() else None

        # Add residue species with activity 0 (all in &#34;aq&#34; state)
        species_func(resnames_residue, state=&#34;aq&#34;, add=True, messages=messages)

        # Get indices of residues in species list
        species_df_temp = get_species()
        ires = []
        for name in resnames_residue:
            idx = np.where(species_df_temp[&#39;name&#39;] == name)[0]
            if len(idx) &gt; 0:
                ires.append(idx[0])
        ires = np.array(ires)

    # Check if basis and species are defined (use provided or global)
    if basis is None:
        if not is_basis_defined():
            raise AffinityError(&#34;basis species are not defined&#34;)
        basis_df = get_basis()
    else:
        basis_df = basis

    if species is None:
        if not is_species_defined():
            raise AffinityError(&#34;species are not defined&#34;)
        species_df = get_species()
    else:
        species_df = species

    # Process arguments
    args_orig = dict(kwargs)

    # Handle argument recall (if first argument is previous affinity result)
    if len(args_orig) &gt; 0:
        first_key = list(args_orig.keys())[0]
        first_value = args_orig[first_key]
        if (isinstance(first_value, dict) and
            first_value.get(&#39;fun&#39;) == &#39;affinity&#39;):
            # Update arguments from previous result
            aargs = first_value.get(&#39;args&#39;, {})
            # Update with new arguments (skip the first one)
            new_args = dict(list(args_orig.items())[1:])
            aargs.update(new_args)
            return affinity(**aargs)

    # Process energy arguments
    args = energy_args(args_orig, messages, basis_df=basis_df)

    # Get property to calculate
    property_name = args.get(&#39;what&#39;, &#39;A&#39;)

    # Get thermo data
    thermo_obj = thermo()
    # basis_df and species_df are already set above

    # Determine if we need specific property calculation
    if property_name and property_name != &#39;A&#39;:
        # Calculate specific property using energy function
        energy_result = energy(
            what=property_name,
            vars=args[&#39;vars&#39;],
            vals=args[&#39;vals&#39;],
            lims=args[&#39;lims&#39;],
            T=args[&#39;T&#39;],
            P=args[&#39;P&#39;],
            IS=args.get(&#39;IS&#39;, 0),
            exceed_Ttr=kwargs.get(&#39;exceed_Ttr&#39;, True),
            exceed_rhomin=kwargs.get(&#39;exceed_rhomin&#39;, False),
            basis_df=basis_df,
            species_df=species_df,
            messages=messages
        )
        affinity_values = energy_result[&#39;a&#39;]
        energy_sout = energy_result[&#39;sout&#39;]
    else:
        # Calculate affinities (A/2.303RT)
        energy_result = energy(
            what=&#39;A&#39;,
            vars=args[&#39;vars&#39;],
            vals=args[&#39;vals&#39;],
            lims=args[&#39;lims&#39;],
            T=args[&#39;T&#39;],
            P=args[&#39;P&#39;],
            IS=args.get(&#39;IS&#39;, 0),
            exceed_Ttr=kwargs.get(&#39;exceed_Ttr&#39;, True),
            exceed_rhomin=kwargs.get(&#39;exceed_rhomin&#39;, False),
            basis_df=basis_df,
            species_df=species_df,
            messages=messages
        )
        affinity_values = energy_result[&#39;a&#39;]
        energy_sout = energy_result[&#39;sout&#39;]

    # Handle protein affinity calculations if iprotein was provided
    if iprotein is not None and ires is not None:
        # Calculate protein affinities from residue affinities using group additivity
        # Normalize loga_protein to match number of proteins
        if isinstance(loga_protein, (int, float)):
            loga_protein_arr = np.full(len(iprotein), loga_protein)
        else:
            loga_protein_arr = np.array(loga_protein)
            if len(loga_protein_arr) &lt; len(iprotein):
                loga_protein_arr = np.resize(loga_protein_arr, len(iprotein))

        # Calculate affinity for each protein
        protein_affinities = {}

        for ip, iprot in enumerate(iprotein):
            # Get protein amino acid composition from thermo().protein
            # Columns 4:24 contain chains and amino acid counts (0-indexed: columns 4-23)
            protein_row = thermo_obj.protein.iloc[iprot]
            aa_counts = protein_row.iloc[4:24].values.astype(float)

            # Calculate protein affinity by summing residue affinities weighted by composition
            # affinity_values keys are ispecies indices
            # Get the ispecies for each residue
            species_df_current = get_species()
            residue_ispecies = species_df_current.iloc[ires][&#39;ispecies&#39;].values

            # Initialize protein affinity with same shape as residue affinities
            first_residue_key = residue_ispecies[0]
            if first_residue_key in affinity_values:
                template_affinity = affinity_values[first_residue_key]
                protein_affinity = np.zeros_like(template_affinity)

                # Sum up contributions from all residues
                for i, res_ispecies in enumerate(residue_ispecies):
                    if res_ispecies in affinity_values:
                        residue_contrib = affinity_values[res_ispecies] * aa_counts[i]
                        protein_affinity = protein_affinity + residue_contrib

                # Subtract protein activity
                protein_affinity = protein_affinity - loga_protein_arr[ip]

                # Use negative index to denote protein (matches R CHNOSZ convention)
                protein_key = -(iprot + 1)  # Negative of (row number + 1)
                protein_affinities[protein_key] = protein_affinity

        # Add ionization affinity if H+ is in basis (matching R CHNOSZ behavior)
        if &#39;H+&#39; in basis_df.index:
            if messages:
                print(&#34;affinity: ionizing proteins ...&#34;)

            # Get protein amino acid compositions
            from ..biomolecules.proteins import pinfo
            from ..biomolecules.ionize_aa import ionize_aa

            # Get aa compositions for these proteins
            aa = pinfo(iprotein)

            # Determine pH values from vars/vals or basis
            # Check if H+ is a variable
            if &#39;H+&#39; in args[&#39;vars&#39;]:
                # H+ is a variable - get pH from vals
                iHplus = args[&#39;vars&#39;].index(&#39;H+&#39;)
                pH_vals = -np.array(args[&#39;vals&#39;][iHplus])  # pH = -log(a_H+)
            else:
                # H+ is constant - get from basis
                pH_val = -basis_df.loc[&#39;H+&#39;, &#39;logact&#39;]  # pH = -log(a_H+)
                pH_vals = np.array([pH_val])

            # Get T values (already processed earlier)
            T_vals = args[&#39;T&#39;]
            if isinstance(T_vals, (int, float)):
                T_celsius = T_vals - 273.15
            else:
                T_celsius = T_vals - 273.15

            # Get P values
            P_vals = args[&#39;P&#39;]

            # Calculate ionization affinity
            # ionize_aa expects arrays, so ensure T, P, pH are properly shaped
            # For grid calculations, we need to expand T, P, pH into a grid matching the affinity grid
            if len(args[&#39;vars&#39;]) &gt;= 2:
                # Multi-dimensional case - create grid
                # Figure out which vars are T, P, H+
                var_names = args[&#39;vars&#39;]
                has_T_var = &#39;T&#39; in var_names
                has_P_var = &#39;P&#39; in var_names
                has_Hplus_var = &#39;H+&#39; in var_names

                # Build T, P, pH grids matching the affinity calculation grid
                if has_T_var and has_Hplus_var:
                    # Both T and pH vary - create meshgrid
                    T_grid, pH_grid = np.meshgrid(T_celsius, pH_vals, indexing=&#39;ij&#39;)
                    T_flat = T_grid.flatten()
                    pH_flat = pH_grid.flatten()
                    if isinstance(P_vals, str):
                        P_flat = np.array([P_vals] * len(T_flat))
                    else:
                        P_flat = np.full(len(T_flat), P_vals if isinstance(P_vals, (int, float)) else P_vals[0])
                elif has_T_var:
                    # Only T varies
                    T_flat = T_celsius if isinstance(T_celsius, np.ndarray) else np.array([T_celsius])
                    pH_flat = np.full(len(T_flat), pH_vals[0])
                    P_flat = np.array([P_vals] * len(T_flat)) if isinstance(P_vals, str) else np.full(len(T_flat), P_vals if isinstance(P_vals, (int, float)) else P_vals[0])
                elif has_Hplus_var:
                    # Only pH varies
                    pH_flat = pH_vals
                    T_flat = np.full(len(pH_flat), T_celsius if isinstance(T_celsius, (int, float)) else T_celsius[0])
                    P_flat = np.array([P_vals] * len(pH_flat)) if isinstance(P_vals, str) else np.full(len(pH_flat), P_vals if isinstance(P_vals, (int, float)) else P_vals[0])
                else:
                    # No T or pH variables
                    T_flat = np.array([T_celsius if isinstance(T_celsius, (int, float)) else T_celsius[0]])
                    pH_flat = pH_vals
                    P_flat = np.array([P_vals] if isinstance(P_vals, str) else [P_vals if isinstance(P_vals, (int, float)) else P_vals[0]])
            else:
                # Single or no variable case
                T_flat = np.array([T_celsius if isinstance(T_celsius, (int, float)) else T_celsius[0]])
                pH_flat = pH_vals if isinstance(pH_vals, np.ndarray) else np.array([pH_vals[0] if hasattr(pH_vals, &#39;__getitem__&#39;) else pH_vals])
                P_flat = np.array([P_vals] if isinstance(P_vals, str) else [P_vals if isinstance(P_vals, (int, float)) else P_vals[0]])

            # Call ionize_aa to get ionization affinity
            ionization_result = ionize_aa(aa, property=&#34;A&#34;, T=T_flat, P=P_flat, pH=pH_flat)

            # Add ionization affinity to formation affinity for each protein
            for ip, iprot in enumerate(iprotein):
                protein_key = -(iprot + 1)
                ionization_affinity = ionization_result.iloc[:, ip].values

                # Reshape to match formation affinity dimensions if needed
                formation_affinity = protein_affinities[protein_key]
                if isinstance(formation_affinity, np.ndarray):
                    if formation_affinity.shape != ionization_affinity.shape:
                        # Reshape ionization affinity to match formation affinity
                        ionization_affinity = ionization_affinity.reshape(formation_affinity.shape)

                # Add ionization to formation affinity
                protein_affinities[protein_key] = formation_affinity + ionization_affinity

        # Replace affinity_values with protein affinities
        affinity_values = protein_affinities

        # Calculate stoichiometric coefficients for proteins using matrix multiplication
        # This matches R CHNOSZ: protbasis &lt;- t(t((resspecies[ires, 1:nrow(thermo$basis)])) %*% t((thermo$protein[iprotein, 5:25])))
        # IMPORTANT: Get the species list BEFORE deletion
        species_df_with_residues = get_species()

        # Extract basis species coefficients from residue species (rows = residues, cols = basis species)
        # ires contains indices of residues in the species list
        # We need the columns corresponding to basis species
        basis_cols = list(basis_df.index)  # e.g., [&#39;CO2&#39;, &#39;H2O&#39;, &#39;NH3&#39;, &#39;H2S&#39;, &#39;e-&#39;, &#39;H+&#39;]

        # Create residue coefficient matrix (n_residues x n_basis)
        # resspecies[ires, 1:nrow(thermo$basis)] in R
        res_coeffs = species_df_with_residues.iloc[ires][basis_cols].values.astype(float)

        # Get amino acid composition matrix (n_proteins x n_residues)
        # thermo$protein[iprotein, 5:25] in R (columns 5-25 contain chains and 20 amino acids)
        # In Python (0-indexed): columns 4:24 contain chains and 20 amino acids
        aa_composition = []
        for iprot in iprotein:
            protein_row = thermo_obj.protein.iloc[iprot]
            # Columns 4:24 contain: chains, Ala, Cys, Asp, Glu, Phe, Gly, His, Ile, Lys, Leu,
            #                       Met, Asn, Pro, Gln, Arg, Ser, Thr, Val, Trp, Tyr
            aa_counts = protein_row.iloc[4:24].values.astype(float)
            aa_composition.append(aa_counts)
        aa_composition = np.array(aa_composition)  # Shape: (n_proteins, 21)

        # Matrix multiplication: (n_proteins x 21) @ (21 x n_basis) = (n_proteins x n_basis)
        # Note: res_coeffs has shape (21, n_basis) - first row is H2O, next 20 are amino acids
        # R code: t(t(resspecies) %*% t(protein)) means: (n_basis x n_residues) @ (n_residues x n_proteins) = (n_basis x n_proteins)
        # Then transpose to get (n_proteins x n_basis)
        # In Python: (n_proteins x n_residues) @ (n_residues x n_basis) = (n_proteins x n_basis)
        protein_coeffs = aa_composition @ res_coeffs  # Shape: (n_proteins, n_basis)

        # Delete residue species from species list now that we have the coefficients
        from .species import species as species_func
        species_func(ires.tolist(), delete=True, messages=False)

        if original_species is not None:
            # Restore original species (but we&#39;ve already calculated, so just update species_df)
            pass

        # Create DataFrame for proteins with basis species coefficients
        species_data = {}

        # Add basis species columns
        for j, basis_sp in enumerate(basis_cols):
            species_data[basis_sp] = protein_coeffs[:, j]

        # Add metadata columns
        protein_names = []
        protein_ispecies = []

        for iprot in iprotein:
            prot_row = thermo_obj.protein.iloc[iprot]
            # Escape underscores for LaTeX compatibility in diagram labels
            protein_name = f&#34;{prot_row[&#39;protein&#39;]}_{prot_row[&#39;organism&#39;]}&#34;
            # Replace underscores with escaped version for matplotlib/LaTeX
            protein_name_escaped = protein_name.replace(&#39;_&#39;, r&#39;\_&#39;)
            protein_names.append(protein_name_escaped)
            protein_ispecies.append(-(iprot + 1))  # Negative index

        species_data[&#39;ispecies&#39;] = protein_ispecies
        species_data[&#39;logact&#39;] = loga_protein_arr[:len(iprotein)]
        species_data[&#39;state&#39;] = [&#39;aq&#39;] * len(iprotein)
        species_data[&#39;name&#39;] = protein_names

        species_df = pd.DataFrame(species_data)

    # Process temperature and pressure for output
    T_out = args[&#39;T&#39;]
    P_out = args[&#39;P&#39;]
    vars_list = args[&#39;vars&#39;]
    vals_dict = {}

    # Convert variable names and values for output
    # Important: Keep vars_list with actual basis species names (H+, e-) for internal use
    # but create display versions in vals_dict with user-friendly names (pH, pe, Eh)
    vars_list_display = vars_list.copy()
    for i, var in enumerate(vars_list):
        # Handle pH, pe, Eh conversions for output
        if var == &#39;H+&#39; and &#39;pH&#39; in args_orig:
            vars_list_display[i] = &#39;pH&#39;
            vals_dict[&#39;pH&#39;] = [-val for val in args[&#39;vals&#39;][i]]
        elif var == &#39;e-&#39; and &#39;pe&#39; in args_orig:
            vars_list_display[i] = &#39;pe&#39;
            vals_dict[&#39;pe&#39;] = [-val for val in args[&#39;vals&#39;][i]]
        elif var == &#39;e-&#39; and &#39;Eh&#39; in args_orig:
            vars_list_display[i] = &#39;Eh&#39;
            # Convert from log(a_e-) back to Eh using temperature-dependent formula
            # log(a_e-) = -pe, so pe = -log(a_e-)
            # Eh = pe * (ln(10) * R * T) / F = -log(a_e-) * T / 5039.76
            T_kelvin = args[&#39;T&#39;] if isinstance(args[&#39;T&#39;], (int, float)) else args[&#39;T&#39;][0] if hasattr(args[&#39;T&#39;], &#39;__len__&#39;) else 298.15
            conversion_factor = T_kelvin / 5039.76  # volts per pe unit
            vals_dict[&#39;Eh&#39;] = [-val * conversion_factor for val in args[&#39;vals&#39;][i]]
        else:
            vals_dict[var] = args[&#39;vals&#39;][i]

    # Keep vars_list as-is (with basis species names) for internal calculations
    # vars_list_display will be used for output only

    # Check if T or P are variables
    if &#39;T&#39; in vars_list:
        T_out = []  # Variable T
        # Convert back to Celsius for output
        T_vals = vals_dict[&#39;T&#39;]
        vals_dict[&#39;T&#39;] = [T - 273.15 for T in T_vals]
    else:
        # Convert to Kelvin for output (matching R)
        T_out = args[&#39;T&#39;]

    if &#39;P&#39; in vars_list:
        P_out = []  # Variable P
    else:
        P_out = args[&#39;P&#39;]

    # Build output dictionary matching R CHNOSZ structure
    result = {
        &#39;fun&#39;: &#39;affinity&#39;,
        &#39;args&#39;: {
            **args_orig,
            &#39;property&#39;: property_name,
            &#39;exceed_Ttr&#39;: kwargs.get(&#39;exceed_Ttr&#39;, False),
            &#39;exceed_rhomin&#39;: kwargs.get(&#39;exceed_rhomin&#39;, False),
            &#39;return_buffer&#39;: kwargs.get(&#39;return_buffer&#39;, False),
            &#39;balance&#39;: kwargs.get(&#39;balance&#39;, &#39;PBB&#39;)
        },
        &#39;sout&#39;: energy_sout,
        &#39;property&#39;: property_name,
        &#39;basis&#39;: basis_df,
        &#39;species&#39;: species_df,
        &#39;T&#39;: T_out,
        &#39;P&#39;: P_out,
        &#39;vars&#39;: vars_list_display,  # Use display version with &#39;Eh&#39;, &#39;pH&#39;, &#39;pe&#39; for output
        &#39;vals&#39;: vals_dict,
        &#39;values&#39;: affinity_values
    }

    return result</code></pre>
</details>
<div class="desc"><p>Calculate affinities of formation reactions.</p>
<p>This function calculates chemical affinities for the formation reactions of
species of interest from user-selected basis species. The affinities are
calculated as A/2.303RT where A is the chemical affinity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
<dt><strong><code>basis</code></strong> :&ensp;<code>pd.DataFrame</code>, optional</dt>
<dd>Basis species definition to use (if not using global basis)</dd>
<dt><strong><code>species</code></strong> :&ensp;<code>pd.DataFrame</code>, optional</dt>
<dd>Species definition to use (if not using global species)</dd>
<dt><strong><code>iprotein</code></strong> :&ensp;<code>int, list</code> of <code>int,</code> or <code>array</code>, optional</dt>
<dd>Build proteins from residues (row numbers in thermo().protein)</dd>
<dt><strong><code>loga_protein</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, default <code>0.0</code></dt>
<dd>Activity of proteins (log scale)</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Variable arguments defining calculation conditions:
- Basis species names (e.g., CO2=[-60, 20, 5]): Variable basis species activities
- T : float or list, Temperature in °C
- P : float or list, Pressure in bar
- property : str, Property to calculate ("A", "logK", "G", etc.)
- exceed_Ttr : bool, Allow extrapolation beyond transition temperatures
- exceed_rhomin : bool, Allow calculations below minimum water density
- return_buffer : bool, Return buffer activities
- balance : str, Balance method for protein buffers</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing:
- fun : str, Function name ("affinity")
- args : dict, Arguments used in calculation
- sout : dict, Subcrt calculation results
- property : str, Property calculated
- basis : pd.DataFrame, Basis species definition
- species : pd.DataFrame, Species of interest definition
- T : float or array, Temperature(s) in Kelvin
- P : float or array, Pressure(s) in bar
- vars : list, Variable names
- vals : dict, Variable values
- values : dict, Calculated affinity values by species</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; pychnosz.basis([&quot;CO2&quot;, &quot;H2O&quot;, &quot;NH3&quot;, &quot;H2S&quot;, &quot;H+&quot;, &quot;O2&quot;])
&gt;&gt;&gt; pychnosz.species([&quot;glycine&quot;, &quot;tyrosine&quot;, &quot;serine&quot;, &quot;methionine&quot;])
&gt;&gt;&gt; result = pychnosz.affinity(CO2=[-60, 20, 5], T=350, P=2000)
&gt;&gt;&gt; print(result['values'][1566])  # Glycine affinities
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # With proteins
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; aa = pd.read_csv(&quot;POLG.csv&quot;)
&gt;&gt;&gt; iprotein = pychnosz.add_protein(aa)
&gt;&gt;&gt; pychnosz.basis(&quot;CHNOSe&quot;)
&gt;&gt;&gt; a = pychnosz.affinity(iprotein=iprotein, pH=[2, 14], Eh=[-1, 1])
</code></pre>
<h2 id="notes">Notes</h2>
<p>This implementation maintains complete fidelity to R CHNOSZ affinity():
- Identical argument processing including dynamic basis species parameters
- Same variable expansion and multi-dimensional calculations
- Exact energy() function behavior for property calculations
- Identical output structure and formatting
- Support for protein calculations via iprotein parameter</p></div>
</dd>
<dt id="pychnosz.animation"><code class="name flex">
<span>def <span class="ident">animation</span></span>(<span>basis_args={},<br>species_args={},<br>affinity_args={},<br>equilibrate_args=None,<br>diagram_args={},<br>anim_var='T',<br>anim_range=[0, 350, 8],<br>xlab=None,<br>ylab=None,<br>save_as='newanimationframe',<br>save_format='png',<br>height=300,<br>width=400,<br>save_scale=1,<br>messages=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animation(basis_args={}, species_args={}, affinity_args={},
              equilibrate_args=None, diagram_args={},
              anim_var=&#34;T&#34;, anim_range=[0, 350, 8], xlab=None, ylab=None,
              save_as=&#34;newanimationframe&#34;, save_format=&#34;png&#34;, height=300,
              width=400, save_scale=1,
              messages=False):
    
    &#34;&#34;&#34;
    Produce an animated interactive affinity, activity, or predominance diagram.
    
    Parameters
    ----------
    basis_args : dict
        Dictionary of options for defining basis species (see `basis`) in the
        animated diagram.
        Example: basis_args={&#39;species&#39;:[&#39;CO2&#39;, &#39;O2&#39;, &#39;H2O&#39;, &#39;H+&#39;]}

    species_args : dict
        Dictionary of options for defining species (see `species`) in the
        animated diagram, or a list of dicts.
        Example 1: species_args={&#39;species&#39;:[&#39;CO2&#39;, &#39;HCO3-&#39;, &#39;CO3-2&#39;]}
        Example 2: species_args=[
                {&#39;species&#39;:[&#39;CO2&#39;, &#39;HCO3-&#39;, &#39;CO3-2&#39;], &#39;state&#39;:[-4]},
                {&#39;species&#39;:[&#39;graphite&#39;], state:[0], &#39;add&#39;:True}]

    affinity_args : dict
        Dictionary of options for defining the affinity calculation (see
        `affinity`).
        Example: affinity_args={&#34;pH&#34;:[2, 12, 100]}
        Example: affinity_args={&#34;pH&#34;:[2, 12, 100], &#34;P&#34;:[2000, 4000, 100]}
    
    equilibrate_args : dict or None, default None
        Dictionary of options for defining equilibration calculation
        (see `equilibrate`). If None, plots output from `affinity`.
        Example: equilibrate_args={&#34;balance&#34;:1}
    
    diagram_args : dict
        Dictionary of options for diagramming (see `diagram`). Diagram option
        `interactive` is set to True.
        Example: diagram_args={&#34;alpha&#34;:True}
    
    anim_var : str, default &#34;T&#34;
        Variable that changes with each frame of animation.
    
    anim_range : list of numeric, default [0, 350, 8]
        The first two numbers in the list are the starting and ending
        values for `anim_var`. The third number in the list is the desired
        number of animation frames.

    xlab, ylab : str, optional
        Custom names for the X and Y axes.
    
    messages : bool, default True
        Display messages from CHNOSZ?
    
    Returns
    -------
    An interactive animated plot.
    &#34;&#34;&#34;
    
    # cap number of frames in animation. Remove limitation after more testing.
    if isinstance(anim_range, list):
        if len(anim_range) == 3:
            if anim_range[2] &gt; 30:
                raise Exception(&#34;anim_range is limited to 30 frames.&#34;)
        else:
            raise Exception(&#34;anim_range must be a list with three values: starting &#34;
                            &#34;value of anim_var, stopping value, and number of &#34;
                            &#34;frames in the animation&#34;)
    else:
        raise Exception(&#34;anim_range must be a list with three values: starting &#34;
                        &#34;value of anim_var, stopping value, and number of &#34;
                        &#34;frames in the animation&#34;)

    if isinstance(basis_args, dict):
        if &#34;species&#34; not in basis_args.keys():
            raise Exception(&#34;basis_args needs to contain a list of species for &#39;species&#39;. &#34;
                            &#34;Example: basis_args={&#39;species&#39;:[&#39;CO2&#39;, &#39;O2&#39;, &#39;H2O&#39;, &#39;H+&#39;]}&#34;)
    else:
        raise Exception(&#34;basis_args needs to be a Python dictionary with a key &#34;
                        &#34;called &#39;species&#39; (additional keys are optional). &#34;
                        &#34;Example: basis_args={&#39;species&#39;:[&#39;CO2&#39;, &#39;O2&#39;, &#39;H2O&#39;, &#39;H+&#39;]}&#34;)


    # Add messages parameter to basis_args if not already present
    if &#34;messages&#34; not in basis_args.keys():
        basis_args[&#34;messages&#34;] = messages

    basis_out = basis(**basis_args)
    basis_sp = list(basis_out.index)
    basis_state = list(basis_out[&#34;state&#34;])
    
    if isinstance(species_args, dict):
        if &#34;species&#34; not in species_args.keys():
            raise Exception(&#34;species_args needs to contain a list of species for &#39;species&#39;. &#34;
                            &#34;Example: species_args={&#39;species&#39;:[&#39;CO2&#39;, &#39;HCO3-&#39;, &#39;CO3-2&#39;]}&#34;)
        species_args_list = [species_args]
    elif isinstance(species_args, list):
        species_args_list = species_args
        for species_args in species_args_list:
            if &#34;species&#34; not in species_args.keys():
                raise Exception(&#34;species_args needs to contain a list of species for &#39;species&#39;. &#34;
                                &#34;Example: species_args={&#39;species&#39;:[&#39;CO2&#39;, &#39;HCO3-&#39;, &#39;CO3-2&#39;]}&#34;)
    else:
        raise Exception(&#34;species_args needs to be either a Python dictionary with a key &#34;
                        &#34;called &#39;species&#39; (additional keys are optional). &#34;
                        &#34;Example: species_args={&#39;species&#39;:[&#39;CO2&#39;, &#39;HCO3-&#39;, &#39;CO3-2&#39;]}&#34;
                        &#34;or else species_args needs to be a list of Python dictionaries.&#34;
                        &#34;Example: species_args=[{&#39;species&#39;:[&#39;CO2&#39;, &#39;HCO3-&#39;, &#39;CO3-2&#39;], &#39;state&#39;:[-4]},&#34;
                        &#34;{&#39;species&#39;:[&#39;graphite&#39;], state:[0], &#39;add&#39;:True}]&#34;)

    # There may be multiple arguments passed to species, especially in cases
    # where add=True. Loop through all the arguments to apply them.
    for species_args in species_args_list:
        if &#34;logact&#34; in species_args.keys():
            mod_species_logact = copy.copy(species_args[&#39;logact&#39;])
            del species_args[&#39;logact&#39;]
        else:
            mod_species_logact = []

        # Add messages parameter to species_args if not already present
        if &#34;messages&#34; not in species_args.keys():
            species_args[&#34;messages&#34;] = messages

        species_out = species(**species_args)

        if len(mod_species_logact)&gt;0:
            for i in range(0, len(mod_species_logact)) :
                species_out = species(species_args[&#34;species&#34;][i], mod_species_logact[i], messages=messages)

    sp = list(species_out[&#34;name&#34;])

    if isinstance(sp[0], (int, np.integer)):
        sp = [info(s, messages=messages)[&#34;name&#34;].values[0] for s in sp]

    dfs = []
    dmaps = []
    dmaps_names = []
    
    if len(anim_range) == 2:
        anim_res = 8
        anim_range = anim_range + [anim_res]
    elif len(anim_range) == 3:
        anim_res = anim_range[2]
        anim_range = [anim_range[0], anim_range[1]]
    
    zvals = __seq(anim_range[0], anim_range[1], length_out=anim_res)
        
    if &#34;messages&#34; not in affinity_args.keys():
        affinity_args[&#34;messages&#34;] = messages
    if &#34;messages&#34; not in diagram_args.keys():
        diagram_args[&#34;messages&#34;] = messages
    if &#34;plot_it&#34; not in diagram_args.keys():
        diagram_args[&#34;plot_it&#34;] = False
    diagram_args[&#34;interactive&#34;] = True
    if &#34;format_names&#34; not in diagram_args.keys():
        format_names=True
        format_x_names=True
        format_y_names=True
    
    for z in zvals:

        if anim_var in basis_out.index:
            basis_out = basis(anim_var, z, messages=messages)
        elif anim_var in list(species_out[&#34;name&#34;]):
            species_out = species(anim_var, -z, messages=messages)
        elif anim_var == &#34;pH&#34;:
            basis_out = basis(&#34;H+&#34;, -z, messages=messages)
        else:
            affinity_args[anim_var] = z
        
        aeout = affinity(**affinity_args)

        if equilibrate_args != None:
            equilibrate_args[&#34;aout&#34;] = aeout
            if &#34;messages&#34; not in equilibrate_args.keys():
                equilibrate_args[&#34;messages&#34;] = messages
            aeout = equilibrate(**equilibrate_args)

        # Get affinity arguments from the result dictionary
        aeout_args = aeout.get(&#34;args&#34;, {})
        xvar = list(aeout_args.keys())[0]
        xrange = list(aeout_args[xvar])

        res_default = 256 # default affinity resolution
        if len(xrange) == 3:
            xres = int(xrange[2])
        else:
            xres = res_default
        
        diagram_args[&#34;eout&#34;] = aeout

        # Use diagram_interactive since interactive=True is set
        # Remove &#39;interactive&#39; key as diagram_interactive doesn&#39;t need it
        diagram_args_copy = diagram_args.copy()
        diagram_args_copy.pop(&#39;interactive&#39;, None)
        df, fig = diagram_interactive(**diagram_args_copy)

        # Check if this is a predominance plot (2D) or affinity/activity plot (1D)
        if &#39;pred&#39; not in df.columns:
            # affinity/activity plot (1D) - melt to long format for animation
            is_predom_plot = False
            id_vars = [xvar]  # Keep the x-variable as identifier
            value_vars = [col for col in df.columns if col != xvar]  # All species columns
            df_melted = df.melt(id_vars=id_vars, value_vars=value_vars,
                               var_name=&#39;variable&#39;, value_name=&#39;value&#39;)
            df_melted[anim_var] = z
            dfs.append(df_melted)
        else:
            # predominance plot (2D) - keep original format with pred and prednames
            is_predom_plot = True
            df[anim_var] = z
            dfs.append(df)
            yvar = list(aeout_args.keys())[1]
            yrange = list(aeout_args[yvar])
            if len(yrange) == 3:
                yres = int(yrange[2])
            else:
                yres = res_default

            data = np.array(df.pred)
            shape = (xres, yres)
            dmap = data.reshape(shape)
            dmaps.append(dmap)

            data = np.array(df.prednames)
            shape = (xres, yres)
            dmap_names = data.reshape(shape)
            dmaps_names.append(dmap_names)
        
    xvals = __seq(xrange[0], xrange[1], length_out=xres)


    unit_dict = {&#34;P&#34;:&#34;bar&#34;, &#34;T&#34;:&#34;°C&#34;, &#34;pH&#34;:&#34;&#34;, &#34;Eh&#34;:&#34;volts&#34;, &#34;IS&#34;:&#34;mol/kg&#34;}
    
    if any([anim_var in basis_out.index, anim_var in list(species_out[&#34;name&#34;])]) and anim_var not in unit_dict.keys():
        unit_dict[anim_var] = &#34;logact &#34;+anim_var

    for i,s in enumerate(basis_sp):
        if basis_state[i] in [&#34;aq&#34;, &#34;liq&#34;, &#34;cr&#34;]:
            if format_names:
                unit_dict[s] = &#34;log &lt;i&gt;a&lt;/i&gt;&lt;sub&gt;{}&lt;/sub&gt;&#34;.format(chemlabel(s))
            else:
                unit_dict[s] = &#34;log &lt;i&gt;a&lt;/i&gt;&lt;sub&gt;{}&lt;/sub&gt;&#34;.format(s)
        else:
            if format_names:
                unit_dict[s] = &#34;log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;{}&lt;/sub&gt;&#34;.format(chemlabel(s))
            else:
                unit_dict[s] = &#34;log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;{}&lt;/sub&gt;&#34;.format(s)

    xlab = xvar+&#34;, &#34;+unit_dict[xvar]
    
    if xvar in basis_sp:
        xlab = unit_dict[xvar]
    if xvar == &#34;pH&#34;:
        xlab = &#34;pH&#34;
    
    if is_predom_plot:
        ylab = yvar+&#34;, &#34;+unit_dict[yvar]
        if yvar in basis_sp:
            ylab = unit_dict[yvar]
        if yvar == &#34;pH&#34;:
            yvar = &#34;pH&#34;

    
    if not is_predom_plot:

        if &#39;loga.equil&#39; not in aeout.keys():
            yvar = &#34;A/(2.303RT)&#34;
        else:
            yvar = &#34;log a&#34;
        if &#34;alpha&#34; in diagram_args.keys():
            if diagram_args[&#34;alpha&#34;]:
                yvar = &#34;alpha&#34;
        
        df_c = pd.concat(dfs)

        if &#34;fill&#34; in diagram_args.keys():
            if isinstance(diagram_args[&#34;fill&#34;], list):
                colormap = {key:col for key,col in zip(list(dict.fromkeys(df_c[&#34;variable&#34;])), diagram_args[&#34;fill&#34;])}
            else:
                colormap = diagram_args[&#34;fill&#34;]

            # with color mapping
            fig = px.line(df_c, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                          width=500,  height=400, animation_frame=anim_var,
                          color_discrete_map = colormap,
                          labels=dict(value=yvar, x=xvar),
                         )
        else:
            # without color mapping
            fig = px.line(df_c, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;, template=&#34;simple_white&#34;,
                          width=500,  height=400, animation_frame=anim_var,
                          labels=dict(value=yvar, x=xvar),
                         )
        
        if &#34;annotation&#34; in diagram_args.keys():
            if &#34;annotation_coords&#34; not in diagram_args.keys():
                diagram_args[&#34;annotation_coords&#34;] = [0, 0]
            fig.add_annotation(x=diagram_args[&#34;annotation_coords&#34;][0],
                               y=diagram_args[&#34;annotation_coords&#34;][1],
                               xref=&#34;paper&#34;,
                               yref=&#34;paper&#34;,
                               align=&#39;left&#39;,
                               text=diagram_args[&#34;annotation&#34;],
                               bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                               showarrow=False)
        
        if &#39;main&#39; in diagram_args.keys():
            fig.update_layout(title={&#39;text&#39;:diagram_args[&#34;main&#34;], &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

        if isinstance(xlab, str):
            fig.update_layout(xaxis_title=xlab)
        if isinstance(ylab, str):
            fig.update_layout(yaxis_title=ylab)
        
        if &#39;fill&#39; in diagram_args.keys():
            if isinstance(diagram_args[&#34;fill&#34;], list):
                for i,v in enumerate(diagram_args[&#34;fill&#34;]):
                    fig[&#39;data&#39;][i][&#39;line&#39;][&#39;color&#39;]=v
        
        fig.update_layout(legend_title=None)

        config = {&#39;displaylogo&#39;: False,
                  &#39;modeBarButtonsToRemove&#39;: [&#39;resetScale2d&#39;, &#39;toggleSpikelines&#39;],
                  &#39;toImageButtonOptions&#39;: {
                                             &#39;format&#39;: save_format, # one of png, svg, jpeg, webp
                                             &#39;filename&#39;: save_as,
                                             &#39;height&#39;: height,
                                             &#39;width&#39;: width,
                                             &#39;scale&#39;: save_scale,
                                          },
                 }

        fig.show(config=config)
        return
    
    else:
        yvals = __seq(yrange[0], yrange[1], length_out=yres)


    
    frames = []
    slider_steps = []
    annotations = []
    cst_data = []
    heatmaps = []
    
    # i is a frame in the animation
    for i in range(0, len(zvals)):

        annotations_i = []
        for s in sp:
            if s in set(dfs[i][&#34;prednames&#34;]):
                # if an annotation should appear, create one for this frame
                df_s = dfs[i].loc[dfs[i][&#34;prednames&#34;]==s,]
                namex = df_s[xvar].mean()
                namey = df_s[yvar].mean()
                a = go.layout.Annotation(
                    x=namex,
                    y=namey,
                    xref=&#34;x&#34;,
                    yref=&#34;y&#34;,
                    text=chemlabel(s),
                    bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                    showarrow=False,
                    )
            else:
                # if an annotation shouldn&#39;t appear, make an invisible annotation
                # (workaround for a plotly bug where annotations won&#39;t clear in an animation)
                namex = statistics.mean(xvals)
                namey = statistics.mean(yvals)
                a = go.layout.Annotation(
                    x=namex,
                    y=namey,
                    xref=&#34;x&#34;,
                    yref=&#34;y&#34;,
                    text=&#34;&#34;,
                    bgcolor=&#34;rgba(255, 255, 255, 0)&#34;,
                    showarrow=False,
                    )
            annotations_i.append(a)
            
        # allows adding a custom annotation; append to frame
        if &#34;annotation&#34; in diagram_args.keys():
            if &#34;annotation_coords&#34; not in diagram_args.keys():
                diagram_args[&#34;annotation_coords&#34;] = [0, 0]
            custom_annotation = go.layout.Annotation(
                    x=diagram_args[&#34;annotation_coords&#34;][0],
                    y=diagram_args[&#34;annotation_coords&#34;][1],
                    xref=&#34;paper&#34;,
                    yref=&#34;paper&#34;,
                    align=&#39;left&#39;,
                    text=diagram_args[&#34;annotation&#34;],
                    bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                    showarrow=False,
                    )
            annotations_i.append(custom_annotation)
    
        annotations.append(annotations_i)

        if &#39;ylab&#39; in diagram_args.keys():
            ylab = diagram_args[&#34;ylab&#34;]
            hover_ylab = ylab+&#39;: %{y} &#39;
        else:
            ylab = chemlabel(ylab)
            hover_ylab = yvar+&#39;: %{y} &#39;+unit_dict[yvar]

        if &#39;xlab&#39; in diagram_args.keys():
            xlab = diagram_args[&#34;xlab&#34;]
            hover_xlab = xlab+&#39;: %{x} &#39;
        else:
            xlab = chemlabel(xlab)
            hover_xlab = xvar+&#39;: %{x} &#39;+unit_dict[xvar]
        
        heatmaps_i = go.Heatmap(z=dmaps[i], x=xvals, y=yvals, zmin=0, zmax=len(sp)-1,
                                customdata=dmaps_names[i],
                                hovertemplate=hover_xlab+&#39;&lt;br&gt;&#39;+hover_ylab+&#39;&lt;br&gt;Region: %{customdata}&lt;extra&gt;&lt;/extra&gt;&#39;)

        heatmaps.append(heatmaps_i)

        frame = go.Frame(data=[heatmaps_i],
                         name=str(i),
                         layout=go.Layout(annotations=annotations_i))

        frames.append(frame)

        slider_step = dict(
            method=&#39;animate&#39;,
            label=zvals[i],
            value=i,
            args=[
                [i],
                dict(
                    frame=dict(duration=300, redraw=True),
                    mode=&#39;immediate&#39;,
                    transition=dict(duration=0)
                )
            ]
        )

        slider_steps.append(slider_step)

    fig = go.Figure(
        data = heatmaps[0],
        layout=go.Layout(
    #         title=&#34;Frame 0&#34;,
            title_x=0.5,
            width=500, height=500,
            annotations=annotations[0],
            sliders=[dict(
                active=0,
                yanchor=&#39;top&#39;,
                xanchor=&#39;left&#39;,
                currentvalue=dict(
                    font=dict(size=12),
                    prefix=&#39;{}: &#39;.format(anim_var),
                    suffix=&#39; &#39;+unit_dict[anim_var],
                    visible=True,
                    xanchor=&#39;right&#39;
                ),
                transition=dict(duration=0, easing=&#39;cubic-in-out&#39;),
                pad=dict(b=10, t=50),
                len=0.9,
                x=0.1,
                y=0,
                steps=slider_steps
            )],
            updatemenus=[dict(
                type=&#34;buttons&#34;,
                buttons=[dict(label=&#34;Play&#34;,
                              method=&#34;animate&#34;,
                              args=[None, {&#34;fromcurrent&#34;:True}]),
                        dict(label=&#34;Pause&#34;,
                             method=&#34;animate&#34;,
                             args=[[None],
                                   {&#34;frame&#34;: {&#34;duration&#34;: 0, &#34;redraw&#34;: True},
                                    &#34;mode&#34;: &#34;immediate&#34;,
                                    &#34;transition&#34;: {&#34;duration&#34;: 0}}],
                             )],
                direction=&#34;left&#34;,
                pad={&#34;r&#34;: 10, &#34;t&#34;: 87},
                showactive=False,
                x=0.1,
                xanchor=&#34;right&#34;,
                y=0,
                yanchor=&#34;top&#34;,
            )]
        ),
        frames=frames

    )


    if &#39;fill&#39; in diagram_args.keys():
        if isinstance(diagram_args[&#34;fill&#34;], list):
            colorscale_temp = []
            for i,v in enumerate(diagram_args[&#34;fill&#34;]):
                colorscale_temp.append([i, v])
            colorscale = colorscale_temp
        elif isinstance(diagram_args[&#34;fill&#34;], str):
            colorscale = diagram_args[&#34;fill&#34;]
    else:
        colorscale = &#34;viridis&#34;
    
    fig.update_traces(dict(showscale=False,
                           colorscale=colorscale),
                      selector={&#39;type&#39;:&#39;heatmap&#39;})
    
    fig.update_layout(
        xaxis_title=xlab,
        yaxis_title=ylab,
        xaxis={&#34;range&#34;:[list(dfs[0][xvar])[0], list(dfs[0][xvar])[-1]]},
        yaxis={&#34;range&#34;:[list(dfs[0][yvar])[0], list(dfs[0][yvar])[-1]]},
        margin={&#34;t&#34;: 60, &#34;r&#34;:60},
    )

    if &#39;main&#39; in diagram_args.keys():
        fig.update_layout(title={&#39;text&#39;:diagram_args[&#39;main&#39;], &#39;x&#39;:0.5, &#39;xanchor&#39;:&#39;center&#39;})

    config = {&#39;displaylogo&#39;: False,
              &#39;modeBarButtonsToRemove&#39;: [&#39;zoom2d&#39;, &#39;pan2d&#39;, &#39;zoomIn2d&#39;, &#39;zoomOut2d&#39;,
                                         &#39;autoScale2d&#39;, &#39;toggleSpikelines&#39;,
                                         &#39;hoverClosestCartesian&#39;, &#39;hoverCompareCartesian&#39;],
              &#39;toImageButtonOptions&#39;: {
                                       &#39;format&#39;: save_format, # one of png, svg, jpeg, webp
                                       &#39;filename&#39;: save_as,
                                       &#39;height&#39;: height,
                                       &#39;width&#39;: width,
                                       &#39;scale&#39;: save_scale,
                                        },
             }
    

    fig.show(config=config)</code></pre>
</details>
<div class="desc"><p>Produce an animated interactive affinity, activity, or predominance diagram.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>basis_args</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of options for defining basis species (see <code><a title="pychnosz.basis" href="#pychnosz.basis">basis()</a></code>) in the
animated diagram.
Example: basis_args={'species':['CO2', 'O2', 'H2O', 'H+']}</dd>
<dt><strong><code>species_args</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of options for defining species (see <code><a title="pychnosz.species" href="#pychnosz.species">species()</a></code>) in the
animated diagram, or a list of dicts.
Example 1: species_args={'species':['CO2', 'HCO3-', 'CO3-2']}
Example 2: species_args=[
{'species':['CO2', 'HCO3-', 'CO3-2'], 'state':[-4]},
{'species':['graphite'], state:[0], 'add':True}]</dd>
<dt><strong><code>affinity_args</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of options for defining the affinity calculation (see
<code><a title="pychnosz.affinity" href="#pychnosz.affinity">affinity()</a></code>).
Example: affinity_args={"pH":[2, 12, 100]}
Example: affinity_args={"pH":[2, 12, 100], "P":[2000, 4000, 100]}</dd>
<dt><strong><code>equilibrate_args</code></strong> :&ensp;<code>dict</code> or <code>None</code>, default <code>None</code></dt>
<dd>Dictionary of options for defining equilibration calculation
(see <code><a title="pychnosz.equilibrate" href="#pychnosz.equilibrate">equilibrate()</a></code>). If None, plots output from <code><a title="pychnosz.affinity" href="#pychnosz.affinity">affinity()</a></code>.
Example: equilibrate_args={"balance":1}</dd>
<dt><strong><code>diagram_args</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of options for diagramming (see <code><a title="pychnosz.diagram" href="#pychnosz.diagram">diagram()</a></code>). Diagram option
<code>interactive</code> is set to True.
Example: diagram_args={"alpha":True}</dd>
<dt><strong><code>anim_var</code></strong> :&ensp;<code>str</code>, default <code>"T"</code></dt>
<dd>Variable that changes with each frame of animation.</dd>
<dt><strong><code>anim_range</code></strong> :&ensp;<code>list</code> of <code>numeric</code>, default <code>[0, 350, 8]</code></dt>
<dd>The first two numbers in the list are the starting and ending
values for <code>anim_var</code>. The third number in the list is the desired
number of animation frames.</dd>
<dt><strong><code>xlab</code></strong>, <strong><code>ylab</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom names for the X and Y axes.</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display messages from CHNOSZ?</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An interactive animated plot.</p></div>
</dd>
<dt id="pychnosz.balance_reaction"><code class="name flex">
<span>def <span class="ident">balance_reaction</span></span>(<span>species: str | List[str] | int | List[int],<br>coeff: int | float | List[int | float],<br>state: str | List[str] | None = None,<br>basis: pandas.core.frame.DataFrame | None = None,<br>messages: bool = False) ‑> Tuple[List, List] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def balance_reaction(species: Union[str, List[str], int, List[int]],
                    coeff: Union[int, float, List[Union[int, float]]],
                    state: Optional[Union[str, List[str]]] = None,
                    basis: Optional[pd.DataFrame] = None,
                    messages: bool = False) -&gt; Optional[Tuple[List, List]]:
    &#34;&#34;&#34;
    Balance a chemical reaction using basis species.

    This function checks if a reaction is balanced and, if not, attempts to
    balance it by adding basis species. Unlike subcrt(), this function only
    performs the balancing calculation without computing thermodynamic properties,
    making it much more efficient for reaction generation.

    Parameters
    ----------
    species : str, int, list of str, or list of int
        Species names or indices in the reaction
    coeff : int, float, or list
        Stoichiometric coefficients for the species
    state : str, list of str, or None
        Physical states for species (optional)
    basis : pd.DataFrame, optional
        Basis species definition to use. If None, uses global basis from thermo()
    messages : bool
        Whether to print informational messages

    Returns
    -------
    tuple or None
        If reaction is balanced or can be balanced:
            (balanced_species, balanced_coeffs) where both are lists
        If reaction cannot be balanced:
            None

    Examples
    --------
    &gt;&gt;&gt; import chnosz
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; pychnosz.basis([&#39;H2O&#39;, &#39;H+&#39;, &#39;Fe+2&#39;])
    &gt;&gt;&gt; # Balance reaction for Fe+3
    &gt;&gt;&gt; species, coeffs = balance_reaction(&#39;Fe+3&#39;, [-1])
    &gt;&gt;&gt; print(f&#34;Species: {species}&#34;)
    &gt;&gt;&gt; print(f&#34;Coefficients: {coeffs}&#34;)
    &#34;&#34;&#34;

    # Convert inputs to lists
    if not isinstance(species, list):
        species = [species]
    if not isinstance(coeff, list):
        coeff = [coeff]
    if state is not None and not isinstance(state, list):
        state = [state]

    # Validate lengths
    if len(species) != len(coeff):
        raise ValueError(&#34;Length of species and coeff must match&#34;)

    # Get basis definition
    thermo_sys = thermo()
    if basis is None:
        if hasattr(thermo_sys, &#39;basis&#39;) and thermo_sys.basis is not None:
            basis = thermo_sys.basis
        else:
            raise RuntimeError(&#34;Basis species not defined. Call pychnosz.basis() first.&#34;)

    # Look up species indices
    ispecies = []
    for i, sp in enumerate(species):
        if isinstance(sp, (int, np.integer)):
            ispecies.append(int(sp))
        else:
            sp_state = state[i] if state and i &lt; len(state) else None
            sp_idx = info(sp, sp_state, messages=messages)
            if sp_idx is None or (isinstance(sp_idx, float) and np.isnan(sp_idx)):
                raise ValueError(f&#34;Species not found: {sp}&#34;)
            ispecies.append(sp_idx)

    # Calculate mass balance
    try:
        mass_balance = makeup(ispecies, coeff, sum_formulas=True)

        # Check if balanced
        tolerance = 1e-6
        unbalanced_elements = {elem: val for elem, val in mass_balance.items()
                             if abs(val) &gt; tolerance}

        if not unbalanced_elements:
            # Already balanced
            if messages:
                print(&#34;Reaction is already balanced&#34;)
            return (species, coeff)

        # Reaction is unbalanced - try to balance using basis species
        missing_composition = {elem: -val for elem, val in unbalanced_elements.items()}

        if messages:
            print(&#34;Reaction is not balanced; missing composition:&#34;)
            elem_names = list(missing_composition.keys())
            elem_values = list(missing_composition.values())
            print(&#34; &#34;.join(elem_names))
            print(&#34; &#34;.join([f&#34;{val:.4f}&#34; for val in elem_values]))

        # Get basis element columns
        basis_elements = [col for col in basis.columns
                        if col not in [&#39;ispecies&#39;, &#39;logact&#39;, &#39;state&#39;]]

        # Check if all missing elements are in basis
        missing_elements = set(missing_composition.keys())
        if not missing_elements.issubset(set(basis_elements)):
            if messages:
                print(f&#34;Cannot balance: elements {missing_elements - set(basis_elements)} not in basis&#34;)
            return None

        # Calculate coefficients for missing composition from basis species
        missing_matrix = np.zeros((1, len(basis_elements)))
        for i, elem in enumerate(basis_elements):
            missing_matrix[0, i] = missing_composition.get(elem, 0)

        # Get basis matrix
        basis_matrix = basis[basis_elements].values.T  # Transpose: (elements × basis_species)

        try:
            # Try to find simple integer solutions first
            basis_coeffs = _find_simple_integer_solution(
                basis_matrix.T,
                missing_matrix.flatten(),
                basis[&#39;ispecies&#39;].tolist(),
                missing_composition
            )

            if basis_coeffs is None:
                # Fall back to linear algebra solution
                basis_coeffs = np.linalg.solve(basis_matrix, missing_matrix.T).flatten()

                # Apply zapsmall equivalent (digits=7)
                basis_coeffs = np.around(basis_coeffs, decimals=7)

                # Clean up very small numbers
                basis_coeffs[np.abs(basis_coeffs) &lt; 1e-7] = 0

            # Get non-zero coefficients and corresponding basis species
            nonzero_indices = np.abs(basis_coeffs) &gt; 1e-6
            if not np.any(nonzero_indices):
                if messages:
                    print(&#34;No basis species needed to balance (coefficients are zero)&#34;)
                return (species, coeff)

            # Get basis species info
            basis_indices = basis[&#39;ispecies&#39;].values[nonzero_indices]
            basis_coeffs_nz = basis_coeffs[nonzero_indices]

            # Create new species list and coefficients
            new_species = list(species) + [int(idx) for idx in basis_indices]
            new_coeff = list(coeff) + list(basis_coeffs_nz)

            if messages:
                print(&#34;Balanced reaction by adding basis species:&#34;)
                for sp_idx, cf in zip(basis_indices, basis_coeffs_nz):
                    sp_name = thermo_sys.obigt.loc[int(sp_idx)][&#39;name&#39;]
                    print(f&#34;  {cf:.4f} {sp_name}&#34;)

            # CRITICAL: Consolidate duplicate species by summing coefficients
            # This prevents infinite recursion and matches subcrt&#39;s behavior
            consolidated_species = []
            consolidated_coeffs = []

            # Convert all species to indices for consolidation
            species_indices = []
            for sp in new_species:
                if isinstance(sp, (int, np.integer)):
                    species_indices.append(int(sp))
                else:
                    sp_idx = info(sp, None, messages=False)
                    if sp_idx is None or (isinstance(sp_idx, float) and np.isnan(sp_idx)):
                        # Keep as string if not found
                        species_indices.append(sp)
                    else:
                        species_indices.append(sp_idx)

            # Group by species index and sum coefficients
            species_coeff_map = {}
            for sp_idx, coeff in zip(species_indices, new_coeff):
                if sp_idx in species_coeff_map:
                    species_coeff_map[sp_idx] += coeff
                else:
                    species_coeff_map[sp_idx] = coeff

            # Remove species with zero coefficient (cancelled out)
            for sp_idx, coeff in species_coeff_map.items():
                if abs(coeff) &gt; tolerance:
                    consolidated_species.append(sp_idx)
                    consolidated_coeffs.append(coeff)

            # Now check if consolidated reaction is balanced
            # If not, recursively balance again
            try:
                final_mass_balance = makeup(consolidated_species, consolidated_coeffs, sum_formulas=True)
                final_unbalanced = {elem: val for elem, val in final_mass_balance.items()
                                   if abs(val) &gt; tolerance}

                if final_unbalanced:
                    # Still unbalanced after consolidation - recursively balance
                    if messages:
                        print(f&#34;After consolidation, reaction still unbalanced: {final_unbalanced}&#34;)
                        print(f&#34;Attempting recursive balance...&#34;)
                    return balance_reaction(consolidated_species, consolidated_coeffs, state=None,
                                           basis=basis, messages=messages)
                else:
                    # Balanced! Return consolidated result
                    if messages:
                        print(f&#34;Reaction balanced after consolidation&#34;)
                    return (consolidated_species, consolidated_coeffs)

            except Exception as e:
                # If check fails, return consolidated result anyway
                if messages:
                    print(f&#34;Could not verify final balance: {e}&#34;)
                return (consolidated_species, consolidated_coeffs)

        except np.linalg.LinAlgError:
            if messages:
                print(&#34;Cannot balance: singular basis matrix&#34;)
            return None

    except Exception as e:
        if messages:
            print(f&#34;Error checking reaction balance: {e}&#34;)
            import traceback
            traceback.print_exc()
        return None</code></pre>
</details>
<div class="desc"><p>Balance a chemical reaction using basis species.</p>
<p>This function checks if a reaction is balanced and, if not, attempts to
balance it by adding basis species. Unlike subcrt(), this function only
performs the balancing calculation without computing thermodynamic properties,
making it much more efficient for reaction generation.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int, list</code> of <code>str,</code> or <code>list</code> of <code>int</code></dt>
<dd>Species names or indices in the reaction</dd>
<dt><strong><code>coeff</code></strong> :&ensp;<code>int, float,</code> or <code>list</code></dt>
<dd>Stoichiometric coefficients for the species</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>None</code></dt>
<dd>Physical states for species (optional)</dd>
<dt><strong><code>basis</code></strong> :&ensp;<code>pd.DataFrame</code>, optional</dt>
<dd>Basis species definition to use. If None, uses global basis from thermo()</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> or <code>None</code></dt>
<dd>If reaction is balanced or can be balanced:
(balanced_species, balanced_coeffs) where both are lists
If reaction cannot be balanced:
None</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import chnosz
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; pychnosz.basis(['H2O', 'H+', 'Fe+2'])
&gt;&gt;&gt; # Balance reaction for Fe+3
&gt;&gt;&gt; species, coeffs = balance_reaction('Fe+3', [-1])
&gt;&gt;&gt; print(f&quot;Species: {species}&quot;)
&gt;&gt;&gt; print(f&quot;Coefficients: {coeffs}&quot;)
</code></pre></div>
</dd>
<dt id="pychnosz.basis"><code class="name flex">
<span>def <span class="ident">basis</span></span>(<span>species: str | int | List[str | int] | None = None,<br>state: str | List[str] | None = None,<br>logact: float | List[float] | None = None,<br>delete: bool = False,<br>add: bool = False,<br>messages: bool = True,<br>global_state: bool = True) ‑> pandas.core.frame.DataFrame | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def basis(species: Optional[Union[str, int, List[Union[str, int]]]] = None,
          state: Optional[Union[str, List[str]]] = None,
          logact: Optional[Union[float, List[float]]] = None,
          delete: bool = False,
          add: bool = False,
          messages: bool = True,
          global_state: bool = True) -&gt; Optional[pd.DataFrame]:
    &#34;&#34;&#34;
    Set up the basis species of a thermodynamic system.

    Parameters
    ----------
    species : str, int, list, or None
        Species name(s), formula(s), or index(es), or preset keyword.
        If None, returns current basis definition.
    state : str, list of str, or None
        Physical state(s) for the species
    logact : float, list of float, or None
        Log activities for the basis species
    delete : bool, default False
        If True, delete the basis definition
    add : bool, default False
        If True, add to existing basis instead of replacing
    messages : bool, default True
        If True, print informational messages about species lookup
        If False, suppress all output (equivalent to R&#39;s suppressMessages())
    global_state : bool, default True
        If True, store basis definition in global thermo().basis (default behavior)
        If False, return basis definition without storing globally (local state)

    Returns
    -------
    pd.DataFrame or None
        Basis species definition DataFrame, or None if deleted

    Examples
    --------
    &gt;&gt;&gt; # Set up a simple basis
    &gt;&gt;&gt; basis([&#34;H2O&#34;, &#34;CO2&#34;, &#34;NH3&#34;], logact=[0, -3, -4])

    &gt;&gt;&gt; # Use a preset basis
    &gt;&gt;&gt; basis(&#34;CHNOS&#34;)

    &gt;&gt;&gt; # Add species to existing basis
    &gt;&gt;&gt; basis(&#34;Fe2O3&#34;, add=True)

    &gt;&gt;&gt; # Delete basis
    &gt;&gt;&gt; basis(delete=True)

    &gt;&gt;&gt; # Suppress messages
    &gt;&gt;&gt; basis(&#34;CHNOS&#34;, messages=False)
    &#34;&#34;&#34;
    thermo_obj = thermo()
    
    # Get current basis
    old_basis = thermo_obj.basis
    
    # Delete basis if requested
    if delete or species == &#34;&#34;:
        thermo_obj.basis = None
        thermo_obj.species = None
        return old_basis
    
    # Return current basis if no species specified
    if species is None:
        return old_basis
    
    # Handle empty species list
    if isinstance(species, list) and len(species) == 0:
        raise ValueError(&#34;species argument is empty&#34;)
    
    # Check for preset keywords
    if isinstance(species, str) and species in _get_preset_basis_keywords():
        return preset_basis(species, messages=messages, global_state=global_state)

    # Ensure species names are unique
    if isinstance(species, list):
        if len(set([str(s) for s in species])) != len(species):
            raise ValueError(&#34;species names are not unique&#34;)

    # Process arguments
    species, state, logact = _process_basis_arguments(species, state, logact)

    # Handle special transformations
    species, logact = _handle_special_species(species, logact)

    # Check if we&#39;re modifying existing basis species
    if (old_basis is not None and not add and
        _all_species_in_basis(species, old_basis)):
        if state is not None or logact is not None:
            return mod_basis(species, state, logact, messages=messages)

    # Create new basis definition or add to existing
    if logact is None:
        logact = [0.0] * len(species)

    # Get species indices
    ispecies = _get_species_indices(species, state, messages=messages)
    
    # Handle adding to existing basis
    if add and old_basis is not None:
        # Check for duplicates
        existing_indices = old_basis[&#39;ispecies&#39;].tolist()
        for i, idx in enumerate(ispecies):
            if idx in existing_indices:
                sp_name = species[i] if isinstance(species[i], str) else str(species[i])
                raise BasisError(f&#34;Species {sp_name} is already in the basis definition&#34;)
        
        # Append to existing basis
        ispecies = existing_indices + ispecies
        logact = old_basis[&#39;logact&#39;].tolist() + logact
    
    # Create new basis
    new_basis = put_basis(ispecies, logact, global_state=global_state)

    # Only update global species list if using global state
    if global_state:
        # Handle species list when adding
        if add and thermo_obj.species is not None:
            _update_species_for_added_basis(old_basis, new_basis)
        else:
            # Clear species since basis changed
            from .species import species as species_func
            species_func(delete=True)

    return new_basis</code></pre>
</details>
<div class="desc"><p>Set up the basis species of a thermodynamic system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int, list,</code> or <code>None</code></dt>
<dd>Species name(s), formula(s), or index(es), or preset keyword.
If None, returns current basis definition.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>None</code></dt>
<dd>Physical state(s) for the species</dd>
<dt><strong><code>logact</code></strong> :&ensp;<code>float, list</code> of <code>float,</code> or <code>None</code></dt>
<dd>Log activities for the basis species</dd>
<dt><strong><code>delete</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, delete the basis definition</dd>
<dt><strong><code>add</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, add to existing basis instead of replacing</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, print informational messages about species lookup
If False, suppress all output (equivalent to R's suppressMessages())</dd>
<dt><strong><code>global_state</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, store basis definition in global thermo().basis (default behavior)
If False, return basis definition without storing globally (local state)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code> or <code>None</code></dt>
<dd>Basis species definition DataFrame, or None if deleted</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Set up a simple basis
&gt;&gt;&gt; basis([&quot;H2O&quot;, &quot;CO2&quot;, &quot;NH3&quot;], logact=[0, -3, -4])
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Use a preset basis
&gt;&gt;&gt; basis(&quot;CHNOS&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Add species to existing basis
&gt;&gt;&gt; basis(&quot;Fe2O3&quot;, add=True)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Delete basis
&gt;&gt;&gt; basis(delete=True)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Suppress messages
&gt;&gt;&gt; basis(&quot;CHNOS&quot;, messages=False)
</code></pre></div>
</dd>
<dt id="pychnosz.calc_G_TP"><code class="name flex">
<span>def <span class="ident">calc_G_TP</span></span>(<span>OBIGT, Tc, P, water_model)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_G_TP(OBIGT, Tc, P, water_model):
    
    aq_out, H2O_Pt = hkf(property=[&#34;G&#34;], parameters=OBIGT,
                         T=273.15+Tc, P=P, contrib=[&#34;n&#34;, &#34;s&#34;, &#34;o&#34;],
                         H2O_props=[&#34;rho&#34;], water_model=water_model)
    
    cgl_out = cgl(property=[&#34;G&#34;], parameters=OBIGT, T=273.15+Tc, P=P)
    
    aq_col = pd.DataFrame.from_dict(aq_out, orient=&#34;index&#34;)
    cgl_col = pd.DataFrame.from_dict(cgl_out, orient=&#34;index&#34;)

    G_TP_df = pd.concat([aq_col, cgl_col], axis=1)
    G_TP_df.columns = [&#39;aq&#39;,&#39;cgl&#39;]
    
    OBIGT[&#34;G_TP&#34;] = G_TP_df[&#39;aq&#39;].combine_first(G_TP_df[&#39;cgl&#39;])
    
    rows_added = 0

    # add a row for water
    if &#34;H2O&#34; not in list(OBIGT[&#34;name&#34;]):
        # Set the water model (without printing messages)
        water(water_model, messages=False)
        # water() returns a scalar when called with single property and scalar T, P
        # The result is in J/mol, need to convert to cal/mol by dividing by 4.184
        G_water = water(&#34;G&#34;, T=Tc+273.15, P=P, messages=False)
        # Handle both scalar and DataFrame returns
        if isinstance(G_water, pd.DataFrame):
            G_water_cal = G_water.iloc[0][&#34;G&#34;] / 4.184
        else:
            G_water_cal = float(G_water) / 4.184
        OBIGT = pd.concat([OBIGT, pd.DataFrame({&#34;name&#34;: &#34;H2O&#34;, &#34;tag&#34;: &#34;nan&#34;, &#34;G_TP&#34;: G_water_cal}, index=[OBIGT.shape[0]])], ignore_index=True)
        rows_added += 1

    # add a row for protons
    if &#34;H+&#34; not in list(OBIGT[&#34;name&#34;]):
        OBIGT = pd.concat([OBIGT, pd.DataFrame({&#34;name&#34;: &#34;H+&#34;, &#34;tag&#34;: &#34;nan&#34;, &#34;G_TP&#34;: 0}, index=[OBIGT.shape[0]])], ignore_index=True)
        rows_added += 1

    return OBIGT, rows_added</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.calc_logK"><code class="name flex">
<span>def <span class="ident">calc_logK</span></span>(<span>OBIGT_df, Tc, P, TP_i, water_model)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_logK(OBIGT_df, Tc, P, TP_i, water_model):
    
    OBIGT_TP, rows_added = calc_G_TP(OBIGT_df, Tc, P, water_model)
    
    dissrxn2logK_out = []
    for i in OBIGT_TP.index:
        dissrxn2logK_out.append(dissrxn2logK(OBIGT_TP, i, Tc))
    assert len(dissrxn2logK_out) == OBIGT_TP.shape[0]
    
    OBIGT_TP[&#39;dissrxn_logK_&#39;+str(TP_i)] = dissrxn2logK_out
    
    # remove any rows added by calc_G_TP
    OBIGT_TP.drop(OBIGT_TP.tail(rows_added).index, inplace = True)
    
    return OBIGT_TP</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.cgl"><code class="name flex">
<span>def <span class="ident">cgl</span></span>(<span>property=None, parameters=None, T=298.15, P=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cgl(property = None, parameters = None, T = 298.15, P = 1):
    # calculate properties of crystalline, liquid (except H2O) and gas species
    Tr = 298.15
    Pr = 1

    # Convert T and P to arrays for vectorized operations
    T = np.atleast_1d(T)
    P = np.atleast_1d(P)

    # make T and P equal length
    if P.size &lt; T.size:
        P = np.full_like(T, P[0] if P.size == 1 else P)
    if T.size &lt; P.size:
        T = np.full_like(P, T[0] if T.size == 1 else T)

    n_conditions = T.size
    # initialize output dict
    out_dict = dict()
    # loop over each species
    
    # Iterate over each row by position to handle duplicate indices properly
    for i in range(len(parameters)):
        # Get the index label for this row
        k = parameters.index[i]
        # Get the row data by position (iloc) to avoid duplicate index issues
        PAR = parameters.iloc[i]

        if PAR[&#34;state&#34;] == &#34;aq&#34;:
            # For aqueous species processed by CGL, return NaN
            # (they should be processed by HKF instead)
            out_dict[k] = {p:float(&#39;NaN&#39;) for p in property}
        else:

            # OBIGT database stores G, H, S in calories (E_units = &#34;cal&#34;)
            # CGL calculations use calories (integrals intCpdT, intCpdlnT, intVdP are in cal)
            # Results are output in calories and converted to J in subcrt.py at line 959

            # Parameter scaling - SUPCRT92 data is already in correct units
            # PAR[&#34;a2.b&#34;] = copy.copy(PAR[&#34;a2.b&#34;]*10**-3)
            # PAR[&#34;a3.c&#34;] = copy.copy(PAR[&#34;a3.c&#34;]*10**5) 
            # PAR[&#34;c1.e&#34;] = copy.copy(PAR[&#34;c1.e&#34;]*10**-5)

            # Check if this is a Berman mineral (columns 9-21 are all NA in R indexing)
            # In Python/pandas, we check the relevant thermodynamic parameter columns
            # NOTE: A mineral is only Berman if it LACKS standard thermodynamic data (G,H,S)
            # If G,H,S are present, use regular CGL even if heat capacity coefficients are all zero
            berman_cols = [&#39;a1.a&#39;, &#39;a2.b&#39;, &#39;a3.c&#39;, &#39;a4.d&#39;, &#39;c1.e&#39;, &#39;c2.f&#39;, &#39;omega.lambda&#39;, &#39;z.T&#39;]
            has_standard_thermo = pd.notna(PAR.get(&#39;G&#39;, np.nan)) and pd.notna(PAR.get(&#39;H&#39;, np.nan)) and pd.notna(PAR.get(&#39;S&#39;, np.nan))
            all_coeffs_zero_or_na = all(pd.isna(PAR.get(col, np.nan)) or PAR.get(col, 0) == 0 for col in berman_cols)
            is_berman_mineral = all_coeffs_zero_or_na and not has_standard_thermo

            if is_berman_mineral:
                # Use Berman equations (parameters not in thermo()$OBIGT)
                from .berman import Berman
                try:
                    # Berman is already vectorized - pass T and P arrays directly
                    properties_df = Berman(PAR[&#34;name&#34;], T=T, P=P)
                    # Extract the requested properties as arrays
                    values = {}
                    for prop in property:
                        if prop in properties_df.columns:
                            # Get all values as an array
                            prop_values = properties_df[prop].values

                            # IMPORTANT: Berman function returns values in J/mol (Joules)
                            # but CGL returns values in cal/mol (calories)
                            # Convert Berman results from J/mol to cal/mol for consistency
                            # Energy properties that need conversion: G, H, S, Cp
                            # Volume (V) and other properties don&#39;t need conversion
                            energy_props = [&#39;G&#39;, &#39;H&#39;, &#39;S&#39;, &#39;Cp&#39;]
                            if prop in energy_props:
                                # Convert J/mol to cal/mol by dividing by 4.184
                                prop_values = prop_values / 4.184

                            values[prop] = prop_values
                        else:
                            values[prop] = np.full(n_conditions, float(&#39;NaN&#39;))
                except Exception as e:
                    # If Berman calculation fails, fall back to NaN arrays
                    values = {prop: np.full(n_conditions, float(&#39;NaN&#39;)) for prop in property}
            else:
                # Use regular CGL equations
                
                # in CHNOSZ, we have
                # 1 cm^3 bar --&gt; convert(1, &#34;calories&#34;) == 0.02390057 cal
                # but REAC92D.F in SUPCRT92 uses
                cm3bar_to_cal = 0.023901488 # cal
                # start with NA values
                values = dict()
                # a test for availability of heat capacity coefficients (a, b, c, d, e, f)
                # based on the column assignments in thermo()$OBIGT

                # Check for heat capacity coefficients, handling both NaN and non-numeric values
                # Heat capacity coefficients are at positions 14-19 (a1.a through c2.f)
                # Position 13 is V (volume), not a heat capacity coefficient
                has_hc_coeffs = False
                try:
                    hc_values = list(PAR.iloc[14:20])
                    has_hc_coeffs = any([pd.notna(p) and p != 0 for p in hc_values if pd.api.types.is_numeric_dtype(type(p))])

                    # DEBUG
                    if False and PAR[&#34;name&#34;] == &#34;rhomboclase&#34;:
                        print(f&#34;DEBUG for rhomboclase:&#34;)
                        print(f&#34;  hc_values (iloc[14:20]): {hc_values}&#34;)
                        print(f&#34;  has_hc_coeffs: {has_hc_coeffs}&#34;)
                except Exception as e:
                    has_hc_coeffs = False

                if has_hc_coeffs:
                    # we have at least one of the heat capacity coefficients;
                    # zero out any NA&#39;s in the rest (leave lambda and T of transition (columns 20-21) alone)
                    for i in range(14, 20):
                        if pd.isna(PAR.iloc[i]) or not pd.api.types.is_numeric_dtype(type(PAR.iloc[i])):
                            PAR.iloc[i] = 0.0
                    # calculate the heat capacity and its integrals (vectorized)
                    Cp = PAR[&#34;a1.a&#34;] + PAR[&#34;a2.b&#34;]*T + PAR[&#34;a3.c&#34;]*T**-2 + PAR[&#34;a4.d&#34;]*T**-0.5 + PAR[&#34;c1.e&#34;]*T**2 + PAR[&#34;c2.f&#34;]*T**PAR[&#34;omega.lambda&#34;]
                    intCpdT = PAR[&#34;a1.a&#34;]*(T - Tr) + PAR[&#34;a2.b&#34;]*(T**2 - Tr**2)/2 + PAR[&#34;a3.c&#34;]*(1/T - 1/Tr)/-1 + PAR[&#34;a4.d&#34;]*(T**0.5 - Tr**0.5)/0.5 + PAR[&#34;c1.e&#34;]*(T**3-Tr**3)/3
                    intCpdlnT = PAR[&#34;a1.a&#34;]*np.log(T / Tr) + PAR[&#34;a2.b&#34;]*(T - Tr) + PAR[&#34;a3.c&#34;]*(T**-2 - Tr**-2)/-2 + PAR[&#34;a4.d&#34;]*(T**-0.5 - Tr**-0.5)/-0.5  + PAR[&#34;c1.e&#34;]*(T**2 - Tr**2)/2

                    # do we also have the lambda parameter (Cp term with adjustable exponent on T)?
                    if pd.notna(PAR[&#34;omega.lambda&#34;]) and PAR[&#34;omega.lambda&#34;] != 0:
                        # equations for lambda adapted from Helgeson et al., 1998 (doi:10.1016/S0016-7037(97)00219-6)
                        if PAR[&#34;omega.lambda&#34;] == -1:
                            intCpdT = intCpdT + PAR[&#34;c2.f&#34;]*np.log(T/Tr)
                        else:
                            intCpdT = intCpdT - PAR[&#34;c2.f&#34;]*( T**(PAR[&#34;omega.lambda&#34;] + 1) - Tr**(PAR[&#34;omega.lambda&#34;] + 1) ) / (PAR[&#34;omega.lambda&#34;] + 1)
                        intCpdlnT = intCpdlnT + PAR[&#34;c2.f&#34;]*(T**PAR[&#34;omega.lambda&#34;] - Tr**PAR[&#34;omega.lambda&#34;]) / PAR[&#34;omega.lambda&#34;]

                else:
                    # use constant heat capacity if the coefficients are not available (vectorized)
                    # If Cp is NA/NaN, use 0 (matching R CHNOSZ behavior)
                    Cp_value = PAR[&#34;Cp&#34;] if pd.notna(PAR[&#34;Cp&#34;]) else 0.0
                    Cp = np.full(n_conditions, Cp_value)
                    intCpdT = Cp_value*(T - Tr)
                    intCpdlnT = Cp_value*np.log(T / Tr)
                    # in case Cp is listed as NA, set the integrals to 0 at Tr
                    at_Tr = (T == Tr)
                    intCpdT = np.where(at_Tr, 0, intCpdT)
                    intCpdlnT = np.where(at_Tr, 0, intCpdlnT)


                # volume and its integrals (vectorized)
                if PAR[&#34;name&#34;] in [&#34;quartz&#34;, &#34;coesite&#34;]:
                    # volume calculations for quartz and coesite
                    qtz = quartz_coesite(PAR, T, P)
                    V = qtz[&#34;V&#34;]
                    intVdP = qtz[&#34;intVdP&#34;]
                    intdVdTdP = qtz[&#34;intdVdTdP&#34;]

                else:
                    # for other minerals, volume is constant (Helgeson et al., 1978)
                    V = np.full(n_conditions, PAR[&#34;V&#34;])
                    # if the volume is NA, set its integrals to zero
                    if pd.isna(PAR[&#34;V&#34;]):
                        intVdP = np.zeros(n_conditions)
                        intdVdTdP = np.zeros(n_conditions)
                    else:
                        intVdP = PAR[&#34;V&#34;]*(P - Pr) * cm3bar_to_cal
                        intdVdTdP = np.zeros(n_conditions)

                # get the values of each of the requested thermodynamic properties (vectorized)
                for i,prop in enumerate(property):
                    if prop == &#34;Cp&#34;: values[&#34;Cp&#34;] = Cp
                    if prop == &#34;V&#34;: values[&#34;V&#34;] = V
                    if prop == &#34;E&#34;: values[&#34;E&#34;] = np.full(n_conditions, float(&#39;NaN&#39;))
                    if prop == &#34;kT&#34;: values[&#34;kT&#34;] = np.full(n_conditions, float(&#39;NaN&#39;))
                    if prop == &#34;G&#34;:
                        # calculate S * (T - Tr), but set it to 0 at Tr (in case S is NA)
                        Sterm = PAR[&#34;S&#34;]*(T - Tr)
                        Sterm = np.where(T == Tr, 0, Sterm)

                        # DEBUG
                        if False and PAR[&#34;name&#34;] == &#34;iron&#34; and PAR.get(&#34;state&#34;) == &#34;cr4&#34;:
                            print(f&#34;DEBUG G calculation for {PAR[&#39;name&#39;]} {PAR.get(&#39;state&#39;, &#39;unknown&#39;)}:&#34;)
                            print(f&#34;  PAR[&#39;G&#39;] = {PAR[&#39;G&#39;]}&#34;)
                            print(f&#34;  PAR[&#39;S&#39;] = {PAR[&#39;S&#39;]}&#34;)
                            print(f&#34;  model = {PAR.get(&#39;model&#39;, &#39;unknown&#39;)}&#34;)
                            print(f&#34;  Sterm[0] = {Sterm[0] if hasattr(Sterm, &#39;__len__&#39;) else Sterm}&#34;)
                            print(f&#34;  intCpdT[0] = {intCpdT[0] if hasattr(intCpdT, &#39;__len__&#39;) else intCpdT}&#34;)
                            print(f&#34;  T[0]*intCpdlnT[0] = {(T[0]*intCpdlnT[0]) if hasattr(intCpdlnT, &#39;__len__&#39;) else T*intCpdlnT}&#34;)
                            print(f&#34;  intVdP[0] = {intVdP[0] if hasattr(intVdP, &#39;__len__&#39;) else intVdP}&#34;)
                            G_calc = PAR[&#39;G&#39;] - Sterm + intCpdT - T*intCpdlnT + intVdP
                            print(f&#34;  G[0] (before subcrt conversion) = {G_calc[0] if hasattr(G_calc, &#39;__len__&#39;) else G_calc}&#34;)

                        values[&#34;G&#34;] = PAR[&#34;G&#34;] - Sterm + intCpdT - T*intCpdlnT + intVdP
                    if prop == &#34;H&#34;:
                        values[&#34;H&#34;] = PAR[&#34;H&#34;] + intCpdT + intVdP - T*intdVdTdP
                    if prop == &#34;S&#34;: values[&#34;S&#34;] = PAR[&#34;S&#34;] + intCpdlnT - intdVdTdP

            out_dict[k] = values # species have to be numbered instead of named because of name repeats (e.g., cr polymorphs)

    return out_dict</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>value: float | numpy.ndarray | List[float],<br>units: str,<br>T: float | numpy.ndarray = 298.15,<br>P: float | numpy.ndarray = 1,<br>pH: float | numpy.ndarray = 7,<br>logaH2O: float | numpy.ndarray = 0,<br>messages: bool = True) ‑> float | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(value: Union[float, np.ndarray, List[float]],
            units: str,
            T: Union[float, np.ndarray] = 298.15,
            P: Union[float, np.ndarray] = 1,
            pH: Union[float, np.ndarray] = 7,
            logaH2O: Union[float, np.ndarray] = 0,
            messages: bool = True) -&gt; Union[float, np.ndarray]:
    &#34;&#34;&#34;
    Convert values to the specified units.

    This function converts thermodynamic values between different units commonly
    used in geochemistry.

    Parameters
    ----------
    value : float, ndarray, or list
        Value(s) to convert
    units : str
        Target units. Options include:
        - Temperature: &#39;C&#39;, &#39;K&#39;
        - Energy: &#39;J&#39;, &#39;cal&#39;
        - Pressure: &#39;bar&#39;, &#39;MPa&#39;
        - Thermodynamic: &#39;G&#39;, &#39;logK&#39;
        - Electrochemical: &#39;Eh&#39;, &#39;pe&#39;, &#39;E0&#39;, &#39;logfO2&#39;
        - Volume: &#39;cm3bar&#39;, &#39;joules&#39;
    T : float or ndarray, default 298.15
        Temperature in K (for Eh/pe/logK conversions)
    P : float or ndarray, default 1
        Pressure in bar (for E0/logfO2 conversions)
    pH : float or ndarray, default 7
        pH value (for E0/logfO2 conversions)
    logaH2O : float or ndarray, default 0
        Log activity of water (for E0/logfO2 conversions)
    messages : bool, default True
        Whether to print informational messages

    Returns
    -------
    float or ndarray
        Converted value(s)

    Examples
    --------
    &gt;&gt;&gt; convert(25, &#39;K&#39;)  # Convert 25°C to K
    298.15
    &gt;&gt;&gt; convert(1.0, &#39;pe&#39;, T=298.15)  # Convert 1V Eh to pe
    16.9
    &#34;&#34;&#34;

    if value is None:
        return None

    # Convert to numpy array for uniform handling
    value = np.asarray(value)
    T = np.asarray(T)
    P = np.asarray(P)
    pH = np.asarray(pH)
    logaH2O = np.asarray(logaH2O)

    units = units.lower()

    # Temperature conversions (C &lt;-&gt; K)
    if units in [&#39;c&#39;, &#39;k&#39;]:
        CK = 273.15
        if units == &#39;k&#39;:
            return value + CK
        if units == &#39;c&#39;:
            return value - CK

    # Energy conversions (J &lt;-&gt; cal)
    elif units in [&#39;j&#39;, &#39;cal&#39;]:
        Jcal = 4.184
        if units == &#39;j&#39;:
            return value * Jcal
        if units == &#39;cal&#39;:
            return value / Jcal

    # Gibbs energy &lt;-&gt; logK conversions
    elif units in [&#39;g&#39;, &#39;logk&#39;]:
        # Gas constant (J K^-1 mol^-1)
        R = 8.314463  # NIST value
        if units == &#39;logk&#39;:
            return value / (-np.log(10) * R * T)
        if units == &#39;g&#39;:
            return value * (-np.log(10) * R * T)

    # Volume conversions (cm3bar &lt;-&gt; joules)
    elif units in [&#39;cm3bar&#39;, &#39;joules&#39;]:
        if units == &#39;cm3bar&#39;:
            return value * 10
        if units == &#39;joules&#39;:
            return value / 10

    # Electrochemical potential conversions (Eh &lt;-&gt; pe)
    elif units in [&#39;eh&#39;, &#39;pe&#39;]:
        R = 0.00831470  # Gas constant in kJ K^-1 mol^-1
        F = 96.4935     # Faraday constant in kJ V^-1 mol^-1
        if units == &#39;pe&#39;:
            return value * F / (np.log(10) * R * T)
        if units == &#39;eh&#39;:
            return value * (np.log(10) * R * T) / F

    # Pressure conversions (bar &lt;-&gt; MPa)
    elif units in [&#39;bar&#39;, &#39;mpa&#39;]:
        barmpa = 10
        if units == &#39;mpa&#39;:
            return value / barmpa
        if units == &#39;bar&#39;:
            return value * barmpa

    # Eh &lt;-&gt; logfO2 conversions
    elif units in [&#39;e0&#39;, &#39;logfo2&#39;]:
        # Calculate equilibrium constant for: H2O = 1/2 O2 + 2 H+ + 2 e-
        # Handle P=&#34;Psat&#34; case (pass it directly to subcrt)
        # Check if P is a string (including numpy string types)
        P_is_psat = False
        if isinstance(P, (str, np.str_)):
            P_is_psat = str(P).lower() == &#39;psat&#39;
        elif isinstance(P, (list, tuple)):
            # P is a list/tuple - check if it&#39;s a single-element string
            if len(P) == 1 and isinstance(P[0], (str, np.str_)):
                P_is_psat = str(P[0]).lower() == &#39;psat&#39;
        elif isinstance(P, np.ndarray):
            # P is a numpy array
            if P.ndim == 0:
                # Scalar array - check if it&#39;s a string
                try:
                    if isinstance(P.item(), (str, np.str_)):
                        P_is_psat = str(P.item()).lower() == &#39;psat&#39;
                except (ValueError, AttributeError):
                    pass
            elif P.size == 1:
                # Single-element array - check if it&#39;s a string
                try:
                    if isinstance(P.flat[0], (str, np.str_)):
                        P_is_psat = str(P.flat[0]).lower() == &#39;psat&#39;
                except (ValueError, AttributeError, IndexError):
                    pass

        if P_is_psat:
            P_arg = &#39;Psat&#39;
            T_arg = np.atleast_1d(T)
            if len(T_arg) == 1:
                T_arg = float(T_arg[0])
            else:
                T_arg = T_arg.tolist()
        else:
            # Convert T and P to proper format for subcrt
            T_vals = np.atleast_1d(T)
            P_vals = np.atleast_1d(P)

            # subcrt needs lists for multiple T/P values
            if len(T_vals) &gt; 1 or len(P_vals) &gt; 1:
                T_arg = T_vals.tolist() if len(T_vals) &gt; 1 else float(T_vals[0])
                P_arg = P_vals.tolist() if len(P_vals) &gt; 1 else float(P_vals[0])
            else:
                T_arg = float(T_vals[0])
                P_arg = float(P_vals[0])

        supcrt_out = subcrt([&#39;H2O&#39;, &#39;oxygen&#39;, &#39;H+&#39;, &#39;e-&#39;],
                           [-1, 0.5, 2, 2],
                           T=T_arg, P=P_arg, convert=False, messages=messages, show=False)

        # Extract logK values
        if hasattr(supcrt_out.out, &#39;logK&#39;):
            logK = supcrt_out.out.logK
        else:
            logK = supcrt_out.out[&#39;logK&#39;]

        # Convert to numpy array
        logK = np.asarray(logK)

        if units == &#39;logfo2&#39;:
            # Convert Eh to logfO2
            pe_value = convert(value, &#39;pe&#39;, T=T, messages=messages)
            return 2 * (logK + logaH2O + 2*pH + 2*pe_value)
        if units == &#39;e0&#39;:
            # Convert logfO2 to Eh
            pe_value = (-logK - 2*pH + value/2 - logaH2O) / 2
            return convert(pe_value, &#39;Eh&#39;, T=T, messages=messages)

    else:
        warnings.warn(f&#34;convert: no conversion to {units} found&#34;)
        return value</code></pre>
</details>
<div class="desc"><p>Convert values to the specified units.</p>
<p>This function converts thermodynamic values between different units commonly
used in geochemistry.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, ndarray,</code> or <code>list</code></dt>
<dd>Value(s) to convert</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>str</code></dt>
<dd>Target units. Options include:
- Temperature: 'C', 'K'
- Energy: 'J', 'cal'
- Pressure: 'bar', 'MPa'
- Thermodynamic: 'G', 'logK'
- Electrochemical: 'Eh', 'pe', 'E0', 'logfO2'
- Volume: 'cm3bar', 'joules'</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>ndarray</code>, default <code>298.15</code></dt>
<dd>Temperature in K (for Eh/pe/logK conversions)</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float</code> or <code>ndarray</code>, default <code>1</code></dt>
<dd>Pressure in bar (for E0/logfO2 conversions)</dd>
<dt><strong><code>pH</code></strong> :&ensp;<code>float</code> or <code>ndarray</code>, default <code>7</code></dt>
<dd>pH value (for E0/logfO2 conversions)</dd>
<dt><strong><code>logaH2O</code></strong> :&ensp;<code>float</code> or <code>ndarray</code>, default <code>0</code></dt>
<dd>Log activity of water (for E0/logfO2 conversions)</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>ndarray</code></dt>
<dd>Converted value(s)</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; convert(25, 'K')  # Convert 25°C to K
298.15
&gt;&gt;&gt; convert(1.0, 'pe', T=298.15)  # Convert 1V Eh to pe
16.9
</code></pre></div>
</dd>
<dt id="pychnosz.copy_plot"><code class="name flex">
<span>def <span class="ident">copy_plot</span></span>(<span>diagram_result: Dict[str, Any]) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy_plot(diagram_result: Dict[str, Any]) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Create a deep copy of a diagram result, allowing independent modification.

    This function addresses a fundamental limitation in Python plotting libraries:
    matplotlib figure and axes objects are mutable, so passing them between
    functions causes modifications to affect all references. This function
    creates a true deep copy that can be modified independently.

    Parameters
    ----------
    diagram_result : dict
        Result dictionary from diagram(), which may contain &#39;fig&#39; and &#39;ax&#39; keys

    Returns
    -------
    dict
        A deep copy of the diagram result with independent figure and axes objects

    Examples
    --------
    Manual copying workflow (advanced usage - normally use add_to parameter instead):

    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; # Create base plot (Plot A)
    &gt;&gt;&gt; basis([&#39;SiO2&#39;, &#39;Ca+2&#39;, &#39;Mg+2&#39;, &#39;CO2&#39;, &#39;H2O&#39;, &#39;O2&#39;, &#39;H+&#39;])
    &gt;&gt;&gt; species([&#39;quartz&#39;, &#39;talc&#39;, &#39;chrysotile&#39;, &#39;forsterite&#39;])
    &gt;&gt;&gt; a = affinity(**{&#39;Mg+2&#39;: [4, 10, 500], &#39;Ca+2&#39;: [5, 15, 500]})
    &gt;&gt;&gt; plot_a = diagram(a, fill=&#39;terrain&#39;)
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Manual approach: create copies first, then modify the axes directly
    &gt;&gt;&gt; plot_a1 = copy_plot(plot_a)  # For modification 1
    &gt;&gt;&gt; plot_a2 = copy_plot(plot_a)  # For modification 2
    &gt;&gt;&gt; # ... then modify plot_a1[&#39;ax&#39;] and plot_a2[&#39;ax&#39;] directly
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Recommended approach: use add_to parameter instead
    &gt;&gt;&gt; # This automatically handles copying internally
    &gt;&gt;&gt; basis(&#39;CO2&#39;, -1)
    &gt;&gt;&gt; species([&#39;calcite&#39;, &#39;dolomide&#39;])
    &gt;&gt;&gt; a2 = affinity(**{&#39;Mg+2&#39;: [4, 10, 500], &#39;Ca+2&#39;: [5, 15, 500]})
    &gt;&gt;&gt; plot_a1 = diagram(a2, type=&#39;saturation&#39;, add_to=plot_a, col=&#39;blue&#39;)
    &gt;&gt;&gt; plot_a2 = diagram(a2, type=&#39;saturation&#39;, add_to=plot_a, col=&#39;red&#39;)
    &gt;&gt;&gt; # Now you have three independent plots: plot_a, plot_a1, plot_a2

    Notes
    -----
    - This function uses copy.deepcopy() which works well for matplotlib figures
    - For very large plots, copying may be memory-intensive
    - Interactive plots (plotly) may not copy perfectly - test before relying on this
    - The copied plot is fully independent and can be saved, displayed, or modified
      without affecting the original

    Limitations
    -----------
    Python&#39;s matplotlib (unlike R&#39;s base graphics) uses mutable objects for plots.
    Without explicit copying, all references point to the same plot. This is a
    known limitation of matplotlib that this function works around.

    See Also
    --------
    diagram : Create plots that can be copied with this function
    &#34;&#34;&#34;
    return copy.deepcopy(diagram_result)</code></pre>
</details>
<div class="desc"><p>Create a deep copy of a diagram result, allowing independent modification.</p>
<p>This function addresses a fundamental limitation in Python plotting libraries:
matplotlib figure and axes objects are mutable, so passing them between
functions causes modifications to affect all references. This function
creates a true deep copy that can be modified independently.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>diagram_result</code></strong> :&ensp;<code>dict</code></dt>
<dd>Result dictionary from diagram(), which may contain 'fig' and 'ax' keys</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A deep copy of the diagram result with independent figure and axes objects</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Manual copying workflow (advanced usage - normally use add_to parameter instead):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; # Create base plot (Plot A)
&gt;&gt;&gt; basis(['SiO2', 'Ca+2', 'Mg+2', 'CO2', 'H2O', 'O2', 'H+'])
&gt;&gt;&gt; species(['quartz', 'talc', 'chrysotile', 'forsterite'])
&gt;&gt;&gt; a = affinity(**{'Mg+2': [4, 10, 500], 'Ca+2': [5, 15, 500]})
&gt;&gt;&gt; plot_a = diagram(a, fill='terrain')
&gt;&gt;&gt;
&gt;&gt;&gt; # Manual approach: create copies first, then modify the axes directly
&gt;&gt;&gt; plot_a1 = copy_plot(plot_a)  # For modification 1
&gt;&gt;&gt; plot_a2 = copy_plot(plot_a)  # For modification 2
&gt;&gt;&gt; # ... then modify plot_a1['ax'] and plot_a2['ax'] directly
&gt;&gt;&gt;
&gt;&gt;&gt; # Recommended approach: use add_to parameter instead
&gt;&gt;&gt; # This automatically handles copying internally
&gt;&gt;&gt; basis('CO2', -1)
&gt;&gt;&gt; species(['calcite', 'dolomide'])
&gt;&gt;&gt; a2 = affinity(**{'Mg+2': [4, 10, 500], 'Ca+2': [5, 15, 500]})
&gt;&gt;&gt; plot_a1 = diagram(a2, type='saturation', add_to=plot_a, col='blue')
&gt;&gt;&gt; plot_a2 = diagram(a2, type='saturation', add_to=plot_a, col='red')
&gt;&gt;&gt; # Now you have three independent plots: plot_a, plot_a1, plot_a2
</code></pre>
<h2 id="notes">Notes</h2>
<ul>
<li>This function uses copy.deepcopy() which works well for matplotlib figures</li>
<li>For very large plots, copying may be memory-intensive</li>
<li>Interactive plots (plotly) may not copy perfectly - test before relying on this</li>
<li>The copied plot is fully independent and can be saved, displayed, or modified
without affecting the original</li>
</ul>
<h2 id="limitations">Limitations</h2>
<p>Python's matplotlib (unlike R's base graphics) uses mutable objects for plots.
Without explicit copying, all references point to the same plot. This is a
known limitation of matplotlib that this function works around.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="pychnosz.diagram" href="#pychnosz.diagram">diagram()</a></code></dt>
<dd>Create plots that can be copied with this function</dd>
</dl></div>
</dd>
<dt id="pychnosz.describe_basis"><code class="name flex">
<span>def <span class="ident">describe_basis</span></span>(<span>ibasis: list = None,<br>digits: int = 1,<br>oneline: bool = False,<br>molality: bool = False,<br>use_pH: bool = True) ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_basis(ibasis: list = None, digits: int = 1,
                  oneline: bool = False, molality: bool = False,
                  use_pH: bool = True) -&gt; list:
    &#34;&#34;&#34;
    Create formatted text describing basis species activities/fugacities.

    This function generates formatted strings for displaying the chemical
    activities or fugacities of basis species, typically for plot legends.

    Parameters
    ----------
    ibasis : list of int, optional
        Indices of basis species to describe (1-based). If None, describes all.
    digits : int, default 1
        Number of decimal places to display
    oneline : bool, default False
        If True, combine all species on one line (not fully implemented)
    molality : bool, default False
        If True, use molality (m) instead of activity (a)
    use_pH : bool, default True
        If True, display H+ as pH instead of log a_H+

    Returns
    -------
    list of str
        Formatted basis species descriptions

    Examples
    --------
    &gt;&gt;&gt; from pychnosz.core.basis import basis
    &gt;&gt;&gt; basis([&#34;H2O&#34;, &#34;H+&#34;, &#34;O2&#34;], [-10, -7, -80])
    &gt;&gt;&gt; describe_basis([2, 3])
    [&#39;pH = 7.0&#39;, &#39;log $f_{O_2}$ = -80.0&#39;]

    &gt;&gt;&gt; describe_basis()  # All basis species
    [&#39;log $a_{H_2O}$ = -10.0&#39;, &#39;pH = 7.0&#39;, &#39;log $f_{O_2}$ = -80.0&#39;]

    Notes
    -----
    This is used to create legend entries showing the basis species
    activities used in thermodynamic calculations.
    &#34;&#34;&#34;
    from ..core.basis import get_basis

    basis_df = get_basis()
    if basis_df is None:
        raise RuntimeError(&#34;Basis species are not defined&#34;)

    # Default to all basis species
    if ibasis is None:
        ibasis = list(range(1, len(basis_df) + 1))

    # Convert to 0-based indexing
    ibasis_0 = [i - 1 for i in ibasis]

    descriptions = []

    for i in ibasis_0:
        species_name = basis_df.index[i]
        state = basis_df.iloc[i][&#39;state&#39;]
        logact = basis_df.iloc[i][&#39;logact&#39;]

        # Check if logact is numeric
        try:
            logact_val = float(logact)
            is_numeric = True
        except (ValueError, TypeError):
            is_numeric = False

        if is_numeric:
            # Handle H+ specially with pH
            if species_name == &#34;H+&#34; and use_pH:
                pH_val = -logact_val
                val_formatted = format(round(pH_val, digits), f&#39;.{digits}f&#39;)
                descriptions.append(f&#34;pH = {val_formatted}&#34;)
            else:
                # Format the activity/fugacity
                val_formatted = format(round(logact_val, digits), f&#39;.{digits}f&#39;)

                # Determine if it&#39;s activity or fugacity based on state
                if state in [&#39;aq&#39;, &#39;liq&#39;, &#39;cr&#39;]:
                    a_or_f = &#34;a&#34; if not molality else &#34;m&#34;
                else:
                    a_or_f = &#34;f&#34;

                # Format the species name
                species_formatted = _format_species_latex(species_name)

                descriptions.append(f&#34;log ${a_or_f}_{{{species_formatted}}}$ = {val_formatted}&#34;)
        else:
            # Non-numeric value (buffer)
            if species_name == &#34;H+&#34; and use_pH:
                descriptions.append(f&#34;pH = {logact}&#34;)
            else:
                # For buffers, just show the buffer name
                if state in [&#39;aq&#39;, &#39;liq&#39;, &#39;cr&#39;]:
                    a_or_f = &#34;a&#34; if not molality else &#34;m&#34;
                else:
                    a_or_f = &#34;f&#34;

                species_formatted = _format_species_latex(species_name)
                descriptions.append(f&#34;${a_or_f}_{{{species_formatted}}}$ = {logact}&#34;)

    return descriptions</code></pre>
</details>
<div class="desc"><p>Create formatted text describing basis species activities/fugacities.</p>
<p>This function generates formatted strings for displaying the chemical
activities or fugacities of basis species, typically for plot legends.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ibasis</code></strong> :&ensp;<code>list</code> of <code>int</code>, optional</dt>
<dd>Indices of basis species to describe (1-based). If None, describes all.</dd>
<dt><strong><code>digits</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Number of decimal places to display</dd>
<dt><strong><code>oneline</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, combine all species on one line (not fully implemented)</dd>
<dt><strong><code>molality</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, use molality (m) instead of activity (a)</dd>
<dt><strong><code>use_pH</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, display H+ as pH instead of log a_H+</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>str</code></dt>
<dd>Formatted basis species descriptions</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz.core.basis import basis
&gt;&gt;&gt; basis([&quot;H2O&quot;, &quot;H+&quot;, &quot;O2&quot;], [-10, -7, -80])
&gt;&gt;&gt; describe_basis([2, 3])
['pH = 7.0', 'log $f_{O_2}$ = -80.0']
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; describe_basis()  # All basis species
['log $a_{H_2O}$ = -10.0', 'pH = 7.0', 'log $f_{O_2}$ = -80.0']
</code></pre>
<h2 id="notes">Notes</h2>
<p>This is used to create legend entries showing the basis species
activities used in thermodynamic calculations.</p></div>
</dd>
<dt id="pychnosz.describe_basis_html"><code class="name flex">
<span>def <span class="ident">describe_basis_html</span></span>(<span>ibasis: list = None,<br>digits: int = 1,<br>oneline: bool = False,<br>molality: bool = False,<br>use_pH: bool = True) ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_basis_html(ibasis: list = None, digits: int = 1,
                        oneline: bool = False, molality: bool = False,
                        use_pH: bool = True) -&gt; list:
    &#34;&#34;&#34;
    Create HTML-formatted text describing basis species (for Plotly).

    This function generates HTML-formatted strings for displaying the chemical
    activities or fugacities of basis species, typically for plot legends in
    interactive diagrams.

    Parameters
    ----------
    ibasis : list of int, optional
        Indices of basis species to describe (1-based). If None, describes all.
    digits : int, default 1
        Number of decimal places to display
    oneline : bool, default False
        If True, combine all species on one line (not fully implemented)
    molality : bool, default False
        If True, use molality (m) instead of activity (a)
    use_pH : bool, default True
        If True, display H+ as pH instead of log a_H+

    Returns
    -------
    list of str
        HTML-formatted basis species descriptions

    Examples
    --------
    &gt;&gt;&gt; from pychnosz.core.basis import basis
    &gt;&gt;&gt; basis([&#34;H2O&#34;, &#34;H+&#34;, &#34;O2&#34;], [-10, -7, -80])
    &gt;&gt;&gt; describe_basis_html([2, 3])
    [&#39;pH = 7.0&#39;, &#39;log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;O&lt;sub&gt;2&lt;/sub&gt;&lt;/sub&gt; = -80.0&#39;]

    &gt;&gt;&gt; describe_basis_html([4])  # CO2
    [&#39;log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;CO&lt;sub&gt;2&lt;/sub&gt;&lt;/sub&gt; = -1.0&#39;]

    Notes
    -----
    Use this instead of describe_basis() when creating legends for
    interactive (Plotly) diagrams.
    &#34;&#34;&#34;
    if not _HTML_DEPS_AVAILABLE:
        raise ImportError(
            &#34;describe_basis_html() requires &#39;WORMutils&#39; package.\n&#34;
            &#34;Install with: pip install WORMutils&#34;
        )

    from ..core.basis import get_basis

    basis_df = get_basis()
    if basis_df is None:
        raise RuntimeError(&#34;Basis species are not defined&#34;)

    # Default to all basis species
    if ibasis is None:
        ibasis = list(range(1, len(basis_df) + 1))

    # Convert to 0-based indexing
    ibasis_0 = [i - 1 for i in ibasis]

    descriptions = []

    for i in ibasis_0:
        species_name = basis_df.index[i]
        state = basis_df.iloc[i][&#39;state&#39;]
        logact = basis_df.iloc[i][&#39;logact&#39;]

        # Check if logact is numeric
        try:
            logact_val = float(logact)
            is_numeric = True
        except (ValueError, TypeError):
            is_numeric = False

        if is_numeric:
            # Handle H+ specially with pH
            if species_name == &#34;H+&#34; and use_pH:
                pH_val = -logact_val
                val_formatted = format(round(pH_val, digits), f&#39;.{digits}f&#39;)
                descriptions.append(f&#34;pH = {val_formatted}&#34;)
            else:
                # Format the activity/fugacity
                val_formatted = format(round(logact_val, digits), f&#39;.{digits}f&#39;)

                # Determine if it&#39;s activity or fugacity based on state
                if state in [&#39;aq&#39;, &#39;liq&#39;, &#39;cr&#39;]:
                    a_or_f = &#34;a&#34; if not molality else &#34;m&#34;
                else:
                    a_or_f = &#34;f&#34;

                # Format the species name using HTML
                species_formatted = chemlabel(species_name)

                descriptions.append(f&#34;log &lt;i&gt;{a_or_f}&lt;/i&gt;&lt;sub&gt;{species_formatted}&lt;/sub&gt; = {val_formatted}&#34;)
        else:
            # Non-numeric value (buffer)
            if species_name == &#34;H+&#34; and use_pH:
                descriptions.append(f&#34;pH = {logact}&#34;)
            else:
                # For buffers, just show the buffer name
                if state in [&#39;aq&#39;, &#39;liq&#39;, &#39;cr&#39;]:
                    a_or_f = &#34;a&#34; if not molality else &#34;m&#34;
                else:
                    a_or_f = &#34;f&#34;

                species_formatted = chemlabel(species_name)
                descriptions.append(f&#34;&lt;i&gt;{a_or_f}&lt;/i&gt;&lt;sub&gt;{species_formatted}&lt;/sub&gt; = {logact}&#34;)

    return descriptions</code></pre>
</details>
<div class="desc"><p>Create HTML-formatted text describing basis species (for Plotly).</p>
<p>This function generates HTML-formatted strings for displaying the chemical
activities or fugacities of basis species, typically for plot legends in
interactive diagrams.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ibasis</code></strong> :&ensp;<code>list</code> of <code>int</code>, optional</dt>
<dd>Indices of basis species to describe (1-based). If None, describes all.</dd>
<dt><strong><code>digits</code></strong> :&ensp;<code>int</code>, default <code>1</code></dt>
<dd>Number of decimal places to display</dd>
<dt><strong><code>oneline</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, combine all species on one line (not fully implemented)</dd>
<dt><strong><code>molality</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, use molality (m) instead of activity (a)</dd>
<dt><strong><code>use_pH</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, display H+ as pH instead of log a_H+</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>str</code></dt>
<dd>HTML-formatted basis species descriptions</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz.core.basis import basis
&gt;&gt;&gt; basis([&quot;H2O&quot;, &quot;H+&quot;, &quot;O2&quot;], [-10, -7, -80])
&gt;&gt;&gt; describe_basis_html([2, 3])
['pH = 7.0', 'log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;O&lt;sub&gt;2&lt;/sub&gt;&lt;/sub&gt; = -80.0']
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; describe_basis_html([4])  # CO2
['log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;CO&lt;sub&gt;2&lt;/sub&gt;&lt;/sub&gt; = -1.0']
</code></pre>
<h2 id="notes">Notes</h2>
<p>Use this instead of describe_basis() when creating legends for
interactive (Plotly) diagrams.</p></div>
</dd>
<dt id="pychnosz.describe_property"><code class="name flex">
<span>def <span class="ident">describe_property</span></span>(<span>property: list = None,<br>value: list = None,<br>digits: int = 0,<br>oneline: bool = False,<br>ret_val: bool = False) ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_property(property: list = None, value: list = None,
                     digits: int = 0, oneline: bool = False,
                     ret_val: bool = False) -&gt; list:
    &#34;&#34;&#34;
    Create formatted text describing thermodynamic properties and their values.

    This function generates formatted strings for displaying property-value pairs
    in legends, typically for temperature, pressure, and other conditions.

    Parameters
    ----------
    property : list of str
        Property names (e.g., [&#34;T&#34;, &#34;P&#34;])
    value : list
        Property values (e.g., [300, 1000])
    digits : int, default 0
        Number of decimal places to display
    oneline : bool, default False
        If True, combine all properties on one line (not implemented)
    ret_val : bool, default False
        If True, return only values with units (not property names)

    Returns
    -------
    list of str
        Formatted property descriptions

    Examples
    --------
    &gt;&gt;&gt; describe_property([&#34;T&#34;, &#34;P&#34;], [300, 1000])
    [&#39;$T$ = 300 °C&#39;, &#39;$P$ = 1000 bar&#39;]

    &gt;&gt;&gt; describe_property([&#34;T&#34;], [25], digits=1)
    [&#39;$T$ = 25.0 °C&#39;]

    Notes
    -----
    This is used to create legend entries showing the conditions
    used in thermodynamic calculations.
    &#34;&#34;&#34;
    if property is None or value is None:
        raise ValueError(&#34;property or value is None&#34;)

    descriptions = []

    for i in range(len(property)):
        prop = property[i]
        val = value[i]

        # Get property symbol
        if prop == &#34;T&#34;:
            prop_str = &#34;$T$&#34;
            if val == &#34;Psat&#34; or val == &#34;NA&#34;:
                val_str = &#34;$P_{sat}$&#34;
            else:
                val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
                val_str = f&#34;{val_formatted} °C&#34;
        elif prop == &#34;P&#34;:
            prop_str = &#34;$P$&#34;
            if val == &#34;Psat&#34; or val == &#34;NA&#34;:
                val_str = &#34;$P_{sat}$&#34;
            else:
                val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
                val_str = f&#34;{val_formatted} bar&#34;
        elif prop == &#34;pH&#34;:
            prop_str = &#34;pH&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = val_formatted
        elif prop == &#34;Eh&#34;:
            prop_str = &#34;Eh&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = f&#34;{val_formatted} V&#34;
        elif prop == &#34;IS&#34;:
            prop_str = &#34;$IS$&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = val_formatted
        else:
            prop_str = f&#34;${prop}$&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = val_formatted

        if ret_val:
            descriptions.append(val_str)
        else:
            descriptions.append(f&#34;{prop_str} = {val_str}&#34;)

    return descriptions</code></pre>
</details>
<div class="desc"><p>Create formatted text describing thermodynamic properties and their values.</p>
<p>This function generates formatted strings for displaying property-value pairs
in legends, typically for temperature, pressure, and other conditions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Property names (e.g., ["T", "P"])</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>list</code></dt>
<dd>Property values (e.g., [300, 1000])</dd>
<dt><strong><code>digits</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>Number of decimal places to display</dd>
<dt><strong><code>oneline</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, combine all properties on one line (not implemented)</dd>
<dt><strong><code>ret_val</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, return only values with units (not property names)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>str</code></dt>
<dd>Formatted property descriptions</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; describe_property([&quot;T&quot;, &quot;P&quot;], [300, 1000])
['$T$ = 300 °C', '$P$ = 1000 bar']
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; describe_property([&quot;T&quot;], [25], digits=1)
['$T$ = 25.0 °C']
</code></pre>
<h2 id="notes">Notes</h2>
<p>This is used to create legend entries showing the conditions
used in thermodynamic calculations.</p></div>
</dd>
<dt id="pychnosz.describe_property_html"><code class="name flex">
<span>def <span class="ident">describe_property_html</span></span>(<span>property: list = None,<br>value: list = None,<br>digits: int = 0,<br>oneline: bool = False,<br>ret_val: bool = False) ‑> list</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def describe_property_html(property: list = None, value: list = None,
                           digits: int = 0, oneline: bool = False,
                           ret_val: bool = False) -&gt; list:
    &#34;&#34;&#34;
    Create HTML-formatted text describing thermodynamic properties (for Plotly).

    This function generates HTML-formatted strings for displaying thermodynamic
    properties and their values, typically for plot legends in interactive diagrams.

    Parameters
    ----------
    property : list of str
        Property names (e.g., [&#34;T&#34;, &#34;P&#34;])
    value : list
        Property values
    digits : int, default 0
        Number of decimal places to display
    oneline : bool, default False
        If True, format on one line (not implemented)
    ret_val : bool, default False
        If True, return only values without property names

    Returns
    -------
    list of str
        HTML-formatted property descriptions

    Examples
    --------
    &gt;&gt;&gt; describe_property_html([&#34;T&#34;, &#34;P&#34;], [300, 1000])
    [&#39;&lt;i&gt;T&lt;/i&gt; = 300 °C&#39;, &#39;&lt;i&gt;P&lt;/i&gt; = 1000 bar&#39;]

    Notes
    -----
    Use this instead of describe_property() when creating legends for
    interactive (Plotly) diagrams.
    &#34;&#34;&#34;
    if property is None or value is None:
        raise ValueError(&#34;property or value is None&#34;)

    descriptions = []

    for i in range(len(property)):
        prop = property[i]
        val = value[i]

        # Get property symbol (HTML format)
        if prop == &#34;T&#34;:
            prop_str = &#34;&lt;i&gt;T&lt;/i&gt;&#34;
            if val == &#34;Psat&#34; or val == &#34;NA&#34;:
                val_str = &#34;&lt;i&gt;P&lt;/i&gt;&lt;sub&gt;sat&lt;/sub&gt;&#34;
            else:
                val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
                val_str = f&#34;{val_formatted} °C&#34;
        elif prop == &#34;P&#34;:
            prop_str = &#34;&lt;i&gt;P&lt;/i&gt;&#34;
            if val == &#34;Psat&#34; or val == &#34;NA&#34;:
                val_str = &#34;&lt;i&gt;P&lt;/i&gt;&lt;sub&gt;sat&lt;/sub&gt;&#34;
            else:
                val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
                val_str = f&#34;{val_formatted} bar&#34;
        elif prop == &#34;pH&#34;:
            prop_str = &#34;pH&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = val_formatted
        elif prop == &#34;Eh&#34;:
            prop_str = &#34;Eh&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = f&#34;{val_formatted} V&#34;
        elif prop == &#34;IS&#34;:
            prop_str = &#34;&lt;i&gt;IS&lt;/i&gt;&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = val_formatted
        else:
            prop_str = f&#34;&lt;i&gt;{prop}&lt;/i&gt;&#34;
            val_formatted = format(round(float(val), digits), f&#39;.{digits}f&#39;)
            val_str = val_formatted

        if ret_val:
            descriptions.append(val_str)
        else:
            descriptions.append(f&#34;{prop_str} = {val_str}&#34;)

    return descriptions</code></pre>
</details>
<div class="desc"><p>Create HTML-formatted text describing thermodynamic properties (for Plotly).</p>
<p>This function generates HTML-formatted strings for displaying thermodynamic
properties and their values, typically for plot legends in interactive diagrams.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Property names (e.g., ["T", "P"])</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>list</code></dt>
<dd>Property values</dd>
<dt><strong><code>digits</code></strong> :&ensp;<code>int</code>, default <code>0</code></dt>
<dd>Number of decimal places to display</dd>
<dt><strong><code>oneline</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, format on one line (not implemented)</dd>
<dt><strong><code>ret_val</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, return only values without property names</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>str</code></dt>
<dd>HTML-formatted property descriptions</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; describe_property_html([&quot;T&quot;, &quot;P&quot;], [300, 1000])
['&lt;i&gt;T&lt;/i&gt; = 300 °C', '&lt;i&gt;P&lt;/i&gt; = 1000 bar']
</code></pre>
<h2 id="notes">Notes</h2>
<p>Use this instead of describe_property() when creating legends for
interactive (Plotly) diagrams.</p></div>
</dd>
<dt id="pychnosz.diagram"><code class="name flex">
<span>def <span class="ident">diagram</span></span>(<span>eout: Dict[str, Any],<br>type: str = 'auto',<br>alpha: bool = False,<br>balance: str | float | List[float] | None = None,<br>names: List[str] | None = None,<br>format_names: bool = True,<br>xlab: str | None = None,<br>ylab: str | None = None,<br>xlim: List[float] | None = None,<br>ylim: List[float] | None = None,<br>col: str | List[str] | None = None,<br>col_names: str | List[str] | None = None,<br>lty: str | int | List | None = None,<br>lwd: float | List[float] = 1,<br>cex: float | List[float] = 1.0,<br>main: str | None = None,<br>fill: str | None = None,<br>fill_NA: str = '0.8',<br>limit_water: bool | None = None,<br>plot_it: bool = True,<br>add_to: Dict[str, Any] | None = None,<br>contour_method: str | List[str] | None = 'edge',<br>messages: bool = True,<br>interactive: bool = False,<br>annotation: str | None = None,<br>annotation_coords: List[float] = [0, 0],<br>width: int = 600,<br>height: int = 520,<br>save_as: str | None = None,<br>save_format: str | None = None,<br>save_scale: float = 1,<br>normalize: bool | List[bool] = False,<br>as_residue: bool = False,<br>**kwargs) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagram(eout: Dict[str, Any],
            type: str = &#34;auto&#34;,
            alpha: bool = False,
            balance: Optional[Union[str, float, List[float]]] = None,
            names: Optional[List[str]] = None,
            format_names: bool = True,
            xlab: Optional[str] = None,
            ylab: Optional[str] = None,
            xlim: Optional[List[float]] = None,
            ylim: Optional[List[float]] = None,
            col: Optional[Union[str, List[str]]] = None,
            col_names: Optional[Union[str, List[str]]] = None,
            lty: Optional[Union[str, int, List]] = None,
            lwd: Union[float, List[float]] = 1,
            cex: Union[float, List[float]] = 1.0,
            main: Optional[str] = None,
            fill: Optional[str] = None,
            fill_NA: str = &#34;0.8&#34;,
            limit_water: Optional[bool] = None,
            plot_it: bool = True,
            add_to: Optional[Dict[str, Any]] = None,
            contour_method: Optional[Union[str, List[str]]] = &#34;edge&#34;,
            messages: bool = True,
            interactive: bool = False,
            annotation: Optional[str] = None,
            annotation_coords: List[float] = [0, 0],
            width: int = 600,
            height: int = 520,
            save_as: Optional[str] = None,
            save_format: Optional[str] = None,
            save_scale: float = 1,
            normalize: Union[bool, List[bool]] = False,
            as_residue: bool = False,
            **kwargs) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Plot equilibrium chemical activity and predominance diagrams.

    This function creates plots from the output of affinity() or equilibrate().
    For 1D diagrams, it produces line plots showing how affinity or activity
    varies with a single variable. For 2D diagrams, it creates predominance
    field diagrams.

    Parameters
    ----------
    eout : dict
        Output from affinity() or equilibrate()
    type : str, default &#34;auto&#34;
        Type of diagram:
        - &#34;auto&#34; (default): Plot affinity values (A/2.303RT)
        - &#34;loga.equil&#34;: Plot equilibrium activities from equilibrate()
        - &#34;saturation&#34;: Draw affinity=0 contour lines (mineral saturation)
        - Basis species name (e.g., &#34;O2&#34;, &#34;H2O&#34;, &#34;CO2&#34;): Plot equilibrium
          log activity/fugacity of the specified basis species where affinity=0
          for each formed species. Useful for Eh-pH diagrams and showing
          oxygen/water fugacities at equilibrium.
    alpha : bool or str, default False
        Plot degree of formation instead of activities?
        If &#34;balance&#34;, scale by balancing coefficients
    balance : str, float, or list of float, optional
        Balancing coefficients or method for balancing reactions
    names : list of str, optional
        Custom names for species (for labels)
    format_names : bool, default True
        Apply formatting to chemical formulas?
    xlab : str, optional
        Custom x-axis label
    ylab : str, optional
        Custom y-axis label
    xlim : list of float, optional
        X-axis limits [min, max]
    ylim : list of float, optional
        Y-axis limits [min, max]
    col : str or list of str, optional
        Line colors for 1-D plots and boundary lines in 2-D plots (matplotlib color specs)
    col_names : str or list of str, optional
        Text colors for field labels in 2-D plots (matplotlib color specs)
    lty : str, int, or list, optional
        Line styles (matplotlib linestyle specs)
    lwd : float or list of float, default 1
        Line widths for 1-D plots and boundary lines in 2-D predominance
        diagrams. Set to 0 to disable borders in 2-D diagrams. If fill is
        None and lwd &gt; 0, uses white fill with black borders (R CHNOSZ default).
    cex : float or list of float, default 1.0
        Character expansion factor for text labels. Values &gt; 1 make text larger,
        values &lt; 1 make text smaller. Can be a single value or a list (one per species).
        Used for contour labels in type=&#34;saturation&#34; plots.
    main : str, optional
        Plot title
    fill : str, optional
        Color palette for 2-D predominance diagrams. Can be any matplotlib
        colormap name (e.g., &#39;viridis&#39;, &#39;plasma&#39;, &#39;terrain&#39;, &#39;rainbow&#39;,
        &#39;Set1&#39;, &#39;tab10&#39;, &#39;Pastel1&#39;). If None, uses discrete colors from
        the default color cycle. Ignored for 1-D diagrams.
    fill_NA : str, default &#34;0.8&#34;
        Color for regions outside water stability limits (water instability regions).
        Matplotlib color specification (e.g., &#34;0.8&#34; for gray, &#34;#CCCCCC&#34;).
        Set to &#34;transparent&#34; to disable shading. Default &#34;0.8&#34; matches R&#39;s &#34;gray80&#34;.
    limit_water : bool, optional
        Whether to show water stability limits as shaded regions (default True for
        2-D diagrams). If True, also clips the diagram to the water stability region.
        Set to False to disable water stability shading.
    plot_it : bool, default True
        Display the plot?
    add_to : dict, optional
        A diagram result dictionary from a previous diagram() call. When provided,
        this plot will be AUTOMATICALLY COPIED and the new diagram will be added to
        the copy. This preserves the original plot while creating a modified version.
        The axes object is extracted from add_to[&#39;ax&#39;].

        This parameter eliminates the need for a separate &#39;add&#39; boolean - when
        add_to is provided, the function automatically operates in &#34;add&#34; mode.

        Example workflow:
        &gt;&gt;&gt; plot_a = diagram(affinity1, fill=&#39;terrain&#39;)  # Create base plot
        &gt;&gt;&gt; plot_a1 = diagram(affinity2, add_to=plot_a, col=&#39;blue&#39;)  # Copy and add
        &gt;&gt;&gt; plot_a2 = diagram(affinity3, add_to=plot_a, col=&#39;red&#39;)   # Copy and add again
        &gt;&gt;&gt; # plot_a remains unchanged, plot_a1 and plot_a2 are independent modifications
    contour_method : str or list of str, optional
        Method for labeling contour lines. Default &#34;edge&#34; labels at plot edges.
        Can be a single value (applied to all species) or a list (one per species).
        Set to None, NA, or &#34;&#34; to disable labels (only for type=&#34;saturation&#34;).
        In R CHNOSZ, different methods like &#34;edge&#34;, &#34;flattest&#34;, &#34;simple&#34; control
        label placement; in Python, this mainly controls whether labels are shown.
    interactive : bool, default False
        Create an interactive plot using Plotly instead of matplotlib?
        If True, calls diagram_interactive() with the appropriate parameters.
    annotation : str, optional
        For interactive plots only. Annotation text to add to the plot.
    annotation_coords : list of float, default [0, 0]
        For interactive plots only. Coordinates of annotation, where [0, 0] is
        bottom left and [1, 1] is top right.
    width : int, default 600
        For interactive plots only. Width of the plot in pixels.
    height : int, default 520
        For interactive plots only. Height of the plot in pixels.
    save_as : str, optional
        For interactive plots only. Provide a filename to save this figure.
        Filetype is determined by `save_format`.
    save_format : str, optional
        For interactive plots only. Desired format of saved or downloaded figure.
        Can be &#39;png&#39;, &#39;jpg&#39;, &#39;jpeg&#39;, &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;.
        If &#39;html&#39;, an interactive plot will be saved.
    save_scale : float, default 1
        For interactive plots only. Multiply title/legend/axis/canvas sizes by
        this factor when saving the figure.
    **kwargs
        Additional arguments passed to matplotlib plotting functions

    Returns
    -------
    dict
        Dictionary containing:
        - plotvar : str, Variable that was plotted
        - plotvals : dict, Values that were plotted
        - names : list, Names used for labels
        - predominant : array or NA, Predominance matrix (for 2D)
        - balance : str or list, Balancing coefficients used
        - n.balance : list, Numerical balancing coefficients
        - ax : matplotlib.axes.Axes, The axes object used for plotting (if plot_it=True)
        - fig : matplotlib.figure.Figure, The figure object used for plotting (if plot_it=True)
        - All original eout contents

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.basis([&#34;Fe2O3&#34;, &#34;CO2&#34;, &#34;H2O&#34;, &#34;NH3&#34;, &#34;H2S&#34;, &#34;oxygen&#34;, &#34;H+&#34;],
    ...              [0, -3, 0, -4, -7, -80, -7])
    &gt;&gt;&gt; pychnosz.species([&#34;pyrite&#34;, &#34;goethite&#34;])
    &gt;&gt;&gt; a = pychnosz.affinity(H2S=[-60, 20, 5], T=25, P=1)
    &gt;&gt;&gt; d = diagram(a)

    Notes
    -----
    This implementation is based on R CHNOSZ diagram() function but adapted
    for Python&#39;s matplotlib plotting instead of R&#39;s base graphics. The key
    differences from diagram_from_WORM.py are:
    - Works directly with Python dict output from affinity() (no rpy2)
    - Uses matplotlib for 1D plots by default
    - Can optionally use plotly if requested
    &#34;&#34;&#34;

    # Handle add_to parameter: automatically copy the provided plot
    # This extracts the axes object and creates an independent copy
    # When add_to is provided, we&#39;re in &#34;add&#34; mode
    ax = None
    add = add_to is not None
    plot_was_provided = add

    if add_to is not None:
        # Make a deep copy of the provided plot to preserve the original
        plot_copy = copy_plot(add_to)
        # Extract the axes from the copied plot
        if &#39;ax&#39; in plot_copy:
            ax = plot_copy[&#39;ax&#39;]
        else:
            raise ValueError(&#34;The &#39;add_to&#39; parameter must contain an &#39;ax&#39; key (a diagram result dictionary)&#34;)

    # If interactive mode is requested, delegate to diagram_interactive
    if interactive:
        df, fig = diagram_interactive(
            eout=eout,
            type=type,
            main=main,
            borders=lwd,
            names=names,
            format_names=format_names,
            annotation=annotation,
            annotation_coords=annotation_coords,
            balance=balance,
            xlab=xlab,
            ylab=ylab,
            fill=fill,
            width=width,
            height=height,
            alpha=alpha,
            plot_it=plot_it,
            add=add,
            ax=ax,
            col=col,
            lty=lty,
            lwd=lwd,
            cex=cex,
            contour_method=contour_method,
            save_as=save_as,
            save_format=save_format,
            save_scale=save_scale,
            messages=messages
        )
        # Return in a format compatible with diagram&#39;s normal output
        # diagram_interactive returns (df, fig), wrap in a dict for consistency
        # Include eout data so water_lines() can access vars, vals, basis, etc.
        result = {
            **eout,  # Include all original eout data
            &#39;df&#39;: df,
            &#39;fig&#39;: fig,
            &#39;ax&#39;: fig  # For compatibility, store fig in ax key for add=True workflow
        }
        return result

    # Check that eout is valid
    efun = eout.get(&#39;fun&#39;, &#39;&#39;)
    if efun not in [&#39;affinity&#39;, &#39;equilibrate&#39;, &#39;solubility&#39;]:
        raise ValueError(&#34;&#39;eout&#39; is not the output from affinity(), equilibrate(), or solubility()&#34;)

    # Determine if eout is from affinity() (as opposed to equilibrate())
    # Check for both Python naming (loga_equil) and R naming (loga.equil)
    eout_is_aout = &#39;loga_equil&#39; not in eout and &#39;loga.equil&#39; not in eout

    # Check if type is a basis species name
    plot_loga_basis = False
    if type not in [&#34;auto&#34;, &#34;saturation&#34;, &#34;loga.equil&#34;, &#34;loga_equil&#34;, &#34;loga.balance&#34;, &#34;loga_balance&#34;]:
        # Check if type matches a basis species name
        if &#39;basis&#39; in eout:
            basis_species = list(eout[&#39;basis&#39;].index) if hasattr(eout[&#39;basis&#39;], &#39;index&#39;) else []
            if type in basis_species:
                plot_loga_basis = True
                if alpha:
                    raise ValueError(&#34;equilibrium activities of basis species not available with alpha = TRUE&#34;)

    # Handle type=&#34;saturation&#34; - requires affinity output
    if type == &#34;saturation&#34;:
        if not eout_is_aout:
            raise ValueError(&#34;type=&#39;saturation&#39; requires output from affinity(), not equilibrate()&#34;)
        # Set eout_is_aout flag
        eout_is_aout = True

    # Get number of dimensions
    # Handle both dict (affinity) and list (equilibrate) values structures
    if isinstance(eout[&#39;values&#39;], dict):
        first_values = list(eout[&#39;values&#39;].values())[0]
    elif isinstance(eout[&#39;values&#39;], list):
        first_values = eout[&#39;values&#39;][0]
    else:
        first_values = eout[&#39;values&#39;]

    if hasattr(first_values, &#39;shape&#39;):
        nd = len(first_values.shape)
    elif hasattr(first_values, &#39;__len__&#39;):
        nd = 1
    else:
        nd = 0  # Single value

    # For affinity output, get balancing coefficients
    if eout_is_aout and type == &#34;auto&#34;:
        n_balance, balance = _get_balance(eout, balance, messages)
    elif eout_is_aout and type == &#34;saturation&#34;:
        # For saturation diagrams, use n_balance = 1 for all species (don&#39;t normalize by stoichiometry)
        if isinstance(eout[&#39;values&#39;], dict):
            n_balance = [1] * len(eout[&#39;values&#39;])
        elif isinstance(eout[&#39;values&#39;], list):
            n_balance = [1] * len(eout[&#39;values&#39;])
        else:
            n_balance = [1]
        if balance is None:
            balance = 1
    else:
        # For equilibrate output, use n_balance from equilibrate if available
        if &#39;n_balance&#39; in eout:
            n_balance = eout[&#39;n_balance&#39;]
            balance = eout.get(&#39;balance&#39;, 1)
        else:
            if isinstance(eout[&#39;values&#39;], dict):
                n_balance = [1] * len(eout[&#39;values&#39;])
            elif isinstance(eout[&#39;values&#39;], list):
                n_balance = [1] * len(eout[&#39;values&#39;])
            else:
                n_balance = [1]
            if balance is None:
                balance = 1

    # Determine what to plot
    plotvals = {}
    plotvar = eout.get(&#39;property&#39;, &#39;A&#39;)

    # Calculate equilibrium log activity/fugacity of basis species
    if plot_loga_basis:
        # Find the index of the basis species
        basis_df = eout[&#39;basis&#39;]
        ibasis = list(basis_df.index).index(type)

        # Get the logarithm of activity used in the affinity calculation
        logact = basis_df.iloc[ibasis][&#39;logact&#39;]

        # Check if logact is numeric
        try:
            loga_basis = float(logact)
        except (ValueError, TypeError):
            raise ValueError(f&#34;the logarithm of activity for basis species {type} is not numeric - was a buffer selected?&#34;)

        # Get the reaction coefficients for this basis species
        # eout[&#39;species&#39;] is a DataFrame with basis species as columns
        nu_basis = eout[&#39;species&#39;].iloc[:, ibasis].values

        # Calculate the logarithm of activity where affinity = 0
        # loga_equilibrium = loga_basis - affinity / nu_basis
        plotvals = {}
        for i, (sp_idx, affinity_vals) in enumerate(eout[&#39;values&#39;].items()):
            plotvals[sp_idx] = loga_basis - affinity_vals / nu_basis[i]

        plotvar = type

        # Set n_balance (not used for basis species plots, but needed for compatibility)
        n_balance = [1] * len(plotvals)
        if balance is None:
            balance = 1
    elif eout_is_aout:
        # Plot affinity values divided by balancing coefficients
        # DEBUG: Check balance application
        if False:  # Set to True for debugging
            print(f&#34;\nDEBUG: Applying balance to affinity values&#34;)
            print(f&#34;  n_balance: {n_balance}&#34;)

        # Handle dict-based values (from affinity)
        if isinstance(eout[&#39;values&#39;], dict):
            for i, (species_idx, values) in enumerate(eout[&#39;values&#39;].items()):
                if False:  # Set to True for debugging
                    print(f&#34;  Species {i} (ispecies {species_idx}): values/n_balance[{i}]={n_balance[i]}&#34;)
                plotvals[species_idx] = values / n_balance[i]
        # Handle list-based values
        elif isinstance(eout[&#39;values&#39;], list):
            for i, values in enumerate(eout[&#39;values&#39;]):
                species_idx = eout[&#39;species&#39;][&#39;ispecies&#39;].iloc[i]
                plotvals[species_idx] = values / n_balance[i]

        if plotvar == &#39;A&#39;:
            plotvar = &#39;A/(2.303RT)&#39;
            if nd == 1:
                if messages:
                    print(f&#34;diagram: plotting {plotvar} / n.balance&#34;)
    else:
        # Plot equilibrated activities
        # Check for both Python naming (loga_equil) and R naming (loga.equil)
        loga_equil_key = &#39;loga_equil&#39; if &#39;loga_equil&#39; in eout else &#39;loga.equil&#39;
        loga_equil_list = eout[loga_equil_key]

        # For equilibrate output, keep plotvals as a dict with INTEGER indices as keys
        # This preserves the 1:1 correspondence with the species list, including duplicates
        # Do NOT use ispecies as keys because duplicates would overwrite each other
        if isinstance(loga_equil_list, list):
            for i, loga_val in enumerate(loga_equil_list):
                plotvals[i] = loga_val  # Use integer index, not ispecies
        else:
            # Already a dict
            plotvals = loga_equil_list

        plotvar = &#39;loga.equil&#39;

    # Handle alpha (degree of formation)
    if alpha:
        # Convert to activities (remove logarithms)
        # Use numpy arrays for proper element-wise operations
        act_vals = {}
        for k, v in plotvals.items():
            if isinstance(v, np.ndarray):
                act_vals[k] = 10**v
            else:
                act_vals[k] = np.power(10, v)

        # Scale by balance if requested
        if alpha == &#34;balance&#34;:
            species_keys = list(act_vals.keys())
            for i, k in enumerate(species_keys):
                act_vals[k] = act_vals[k] * n_balance[i]

        # Calculate sum of activities (element-wise for arrays)
        # Get the first value to determine shape
        first_val = list(act_vals.values())[0]
        if isinstance(first_val, np.ndarray):
            # Multi-dimensional case
            sum_act = np.zeros_like(first_val)
            for v in act_vals.values():
                sum_act = sum_act + v
        else:
            # Single value case
            sum_act = sum(act_vals.values())

        # Calculate alpha (fraction) - element-wise division
        plotvals = {k: v / sum_act for k, v in act_vals.items()}
        plotvar = &#34;alpha&#34;

    # Get species information for labels
    species_df = eout[&#39;species&#39;]
    if names is None:
        names = species_df[&#39;name&#39;].tolist()

    # Format chemical names if requested
    if format_names and not alpha:
        names = [_format_chemname(name) for name in names]

    # Prepare for plotting
    if nd == 0:
        # 0-D: Bar plot (not implemented yet)
        raise NotImplementedError(&#34;0-D bar plots not yet implemented&#34;)

    elif nd == 1:
        # 1-D: Line plot
        result = _plot_1d(eout, plotvals, plotvar, names, n_balance, balance,
                       xlab, ylab, xlim, ylim, col, lty, lwd, main, add, plot_it, ax, width, height, plot_was_provided, **kwargs)

    elif nd == 2:
        # 2-D: Predominance diagram or saturation lines
        # Pass lty and cex through kwargs for saturation plots
        result = _plot_2d(eout, plotvals, plotvar, names, n_balance, balance,
                       xlab, ylab, xlim, ylim, col, col_names, fill, fill_NA, limit_water, lwd, main, add, plot_it, ax,
                       type, contour_method, messages, width, height, plot_was_provided, lty=lty, cex=cex, **kwargs)

    else:
        raise ValueError(f&#34;Cannot create diagram with {nd} dimensions&#34;)

    # Handle Jupyter display behavior
    # When plot_it=True, we want the figure to display
    # When plot_it=False, we want to suppress display and close the figure
    if not plot_it and result is not None and &#39;fig&#39; in result:
        # Close the figure to prevent auto-display in Jupyter
        # The figure is still in the result dict, so users can access it via result[&#39;fig&#39;]
        # but it won&#39;t be displayed automatically
        plt.close(result[&#39;fig&#39;])
    elif plot_it and result is not None and &#39;fig&#39; in result:
        # Try to use IPython display if available (for Jupyter notebooks)
        try:
            from IPython.display import display
            display(result[&#39;fig&#39;])
        except (ImportError, NameError):
            # Not in IPython/Jupyter, regular matplotlib display
            pass

    return result</code></pre>
</details>
<div class="desc"><p>Plot equilibrium chemical activity and predominance diagrams.</p>
<p>This function creates plots from the output of affinity() or equilibrate().
For 1D diagrams, it produces line plots showing how affinity or activity
varies with a single variable. For 2D diagrams, it creates predominance
field diagrams.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eout</code></strong> :&ensp;<code>dict</code></dt>
<dd>Output from affinity() or equilibrate()</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>str</code>, default <code>"auto"</code></dt>
<dd>Type of diagram:
- "auto" (default): Plot affinity values (A/2.303RT)
- "loga.equil": Plot equilibrium activities from equilibrate()
- "saturation": Draw affinity=0 contour lines (mineral saturation)
- Basis species name (e.g., "O2", "H2O", "CO2"): Plot equilibrium
log activity/fugacity of the specified basis species where affinity=0
for each formed species. Useful for Eh-pH diagrams and showing
oxygen/water fugacities at equilibrium.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>bool</code> or <code>str</code>, default <code>False</code></dt>
<dd>Plot degree of formation instead of activities?
If "balance", scale by balancing coefficients</dd>
<dt><strong><code>balance</code></strong> :&ensp;<code>str, float,</code> or <code>list</code> of <code>float</code>, optional</dt>
<dd>Balancing coefficients or method for balancing reactions</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>Custom names for species (for labels)</dd>
<dt><strong><code>format_names</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Apply formatting to chemical formulas?</dd>
<dt><strong><code>xlab</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom x-axis label</dd>
<dt><strong><code>ylab</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom y-axis label</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>list</code> of <code>float</code>, optional</dt>
<dd>X-axis limits [min, max]</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>float</code>, optional</dt>
<dd>Y-axis limits [min, max]</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, optional</dt>
<dd>Line colors for 1-D plots and boundary lines in 2-D plots (matplotlib color specs)</dd>
<dt><strong><code>col_names</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, optional</dt>
<dd>Text colors for field labels in 2-D plots (matplotlib color specs)</dd>
<dt><strong><code>lty</code></strong> :&ensp;<code>str, int,</code> or <code>list</code>, optional</dt>
<dd>Line styles (matplotlib linestyle specs)</dd>
<dt><strong><code>lwd</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, default <code>1</code></dt>
<dd>Line widths for 1-D plots and boundary lines in 2-D predominance
diagrams. Set to 0 to disable borders in 2-D diagrams. If fill is
None and lwd &gt; 0, uses white fill with black borders (R CHNOSZ default).</dd>
<dt><strong><code>cex</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, default <code>1.0</code></dt>
<dd>Character expansion factor for text labels. Values &gt; 1 make text larger,
values &lt; 1 make text smaller. Can be a single value or a list (one per species).
Used for contour labels in type="saturation" plots.</dd>
<dt><strong><code>main</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Plot title</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Color palette for 2-D predominance diagrams. Can be any matplotlib
colormap name (e.g., 'viridis', 'plasma', 'terrain', 'rainbow',
'Set1', 'tab10', 'Pastel1'). If None, uses discrete colors from
the default color cycle. Ignored for 1-D diagrams.</dd>
<dt><strong><code>fill_NA</code></strong> :&ensp;<code>str</code>, default <code>"0.8"</code></dt>
<dd>Color for regions outside water stability limits (water instability regions).
Matplotlib color specification (e.g., "0.8" for gray, "#CCCCCC").
Set to "transparent" to disable shading. Default "0.8" matches R's "gray80".</dd>
<dt><strong><code>limit_water</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show water stability limits as shaded regions (default True for
2-D diagrams). If True, also clips the diagram to the water stability region.
Set to False to disable water stability shading.</dd>
<dt><strong><code>plot_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display the plot?</dd>
<dt><strong><code>add_to</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>
<p>A diagram result dictionary from a previous diagram() call. When provided,
this plot will be AUTOMATICALLY COPIED and the new diagram will be added to
the copy. This preserves the original plot while creating a modified version.
The axes object is extracted from add_to['ax'].</p>
<p>This parameter eliminates the need for a separate 'add' boolean - when
add_to is provided, the function automatically operates in "add" mode.</p>
<p>Example workflow:</p>
<blockquote>
<blockquote>
<blockquote>
<p>plot_a = diagram(affinity1, fill='terrain')
# Create base plot
plot_a1 = diagram(affinity2, add_to=plot_a, col='blue')
# Copy and add
plot_a2 = diagram(affinity3, add_to=plot_a, col='red')
# Copy and add again</p>
<h1 id="plot_a-remains-unchanged-plot_a1-and-plot_a2-are-independent-modifications">plot_a remains unchanged, plot_a1 and plot_a2 are independent modifications</h1>
</blockquote>
</blockquote>
</blockquote>
</dd>
<dt><strong><code>contour_method</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, optional</dt>
<dd>Method for labeling contour lines. Default "edge" labels at plot edges.
Can be a single value (applied to all species) or a list (one per species).
Set to None, NA, or "" to disable labels (only for type="saturation").
In R CHNOSZ, different methods like "edge", "flattest", "simple" control
label placement; in Python, this mainly controls whether labels are shown.</dd>
<dt><strong><code>interactive</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Create an interactive plot using Plotly instead of matplotlib?
If True, calls diagram_interactive() with the appropriate parameters.</dd>
<dt><strong><code>annotation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>For interactive plots only. Annotation text to add to the plot.</dd>
<dt><strong><code>annotation_coords</code></strong> :&ensp;<code>list</code> of <code>float</code>, default <code>[0, 0]</code></dt>
<dd>For interactive plots only. Coordinates of annotation, where [0, 0] is
bottom left and [1, 1] is top right.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, default <code>600</code></dt>
<dd>For interactive plots only. Width of the plot in pixels.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, default <code>520</code></dt>
<dd>For interactive plots only. Height of the plot in pixels.</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>For interactive plots only. Provide a filename to save this figure.
Filetype is determined by <code>save_format</code>.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>For interactive plots only. Desired format of saved or downloaded figure.
Can be 'png', 'jpg', 'jpeg', 'webp', 'svg', 'pdf', 'eps', 'json', or 'html'.
If 'html', an interactive plot will be saved.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>For interactive plots only. Multiply title/legend/axis/canvas sizes by
this factor when saving the figure.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to matplotlib plotting functions</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing:
- plotvar : str, Variable that was plotted
- plotvals : dict, Values that were plotted
- names : list, Names used for labels
- predominant : array or NA, Predominance matrix (for 2D)
- balance : str or list, Balancing coefficients used
- n.balance : list, Numerical balancing coefficients
- ax : matplotlib.axes.Axes, The axes object used for plotting (if plot_it=True)
- fig : matplotlib.figure.Figure, The figure object used for plotting (if plot_it=True)
- All original eout contents</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.basis([&quot;Fe2O3&quot;, &quot;CO2&quot;, &quot;H2O&quot;, &quot;NH3&quot;, &quot;H2S&quot;, &quot;oxygen&quot;, &quot;H+&quot;],
...              [0, -3, 0, -4, -7, -80, -7])
&gt;&gt;&gt; pychnosz.species([&quot;pyrite&quot;, &quot;goethite&quot;])
&gt;&gt;&gt; a = pychnosz.affinity(H2S=[-60, 20, 5], T=25, P=1)
&gt;&gt;&gt; d = diagram(a)
</code></pre>
<h2 id="notes">Notes</h2>
<p>This implementation is based on R CHNOSZ diagram() function but adapted
for Python's matplotlib plotting instead of R's base graphics. The key
differences from diagram_from_WORM.py are:
- Works directly with Python dict output from affinity() (no rpy2)
- Uses matplotlib for 1D plots by default
- Can optionally use plotly if requested</p></div>
</dd>
<dt id="pychnosz.diagram_interactive"><code class="name flex">
<span>def <span class="ident">diagram_interactive</span></span>(<span>eout: Dict[str, Any],<br>type: str = 'auto',<br>main: str | None = None,<br>borders: float | str = 0,<br>names: List[str] | None = None,<br>format_names: bool = True,<br>annotation: str | None = None,<br>annotation_coords: List[float] = [0, 0],<br>balance: str | float | List[float] | None = None,<br>xlab: str | None = None,<br>ylab: str | None = None,<br>fill: str | List[str] | None = 'viridis',<br>width: int = 600,<br>height: int = 520,<br>alpha: bool | str = False,<br>add: bool = False,<br>ax: Any | None = None,<br>col: str | List[str] | None = None,<br>lty: str | int | List | None = None,<br>lwd: float | List[float] = 1,<br>cex: float | List[float] = 1.0,<br>contour_method: str | List[str] | None = 'edge',<br>messages: bool = True,<br>plot_it: bool = True,<br>save_as: str | None = None,<br>save_format: str | None = None,<br>save_scale: float = 1) ‑> Tuple[pandas.core.frame.DataFrame, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diagram_interactive(eout: Dict[str, Any],
                        type: str = &#34;auto&#34;,
                        main: Optional[str] = None,
                        borders: Union[float, str] = 0,
                        names: Optional[List[str]] = None,
                        format_names: bool = True,
                        annotation: Optional[str] = None,
                        annotation_coords: List[float] = [0, 0],
                        balance: Optional[Union[str, float, List[float]]] = None,
                        xlab: Optional[str] = None,
                        ylab: Optional[str] = None,
                        fill: Optional[Union[str, List[str]]] = &#34;viridis&#34;,
                        width: int = 600,
                        height: int = 520,
                        alpha: Union[bool, str] = False,
                        add: bool = False,
                        ax: Optional[Any] = None,
                        col: Optional[Union[str, List[str]]] = None,
                        lty: Optional[Union[str, int, List]] = None,
                        lwd: Union[float, List[float]] = 1,
                        cex: Union[float, List[float]] = 1.0,
                        contour_method: Optional[Union[str, List[str]]] = &#34;edge&#34;,
                        messages: bool = True,
                        plot_it: bool = True,
                        save_as: Optional[str] = None,
                        save_format: Optional[str] = None,
                        save_scale: float = 1) -&gt; Tuple[pd.DataFrame, Any]:
    &#34;&#34;&#34;
    Create an interactive diagram using Plotly.

    This function produces interactive versions of the diagrams created by diagram(),
    using Plotly for interactivity. It accepts output from affinity() or equilibrate()
    and creates either 1D line plots or 2D predominance diagrams.

    Parameters
    ----------
    eout : dict
        Output from affinity() or equilibrate().
    main : str, optional
        Title of the plot.
    borders : float or str, default 0
        Controls boundary lines between regions in 2D predominance diagrams.
        - If numeric &gt; 0: draws grid-aligned borders with specified thickness (pixels)
        - If &#34;contour&#34;: draws smooth contour-based boundaries (like diagram())
        - If 0 or None: no borders drawn
    names : list of str, optional
        Names of species for activity lines or predominance fields.
    format_names : bool, default True
        Apply formatting to chemical formulas?
    annotation : str, optional
        Annotation to add to the plot.
    annotation_coords : list of float, default [0, 0]
        Coordinates of annotation, where 0,0 is bottom left and 1,1 is top right.
    balance : str or numeric, optional
        How to balance the transformations.
    xlab : str, optional
        Custom x-axis label.
    ylab : str, optional
        Custom y-axis label.
    fill : str or list of str, default &#34;viridis&#34;
        For 2D diagrams: colormap name (e.g., &#34;viridis&#34;, &#34;hot&#34;) or list of colors.
        For 1D diagrams: list of line colors.
    width : int, default 600
        Width of the plot in pixels.
    height : int, default 520
        Height of the plot in pixels.
    alpha : bool or str, default False
        For speciation diagrams, plot degree of formation instead of activities?
        If True, plots mole fractions. If &#34;balance&#34;, scales by stoichiometry.
    messages : bool, default True
        Display messages?
    plot_it : bool, default True
        Show the plot?
    save_as : str, optional
        Provide a filename to save this figure. Filetype of saved figure is
        determined by save_format.
    save_format : str, default &#34;png&#34;
        Desired format of saved or downloaded figure. Can be &#39;png&#39;, &#39;jpg&#39;, &#39;jpeg&#39;,
        &#39;webp&#39;, &#39;svg&#39;, &#39;pdf&#39;, &#39;eps&#39;, &#39;json&#39;, or &#39;html&#39;. If &#39;html&#39;, an interactive
        plot will be saved.
    save_scale : float, default 1
        Multiply title/legend/axis/canvas sizes by this factor when saving.

    Returns
    -------
    tuple
        (df, fig) where df is a pandas DataFrame with the data and fig is the
        Plotly figure object.

    Examples
    --------
    1D diagram:
    &gt;&gt;&gt; basis(&#34;CHNOS+&#34;)
    &gt;&gt;&gt; species(info([&#34;glycinium&#34;, &#34;glycine&#34;, &#34;glycinate&#34;]))
    &gt;&gt;&gt; a = affinity(pH=[0, 14])
    &gt;&gt;&gt; e = equilibrate(a)
    &gt;&gt;&gt; diagram_interactive(e, alpha=True)

    2D diagram:
    &gt;&gt;&gt; basis([&#34;Fe&#34;, &#34;oxygen&#34;, &#34;S2&#34;])
    &gt;&gt;&gt; species([&#34;iron&#34;, &#34;ferrous-oxide&#34;, &#34;magnetite&#34;, &#34;hematite&#34;, &#34;pyrite&#34;, &#34;pyrrhotite&#34;])
    &gt;&gt;&gt; a = affinity(S2=[-50, 0], O2=[-90, -10], T=200)
    &gt;&gt;&gt; diagram_interactive(a, fill=&#34;hot&#34;)

    Notes
    -----
    This function requires plotly to be installed. Install with:
        pip install plotly

    The function adapts the pyCHNOSZ diagram_interactive() implementation
    to work with Python CHNOSZ&#39;s native data structures.
    &#34;&#34;&#34;

    # Import plotly (lazy import to avoid dependency issues)
    try:
        import plotly.express as px
        import plotly.graph_objects as go
        import plotly.io as pio
    except ImportError:
        raise ImportError(&#34;diagram_interactive() requires plotly. Install with: pip install plotly&#34;)

    # Check that eout is valid
    efun = eout.get(&#39;fun&#39;, &#39;&#39;)
    if efun not in [&#39;affinity&#39;, &#39;equilibrate&#39;, &#39;solubility&#39;]:
        raise ValueError(&#34;&#39;eout&#39; is not the output from affinity(), equilibrate(), or solubility()&#34;)

    # Determine if this is affinity or equilibrate output
    calc_type = &#34;a&#34; if (&#39;loga_equil&#39; not in eout and &#39;loga.equil&#39; not in eout) else &#34;e&#34;

    # Get basis species and their states
    basis_df = eout[&#39;basis&#39;]
    basis_sp = list(basis_df.index)
    basis_state = list(basis_df[&#39;state&#39;])

    # Get variable names and values
    xyvars = eout[&#39;vars&#39;]
    xyvals_dict = eout[&#39;vals&#39;]
    # Convert vals dict to list format for easier access
    xyvals = [xyvals_dict[var] for var in xyvars]

    # Determine balance if not provided
    if balance is None or balance == &#34;&#34;:
        # For saturation diagrams, use balance=1 (formula units) to match R behavior
        # This avoids issues when minerals don&#39;t have a common basis element
        if type == &#34;saturation&#34;:
            balance = 1
            n_balance = [1] * len(eout[&#39;values&#39;])
        else:
            # Call diagram with plot_it=False to get balance
            # Need to import matplotlib to close the figure afterward
            import matplotlib.pyplot as plt_temp
            temp_result = diagram(eout, messages=False, plot_it=False)
            balance = temp_result.get(&#39;balance&#39;, 1)
            n_balance = temp_result.get(&#39;n_balance&#39;, [1])
            # Close the matplotlib figure created by diagram() since we don&#39;t need it
            if &#39;fig&#39; in temp_result and temp_result[&#39;fig&#39;] is not None:
                plt_temp.close(temp_result[&#39;fig&#39;])
    else:
        # Calculate n_balance from balance
        try:
            balance_float = float(balance)
            n_balance = [balance_float] * len(eout[&#39;values&#39;])
        except (ValueError, TypeError):
            # balance is a string (element name)
            # Get species from eout instead of global state
            if &#39;species&#39; in eout and eout[&#39;species&#39;] is not None:
                sp_df = eout[&#39;species&#39;]
            else:
                # Fallback to global species if not in eout
                from .species import species as species_func
                sp_df = species_func()

            # Check if balance is a list (user-provided values) or a string (column name)
            if isinstance(balance, list):
                n_balance = balance
            elif balance in sp_df.columns:
                n_balance = list(sp_df[balance])
            else:
                n_balance = [1] * len(eout[&#39;values&#39;])

    # Get output values
    if calc_type == &#34;a&#34;:
        # handling output of affinity()
        out_vals = eout[&#39;values&#39;]
        out_units = &#34;A/(2.303RT)&#34;
    else:
        # handling output of equilibrate()
        loga_equil_key = &#39;loga_equil&#39; if &#39;loga_equil&#39; in eout else &#39;loga.equil&#39;
        out_vals = eout[loga_equil_key]
        out_units = &#34;log a&#34;

    # Convert values to a list format
    if isinstance(out_vals, dict):
        nsp = len(out_vals)
        values_list = list(out_vals.values())
        species_indices = list(out_vals.keys())
    else:
        nsp = len(out_vals)
        values_list = out_vals
        species_indices = eout[&#39;species&#39;][&#39;ispecies&#39;].tolist()

    # Get species names
    from .info import info as info_func
    # Convert numpy types to Python types
    species_indices_py = [int(idx) for idx in species_indices]
    sp_info = info_func(species_indices_py, messages=False)
    sp_names = sp_info[&#39;name&#39;].tolist()

    # Use custom names if provided
    if isinstance(names, list) and len(names) == len(sp_names):
        sp_names = names

    # Determine dimensions
    first_val = values_list[0]
    if hasattr(first_val, &#39;shape&#39;):
        nd = len(first_val.shape)
    else:
        nd = 1 if hasattr(first_val, &#39;__len__&#39;) else 0

    # Handle type=&#34;saturation&#34; - plot contour lines where affinity=0
    if type == &#34;saturation&#34;:
        if nd != 2:
            raise ValueError(&#34;type=&#39;saturation&#39; requires 2-D diagram&#34;)
        if calc_type != &#34;a&#34;:
            raise ValueError(&#34;type=&#39;saturation&#39; requires output from affinity(), not equilibrate()&#34;)

        # Delegate to saturation plotting function
        return _plot_saturation_interactive(
            eout, values_list, sp_names, xyvars, xyvals,
            xlab, ylab, col, lwd, lty, cex, contour_method,
            main, add, ax, width, height, plot_it,
            save_as, save_format, save_scale, messages
        )

    # Build DataFrame
    if nd == 2:
        # 2D case - flatten the data
        xvals = xyvals[0]
        yvals = xyvals[1]
        xvar = xyvars[0]
        yvar = xyvars[1]

        # Flatten the data - transpose first so coordinates match
        # Original shape is (nx, ny) where nx=len(xvals), ny=len(yvals)
        # After transpose, shape is (ny, nx)
        # Flattening with C-order then gives: [row0, row1, ...] = [x-values at y[0], x-values at y[1], ...]
        flat_out_vals = []
        for v in values_list:
            # Transpose then flatten so coordinates align correctly
            flat_out_vals.append(v.T.flatten())
        df = pd.DataFrame(flat_out_vals, index=sp_names).T

        # Apply balance if needed
        if calc_type == &#34;a&#34;:
            if isinstance(balance, str):
                # Get balance from species dataframe
                # Get species from eout instead of global state
                if &#39;species&#39; in eout and eout[&#39;species&#39;] is not None:
                    sp_df = eout[&#39;species&#39;]
                else:
                    # Fallback to global species if not in eout
                    from .species import species as species_func
                    sp_df = species_func()

                # Check if balance is a list (user-provided values) or a string (column name)
                if isinstance(balance, list):
                    n_balance = balance
                elif balance in sp_df.columns:
                    n_balance = list(sp_df[balance])
            # Divide by balance
            for i, sp in enumerate(sp_names):
                df[sp] = df[sp] / n_balance[i]

        # Find predominant species
        df[&#34;pred&#34;] = df.idxmax(axis=1, skipna=True)
        df[&#34;prednames&#34;] = df[&#34;pred&#34;]

        # Add x and y coordinates
        # After transpose and flatten, data is ordered as:
        # [x0,y0], [x1,y0], ..., [xn,y0], [x0,y1], [x1,y1], ...
        xvals_full = list(xvals) * len(yvals)
        yvals_full = []
        for y in yvals:
            yvals_full.extend([y] * len(xvals))
        df[xvar] = xvals_full
        df[yvar] = yvals_full

    else:
        # 1D case
        xvar = xyvars[0]
        xvals = xyvals[0]

        flat_out_vals = []
        for v in values_list:
            flat_out_vals.append(v)
        df = pd.DataFrame(flat_out_vals, index=sp_names).T

        # Apply balance if needed
        if calc_type == &#34;a&#34;:
            if isinstance(balance, str):
                # Get species from eout instead of global state
                if &#39;species&#39; in eout and eout[&#39;species&#39;] is not None:
                    sp_df = eout[&#39;species&#39;]
                else:
                    # Fallback to global species if not in eout
                    from .species import species as species_func
                    sp_df = species_func()

                # Check if balance is a list (user-provided values) or a string (column name)
                if isinstance(balance, list):
                    n_balance = balance
                elif balance in sp_df.columns:
                    n_balance = list(sp_df[balance])
            # Divide by balance
            for i, sp in enumerate(sp_names):
                df[sp] = df[sp] / n_balance[i]

        # Handle alpha (degree of formation)
        if alpha:
            df = df.apply(lambda x: 10**x)
            df = df[sp_names].div(df[sp_names].sum(axis=1), axis=0)

        df[xvar] = xvals

    # Create axis labels
    unit_dict = {&#34;P&#34;: &#34;bar&#34;, &#34;T&#34;: &#34;°C&#34;, &#34;pH&#34;: &#34;&#34;, &#34;Eh&#34;: &#34;volts&#34;, &#34;IS&#34;: &#34;mol/kg&#34;}

    for i, s in enumerate(basis_sp):
        if basis_state[i] in [&#34;aq&#34;, &#34;liq&#34;, &#34;cr&#34;]:
            if format_names:
                unit_dict[s] = f&#34;log &lt;i&gt;a&lt;/i&gt;&lt;sub&gt;{_format_html_species(s)}&lt;/sub&gt;&#34;
            else:
                unit_dict[s] = f&#34;log &lt;i&gt;a&lt;/i&gt;&lt;sub&gt;{s}&lt;/sub&gt;&#34;
        else:
            if format_names:
                unit_dict[s] = f&#34;log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;{_format_html_species(s)}&lt;/sub&gt;&#34;
            else:
                unit_dict[s] = f&#34;log &lt;i&gt;f&lt;/i&gt;&lt;sub&gt;{s}&lt;/sub&gt;&#34;

    # Set x-axis label
    if not isinstance(xlab, str):
        xlab = xvar + &#34;, &#34; + unit_dict.get(xvar, &#34;&#34;)
        if xvar == &#34;pH&#34;:
            xlab = &#34;pH&#34;
        if xvar in basis_sp:
            xlab = unit_dict[xvar]

    # Create the plot
    if nd == 1:
        # 1D plot
        # Melt the dataframe for plotting
        df_melted = pd.melt(df, id_vars=[xvar], value_vars=sp_names, var_name=&#39;variable&#39;, value_name=&#39;value&#39;)

        # Format species names if requested
        if format_names:
            df_melted[&#39;variable&#39;] = df_melted[&#39;variable&#39;].apply(_format_html_species)

        # Set y-axis label
        if not isinstance(ylab, str):
            if alpha:
                ylab = &#34;alpha&#34;
            else:
                ylab = out_units

        fig = px.line(df_melted, x=xvar, y=&#34;value&#34;, color=&#39;variable&#39;,
                      template=&#34;simple_white&#34;, width=width, height=height,
                      labels={&#39;value&#39;: ylab, xvar: xlab},
                      render_mode=&#39;svg&#39;)

        # Apply custom colors if provided
        if isinstance(fill, list):
            for i, color in enumerate(fill):
                if i &lt; len(fig.data):
                    fig.data[i].line.color = color

        # Check for LaTeX format in axis labels
        if xlab and _detect_latex_format(xlab):
            warnings.warn(
                &#34;LaTeX formatting detected in &#39;xlab&#39; parameter. &#34;
                &#34;Plotly requires HTML format (&lt;sub&gt;, &lt;sup&gt;) instead of LaTeX ($, _, ^). &#34;
                &#34;For activity ratios, use ratlab_html() instead of ratlab().&#34;,
                UserWarning
            )
        if ylab and _detect_latex_format(ylab):
            warnings.warn(
                &#34;LaTeX formatting detected in &#39;ylab&#39; parameter. &#34;
                &#34;Plotly requires HTML format (&lt;sub&gt;, &lt;sup&gt;) instead of LaTeX ($, _, ^). &#34;
                &#34;For activity ratios, use ratlab_html() instead of ratlab().&#34;,
                UserWarning
            )

        fig.update_layout(xaxis_title=xlab,
                          yaxis_title=ylab,
                          legend_title=None)

        if isinstance(main, str):
            fig.update_layout(title={&#39;text&#39;: main, &#39;x&#39;: 0.5, &#39;xanchor&#39;: &#39;center&#39;})

        if isinstance(annotation, str):
            # Check for LaTeX format and warn user
            if _detect_latex_format(annotation):
                warnings.warn(
                    &#34;LaTeX formatting detected in &#39;annotation&#39; parameter. &#34;
                    &#34;Plotly requires HTML format (&lt;sub&gt;, &lt;sup&gt;) instead of LaTeX ($, _, ^). &#34;
                    &#34;For activity ratios, use ratlab_html() instead of ratlab().&#34;,
                    UserWarning
                )

            fig.add_annotation(
                x=annotation_coords[0],
                y=annotation_coords[1],
                text=annotation,
                showarrow=False,
                xref=&#34;paper&#34;,
                yref=&#34;paper&#34;,
                align=&#39;left&#39;,
                bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;)

        # Configure download button
        save_as_name, save_format_final = _save_figure(fig, save_as, save_format, save_scale,
                                                        plot_width=width, plot_height=height, ppi=1)

        config = {&#39;displaylogo&#39;: False,
                  &#39;modeBarButtonsToRemove&#39;: [&#39;resetScale2d&#39;, &#39;toggleSpikelines&#39;],
                  &#39;toImageButtonOptions&#39;: {
                      &#39;format&#39;: save_format_final,
                      &#39;filename&#39;: save_as_name,
                      &#39;height&#39;: height,
                      &#39;width&#39;: width,
                      &#39;scale&#39;: save_scale,
                  }}

        # Store config on figure so it persists when fig.show() is called later
        fig._config = fig._config | config

    else:
        # 2D plot
        # Map species names to numeric values
        mappings = {s: lab for s, lab in zip(sp_names, range(len(sp_names)))}
        df[&#39;pred&#39;] = df[&#39;pred&#39;].map(mappings).astype(int)

        # Reshape data
        # Data is flattened as [x0,y0], [x1,y0], ..., [xn,y0], [x0,y1], ...
        # Reshape to (ny, nx) for proper orientation in Plotly
        # Plotly expects data[i,j] to correspond to x[j], y[i]
        data = np.array(df[&#39;pred&#39;])
        shape = (len(yvals), len(xvals))
        dmap = data.reshape(shape)

        data_names = np.array(df[&#39;prednames&#39;])
        dmap_names = data_names.reshape(shape)

        # Set y-axis label
        if not isinstance(ylab, str):
            ylab = yvar + &#34;, &#34; + unit_dict.get(yvar, &#34;&#34;)
            if yvar in basis_sp:
                ylab = unit_dict[yvar]
            if yvar == &#34;pH&#34;:
                ylab = &#34;pH&#34;

        # Check for LaTeX format in axis labels (2D plot)
        if xlab and _detect_latex_format(xlab):
            warnings.warn(
                &#34;LaTeX formatting detected in &#39;xlab&#39; parameter. &#34;
                &#34;Plotly requires HTML format (&lt;sub&gt;, &lt;sup&gt;) instead of LaTeX ($, _, ^). &#34;
                &#34;For activity ratios, use ratlab_html() instead of ratlab().&#34;,
                UserWarning
            )
        if ylab and _detect_latex_format(ylab):
            warnings.warn(
                &#34;LaTeX formatting detected in &#39;ylab&#39; parameter. &#34;
                &#34;Plotly requires HTML format (&lt;sub&gt;, &lt;sup&gt;) instead of LaTeX ($, _, ^). &#34;
                &#34;For activity ratios, use ratlab_html() instead of ratlab().&#34;,
                UserWarning
            )

        # Create heatmap
        fig = px.imshow(dmap, width=width, height=height, aspect=&#34;auto&#34;,
                        labels={&#39;x&#39;: xlab, &#39;y&#39;: ylab, &#39;color&#39;: &#34;region&#34;},
                        x=xvals, y=yvals, template=&#34;simple_white&#34;)

        fig.update(data=[{&#39;customdata&#39;: dmap_names,
                          &#39;hovertemplate&#39;: xlab + &#39;: %{x}&lt;br&gt;&#39; + ylab + &#39;: %{y}&lt;br&gt;Region: %{customdata}&lt;extra&gt;&lt;/extra&gt;&#39;}])

        # Set colormap
        if fill == &#39;none&#39;:
            colormap = [[0, &#39;white&#39;], [1, &#39;white&#39;]]
        elif isinstance(fill, list):
            colmap_temp = []
            for i, v in enumerate(fill):
                colmap_temp.append([i / (len(fill) - 1) if len(fill) &gt; 1 else 0, v])
            colormap = colmap_temp
        else:
            colormap = fill

        fig.update_traces(dict(showscale=False,
                               coloraxis=None,
                               colorscale=colormap),
                          selector={&#39;type&#39;: &#39;heatmap&#39;})

        fig.update_yaxes(autorange=True)

        if isinstance(main, str):
            fig.update_layout(title={&#39;text&#39;: main, &#39;x&#39;: 0.5, &#39;xanchor&#39;: &#39;center&#39;})

        # Add species labels
        for s in sp_names:
            if s in set(df[&#34;prednames&#34;]):
                df_s = df.loc[df[&#34;prednames&#34;] == s]
                namex = df_s[xvar].mean()
                namey = df_s[yvar].mean()

                if format_names:
                    annot_text = _format_html_species(s)
                else:
                    annot_text = str(s)

                fig.add_annotation(x=namex, y=namey,
                                   text=annot_text,
                                   bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;,
                                   showarrow=False)

        if isinstance(annotation, str):
            # Check for LaTeX format and warn user
            if _detect_latex_format(annotation):
                warnings.warn(
                    &#34;LaTeX formatting detected in &#39;annotation&#39; parameter. &#34;
                    &#34;Plotly requires HTML format (&lt;sub&gt;, &lt;sup&gt;) instead of LaTeX ($, _, ^). &#34;
                    &#34;For activity ratios, use ratlab_html() instead of ratlab().&#34;,
                    UserWarning
                )

            fig.add_annotation(
                x=annotation_coords[0],
                y=annotation_coords[1],
                text=annotation,
                showarrow=False,
                xref=&#34;paper&#34;,
                yref=&#34;paper&#34;,
                align=&#39;left&#39;,
                bgcolor=&#34;rgba(255, 255, 255, 0.5)&#34;)

        # Add borders if requested
        if borders == &#34;contour&#34;:
            # Use contour-based boundaries (smooth, like diagram())
            # Draw boundaries using matplotlib contour extraction without filling

            # Get unique species (excluding any that don&#39;t appear)
            unique_species_names = sorted(df[&#34;prednames&#34;].unique())

            # Create a temporary matplotlib figure to extract contour paths
            # We won&#39;t display it, just use it to calculate contours
            temp_fig, temp_ax = plt.subplots()

            # For each species, create a binary mask and extract contours
            for i, sp_name in enumerate(unique_species_names):
                # Create binary mask: 1 where this species predominates, 0 elsewhere
                z = (dmap_names == sp_name).astype(float)

                # Create meshgrid for contour
                X, Y = np.meshgrid(xvals, yvals)

                # Find contours at level 0.5 using matplotlib
                try:
                    cs = temp_ax.contour(X, Y, z, levels=[0.5])

                    # Extract the contour segments
                    # cs.allsegs is a list of lists: [level][segment]
                    for level_segs in cs.allsegs:
                        for segment in level_segs:
                            # segment is an (N, 2) array of (x, y) coordinates
                            # Add as a scatter trace with lines
                            fig.add_trace(
                                go.Scatter(
                                    x=segment[:, 0],
                                    y=segment[:, 1],
                                    mode=&#39;lines&#39;,
                                    line=dict(color=&#39;black&#39;, width=2),
                                    hoverinfo=&#39;skip&#39;,
                                    showlegend=False
                                )
                            )

                    # Clear the temp axes for next species
                    temp_ax.clear()
                except Exception as e:
                    if messages:
                        warnings.warn(f&#34;Could not draw contour for {sp_name}: {e}&#34;)
                    pass  # Skip if contour can&#39;t be drawn

            # Close the temporary figure
            plt.close(temp_fig)

        elif isinstance(borders, (int, float)) and borders &gt; 0:
            unique_x_vals = sorted(list(set(df[xvar])))
            unique_y_vals = sorted(list(set(df[yvar])))

            # Skip border drawing if there are fewer than 2 unique values
            # (single point or single line - no borders to draw between regions)
            if len(unique_x_vals) &lt; 2 or len(unique_y_vals) &lt; 2:
                if messages:
                    warnings.warn(&#34;Skipping border drawing: need at least 2 unique values in each dimension&#34;)
            else:
                def mov_mean(numbers, window_size=2):
                    moving_averages = []
                    for i in range(len(numbers) - window_size + 1):
                        window_average = sum(numbers[i:i + window_size]) / window_size
                        moving_averages.append(window_average)
                    return moving_averages

                x_mov_mean = mov_mean(unique_x_vals)
                y_mov_mean = mov_mean(unique_y_vals)

                x_plot_min = x_mov_mean[0] - (x_mov_mean[1] - x_mov_mean[0])
                y_plot_min = y_mov_mean[0] - (y_mov_mean[1] - y_mov_mean[0])

                x_plot_max = x_mov_mean[-1] + (x_mov_mean[1] - x_mov_mean[0])
                y_plot_max = y_mov_mean[-1] + (y_mov_mean[1] - y_mov_mean[0])

                x_vals_border = [x_plot_min] + x_mov_mean + [x_plot_max]
                y_vals_border = [y_plot_min] + y_mov_mean + [y_plot_max]

                # Find border lines
                def find_line(dmap, row_index):
                    return [i for i in range(len(dmap[row_index]) - 1) if dmap[row_index][i] != dmap[row_index][i + 1]]

                nrows, ncols = dmap.shape
                vlines = [find_line(dmap, row_i) for row_i in range(nrows)]

                dmap_transposed = dmap.transpose()
                nrows_t, ncols_t = dmap_transposed.shape
                hlines = [find_line(dmap_transposed, row_i) for row_i in range(nrows_t)]

                y_coord_list_vertical = []
                x_coord_list_vertical = []
                for i, row in enumerate(vlines):
                    for line in row:
                        x_coord_list_vertical += [x_vals_border[line + 1], x_vals_border[line + 1], np.nan]
                        y_coord_list_vertical += [y_vals_border[i], y_vals_border[i + 1], np.nan]

                y_coord_list_horizontal = []
                x_coord_list_horizontal = []
                for i, col in enumerate(hlines):
                    for line in col:
                        y_coord_list_horizontal += [y_vals_border[line + 1], y_vals_border[line + 1], np.nan]
                        x_coord_list_horizontal += [x_vals_border[i], x_vals_border[i + 1], np.nan]

                fig.add_trace(
                    go.Scatter(
                        mode=&#39;lines&#39;,
                        x=x_coord_list_horizontal,
                        y=y_coord_list_horizontal,
                        line={&#39;width&#39;: borders, &#39;color&#39;: &#39;black&#39;},
                        hoverinfo=&#39;skip&#39;,
                        showlegend=False))

                fig.add_trace(
                    go.Scatter(
                        mode=&#39;lines&#39;,
                        x=x_coord_list_vertical,
                        y=y_coord_list_vertical,
                        line={&#39;width&#39;: borders, &#39;color&#39;: &#39;black&#39;},
                        hoverinfo=&#39;skip&#39;,
                        showlegend=False))

                fig.update_yaxes(range=[min(yvals), max(yvals)], autorange=False, mirror=True)
                fig.update_xaxes(range=[min(xvals), max(xvals)], autorange=False, mirror=True)

        # Configure download button
        save_as_name, save_format_final = _save_figure(fig, save_as, save_format, save_scale,
                                                        plot_width=width, plot_height=height, ppi=1)

        config = {&#39;displaylogo&#39;: False,
                  &#39;modeBarButtonsToRemove&#39;: [&#39;zoom2d&#39;, &#39;pan2d&#39;, &#39;zoomIn2d&#39;, &#39;zoomOut2d&#39;,
                                             &#39;autoScale2d&#39;, &#39;resetScale2d&#39;, &#39;toggleSpikelines&#39;,
                                             &#39;hoverClosestCartesian&#39;, &#39;hoverCompareCartesian&#39;],
                  &#39;toImageButtonOptions&#39;: {
                      &#39;format&#39;: save_format_final,
                      &#39;filename&#39;: save_as_name,
                      &#39;height&#39;: height,
                      &#39;width&#39;: width,
                      &#39;scale&#39;: save_scale,
                  }}

        # Store config on figure so it persists when fig.show() is called later
        fig._config = fig._config | config

    if plot_it:
        fig.show(config=config)

    return df, fig</code></pre>
</details>
<div class="desc"><p>Create an interactive diagram using Plotly.</p>
<p>This function produces interactive versions of the diagrams created by diagram(),
using Plotly for interactivity. It accepts output from affinity() or equilibrate()
and creates either 1D line plots or 2D predominance diagrams.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eout</code></strong> :&ensp;<code>dict</code></dt>
<dd>Output from affinity() or equilibrate().</dd>
<dt><strong><code>main</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Title of the plot.</dd>
<dt><strong><code>borders</code></strong> :&ensp;<code>float</code> or <code>str</code>, default <code>0</code></dt>
<dd>Controls boundary lines between regions in 2D predominance diagrams.
- If numeric &gt; 0: draws grid-aligned borders with specified thickness (pixels)
- If "contour": draws smooth contour-based boundaries (like diagram())
- If 0 or None: no borders drawn</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>Names of species for activity lines or predominance fields.</dd>
<dt><strong><code>format_names</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Apply formatting to chemical formulas?</dd>
<dt><strong><code>annotation</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Annotation to add to the plot.</dd>
<dt><strong><code>annotation_coords</code></strong> :&ensp;<code>list</code> of <code>float</code>, default <code>[0, 0]</code></dt>
<dd>Coordinates of annotation, where 0,0 is bottom left and 1,1 is top right.</dd>
<dt><strong><code>balance</code></strong> :&ensp;<code>str</code> or <code>numeric</code>, optional</dt>
<dd>How to balance the transformations.</dd>
<dt><strong><code>xlab</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom x-axis label.</dd>
<dt><strong><code>ylab</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Custom y-axis label.</dd>
<dt><strong><code>fill</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, default <code>"viridis"</code></dt>
<dd>For 2D diagrams: colormap name (e.g., "viridis", "hot") or list of colors.
For 1D diagrams: list of line colors.</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, default <code>600</code></dt>
<dd>Width of the plot in pixels.</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, default <code>520</code></dt>
<dd>Height of the plot in pixels.</dd>
<dt><strong><code>alpha</code></strong> :&ensp;<code>bool</code> or <code>str</code>, default <code>False</code></dt>
<dd>For speciation diagrams, plot degree of formation instead of activities?
If True, plots mole fractions. If "balance", scales by stoichiometry.</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display messages?</dd>
<dt><strong><code>plot_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show the plot?</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Provide a filename to save this figure. Filetype of saved figure is
determined by save_format.</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Desired format of saved or downloaded figure. Can be 'png', 'jpg', 'jpeg',
'webp', 'svg', 'pdf', 'eps', 'json', or 'html'. If 'html', an interactive
plot will be saved.</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Multiply title/legend/axis/canvas sizes by this factor when saving.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>(df, fig) where df is a pandas DataFrame with the data and fig is the
Plotly figure object.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>1D diagram:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; basis(&quot;CHNOS+&quot;)
&gt;&gt;&gt; species(info([&quot;glycinium&quot;, &quot;glycine&quot;, &quot;glycinate&quot;]))
&gt;&gt;&gt; a = affinity(pH=[0, 14])
&gt;&gt;&gt; e = equilibrate(a)
&gt;&gt;&gt; diagram_interactive(e, alpha=True)
</code></pre>
<p>2D diagram:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; basis([&quot;Fe&quot;, &quot;oxygen&quot;, &quot;S2&quot;])
&gt;&gt;&gt; species([&quot;iron&quot;, &quot;ferrous-oxide&quot;, &quot;magnetite&quot;, &quot;hematite&quot;, &quot;pyrite&quot;, &quot;pyrrhotite&quot;])
&gt;&gt;&gt; a = affinity(S2=[-50, 0], O2=[-90, -10], T=200)
&gt;&gt;&gt; diagram_interactive(a, fill=&quot;hot&quot;)
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function requires plotly to be installed. Install with:
pip install plotly</p>
<p>The function adapts the pyCHNOSZ diagram_interactive() implementation
to work with Python CHNOSZ's native data structures.</p></div>
</dd>
<dt id="pychnosz.dissrxn2logK"><code class="name flex">
<span>def <span class="ident">dissrxn2logK</span></span>(<span>OBIGT, i, Tc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dissrxn2logK(OBIGT, i, Tc):
    
    this_dissrxn = OBIGT.iloc[i, OBIGT.columns.get_loc(&#39;dissrxn&#39;)]
    
    if this_dissrxn == &#34;nan&#34;:
        this_dissrxn = OBIGT.iloc[i, OBIGT.columns.get_loc(&#39;regenerate_dissrxn&#39;)]
    
#     print(OBIGT[&#34;name&#34;][i], this_dissrxn)
    
    try:
        this_dissrxn = this_dissrxn.strip()
        split_dissrxn = this_dissrxn.split(&#34; &#34;)
    except:
        return float(&#39;NaN&#39;)
    
    
    
    coeff = [float(n) for n in split_dissrxn[::2]]
    species = split_dissrxn[1::2]
    try:
        G = sum([float(c*OBIGT.loc[OBIGT[&#34;name&#34;]==sp, &#34;G_TP&#34;].iloc[0]) for c,sp in zip(coeff, species)])
    except:
        G_list = []
        for ii, sp in enumerate(species):
            G_TP = OBIGT.loc[OBIGT[&#34;name&#34;]==sp, &#34;G_TP&#34;]
            if len(G_TP) == 1:
                G_list.append(float(coeff[ii]*OBIGT.loc[OBIGT[&#34;name&#34;]==sp, &#34;G_TP&#34;]))
            else:
                ### check valid polymorph T

                # get polymorph entries of OBIGT that match mineral
                poly_df = copy.copy(OBIGT.loc[OBIGT[&#34;name&#34;]==sp,:])
                # ensure polymorph df is sorted according to cr, cr2, cr3... etc.
                poly_df = poly_df.sort_values(&#34;state&#34;)

                z_Ts = list(poly_df.loc[poly_df[&#34;name&#34;]==sp, &#34;z.T&#34;])

                last_t = float(&#39;-inf&#39;)
                appended=False
                for iii,t in enumerate(z_Ts):

                    if Tc+273.15 &gt; last_t and Tc+273.15 &lt; t:
                        G_list.append(float(coeff[ii]*list(poly_df.loc[poly_df[&#34;name&#34;]==sp, &#34;G_TP&#34;])[iii]))
                        appended=True
                    if not appended and z_Ts[-1] == t:
                        G_list.append(float(coeff[ii]*list(poly_df.loc[poly_df[&#34;name&#34;]==sp, &#34;G_TP&#34;])[iii]))
                    last_t = t

        G = sum(G_list)

    return G2logK(G, Tc)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.entropy"><code class="name flex">
<span>def <span class="ident">entropy</span></span>(<span>formula: str | int | List[str | int]) ‑> float | List[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def entropy(formula: Union[str, int, List[Union[str, int]]]) -&gt; Union[float, List[float]]:
    &#34;&#34;&#34;
    Calculate standard molal entropy of elements in chemical formulas.
    
    Parameters
    ----------
    formula : str, int, or list
        Chemical formula(s) or species index(es)
        
    Returns
    -------
    float or list of float
        Standard entropy(ies) in J/(mol*K)
    &#34;&#34;&#34;
    thermo_obj = thermo()
    if thermo_obj.element is None:
        raise RuntimeError(&#34;Element data not available&#34;)
    
    # Convert to stoichiometric matrix
    compositions = makeup(formula, count_zero=False)
    if not isinstance(compositions, list):
        compositions = [compositions]
    
    entropies = []
    
    for comp in compositions:
        if comp is None:
            entropies.append(np.nan)
            continue
        
        total_entropy = 0.0
        has_na = False
        
        for element, count in comp.items():
            
            # Look up element entropy
            element_data = thermo_obj.element[thermo_obj.element[&#39;element&#39;] == element]
            if len(element_data) == 0:
                warnings.warn(f&#34;Element {element} not available in thermo().element&#34;)
                has_na = True
                continue
            
            element_s = element_data.iloc[0][&#39;s&#39;]
            element_n = element_data.iloc[0][&#39;n&#39;]
            
            if pd.isna(element_s) or pd.isna(element_n):
                has_na = True
                continue
            
            # Entropy per atom
            entropy_per_atom = element_s / element_n
            total_entropy += count * entropy_per_atom
        
        if has_na and total_entropy == 0:
            entropies.append(np.nan)
        else:
            # Convert to Joules (assuming input is in cal)
            entropies.append(total_entropy * 4.184)  # cal to J conversion
    
    if len(entropies) == 1:
        return entropies[0]
    else:
        return entropies</code></pre>
</details>
<div class="desc"><p>Calculate standard molal entropy of elements in chemical formulas.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formula</code></strong> :&ensp;<code>str, int,</code> or <code>list</code></dt>
<dd>Chemical formula(s) or species index(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>list</code> of <code>float</code></dt>
<dd>Standard entropy(ies) in J/(mol*K)</dd>
</dl></div>
</dd>
<dt id="pychnosz.envert"><code class="name flex">
<span>def <span class="ident">envert</span></span>(<span>value: float | numpy.ndarray | List[float], units: str) ‑> float | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def envert(value: Union[float, np.ndarray, List[float]],
           units: str) -&gt; Union[float, np.ndarray]:
    &#34;&#34;&#34;
    Convert values to the specified units from those given in thermo()$opt.

    This function is used internally to convert from the user&#39;s preferred units
    (stored in thermo().opt) to standard internal units.

    Parameters
    ----------
    value : float, ndarray, or list
        Value(s) to convert
    units : str
        Target units (&#39;C&#39;, &#39;K&#39;, &#39;bar&#39;, &#39;MPa&#39;, &#39;J&#39;, &#39;cal&#39;)

    Returns
    -------
    float or ndarray
        Converted value(s)
    &#34;&#34;&#34;

    if not isinstance(value, (int, float, np.ndarray, list)):
        return value

    value = np.asarray(value)

    # Check if first element is numeric
    if value.size &gt; 0 and not np.issubdtype(value.dtype, np.number):
        return value

    units = units.lower()
    opt = thermo().opt

    # Temperature conversions
    if units in [&#39;c&#39;, &#39;k&#39;, &#39;t.units&#39;]:
        if units == &#39;c&#39; and opt[&#39;T.units&#39;] == &#39;K&#39;:
            return convert(value, &#39;c&#39;)
        if units == &#39;k&#39; and opt[&#39;T.units&#39;] == &#39;C&#39;:
            return convert(value, &#39;k&#39;)

    # Energy conversions
    if units in [&#39;j&#39;, &#39;cal&#39;, &#39;e.units&#39;]:
        if units == &#39;j&#39; and opt[&#39;E.units&#39;] == &#39;cal&#39;:
            return convert(value, &#39;j&#39;)
        if units == &#39;cal&#39; and opt[&#39;E.units&#39;] == &#39;J&#39;:
            return convert(value, &#39;cal&#39;)

    # Pressure conversions
    if units in [&#39;bar&#39;, &#39;mpa&#39;, &#39;p.units&#39;]:
        if units == &#39;mpa&#39; and opt[&#39;P.units&#39;] == &#39;bar&#39;:
            return convert(value, &#39;mpa&#39;)
        if units == &#39;bar&#39; and opt[&#39;P.units&#39;] == &#39;MPa&#39;:
            return convert(value, &#39;bar&#39;)

    return value</code></pre>
</details>
<div class="desc"><p>Convert values to the specified units from those given in thermo()$opt.</p>
<p>This function is used internally to convert from the user's preferred units
(stored in thermo().opt) to standard internal units.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>float, ndarray,</code> or <code>list</code></dt>
<dd>Value(s) to convert</dd>
<dt><strong><code>units</code></strong> :&ensp;<code>str</code></dt>
<dd>Target units ('C', 'K', 'bar', 'MPa', 'J', 'cal')</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>ndarray</code></dt>
<dd>Converted value(s)</dd>
</dl></div>
</dd>
<dt id="pychnosz.equilibrate"><code class="name flex">
<span>def <span class="ident">equilibrate</span></span>(<span>aout: Dict[str, Any],<br>balance: str | int | List[float] | None = None,<br>loga_balance: float | List[float] | None = None,<br>ispecies: List[int] | List[bool] | None = None,<br>normalize: bool | List[bool] = False,<br>as_residue: bool = False,<br>method: str | List[str] | None = None,<br>tol: float = np.float64(0.0001220703125),<br>messages: bool = True) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equilibrate(aout: Dict[str, Any],
                balance: Optional[Union[str, int, List[float]]] = None,
                loga_balance: Optional[Union[float, List[float]]] = None,
                ispecies: Optional[Union[List[int], List[bool]]] = None,
                normalize: Union[bool, List[bool]] = False,
                as_residue: bool = False,
                method: Optional[Union[str, List[str]]] = None,
                tol: float = np.finfo(float).eps ** 0.25,
                messages: bool = True) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Calculate equilibrium activities of species from affinities.

    This function calculates the equilibrium activities of species in
    (metastable) equilibrium from the affinities of their formation reactions
    from basis species at given activities.

    Parameters
    ----------
    aout : dict
        Output from affinity() containing chemical affinities
    balance : str, int, or list of float, optional
        Balancing method:
        - None: Autoselect using which_balance()
        - str: Name of basis species to balance on
        - &#34;length&#34;: Balance on protein length (for proteins)
        - &#34;volume&#34;: Balance on standard-state volume
        - 1: Balance on one mole of species (formula units)
        - list: User-defined balancing coefficients
    loga_balance : float or list of float, optional
        Logarithm of total activity of the balancing basis species
        If None, calculated from species initial activities and n.balance
    ispecies : list of int or list of bool, optional
        Indices or boolean mask of species to include in equilibration
        Default: all species except those with state &#34;cr&#34; (crystalline)
    normalize : bool or list of bool, default False
        Normalize formulas by balancing coefficients?
    as_residue : bool, default False
        Use residue basis for proteins?
    method : str or list of str, optional
        Equilibration method:
        - &#34;boltzmann&#34;: Boltzmann distribution (for n.balance = 1)
        - &#34;reaction&#34;: Reaction-based equilibration (general method)
        If None, chooses &#34;boltzmann&#34; if all n.balance == 1, else &#34;reaction&#34;
    tol : float, default np.finfo(float).eps**0.25
        Tolerance for root-finding in reaction method
    messages : bool, default True
        Whether to print informational messages

    Returns
    -------
    dict
        Dictionary containing all aout contents plus:
        - balance : str or list, Balancing description
        - m_balance : list, Molar formula divisors
        - n_balance : list, Balancing coefficients
        - loga_balance : float or array, Log activity of balanced quantity
        - Astar : list of arrays, Normalized affinities
        - loga_equil : list of arrays, Equilibrium log activities

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.basis(&#34;CHNOS&#34;)
    &gt;&gt;&gt; pychnosz.basis(&#34;NH3&#34;, -2)
    &gt;&gt;&gt; pychnosz.species([&#34;alanine&#34;, &#34;glycine&#34;, &#34;serine&#34;])
    &gt;&gt;&gt; a = pychnosz.affinity(NH3=[-80, 60], T=55, P=2000)
    &gt;&gt;&gt; e = pychnosz.equilibrate(a, balance=&#34;CO2&#34;)

    Notes
    -----
    This is a 1:1 replica of the R CHNOSZ equilibrate() function.
    - Handles both Boltzmann and reaction-based equilibration
    - Supports normalization and residue basis for proteins
    - Properly handles crystalline species via predominance diagrams
    - Implements identical balancing logic to R version
    &#34;&#34;&#34;

    # Handle mosaic output (not implemented yet, but keep structure)
    if aout.get(&#39;fun&#39;) == &#39;mosaic&#39;:
        raise NotImplementedError(&#34;mosaic equilibration not yet implemented&#34;)

    # Number of possible species
    # affinity() returns values as a dict with ispecies as keys
    if isinstance(aout[&#39;values&#39;], dict):
        # Convert dict to list ordered by species dataframe
        values_list = []
        for i in range(len(aout[&#39;species&#39;])):
            species_idx = aout[&#39;species&#39;][&#39;ispecies&#39;].iloc[i]
            if species_idx in aout[&#39;values&#39;]:
                values_list.append(aout[&#39;values&#39;][species_idx])
            else:
                # Species not in values dict - use NaN array
                values_list.append(np.array([np.nan]))
        aout[&#39;values&#39;] = values_list

    nspecies = len(aout[&#39;values&#39;])

    # Get the balancing coefficients
    bout = _balance(aout, balance, messages)
    n_balance_orig = bout[&#39;n_balance&#39;].copy()
    n_balance = bout[&#39;n_balance&#39;].copy()
    balance = bout[&#39;balance&#39;]

    # If solids (cr) species are present, find them on a predominance diagram
    iscr = [(&#39;cr&#39; in str(state)) for state in aout[&#39;species&#39;][&#39;state&#39;]]
    ncr = sum(iscr)

    # Set default ispecies to exclude cr species (matching R default)
    if ispecies is None:
        ispecies = [not is_cr for is_cr in iscr]

    if ncr &gt; 0:
        # Import diagram here to avoid circular imports
        from .diagram import diagram
        dout = diagram(aout, balance=balance, normalize=normalize,
                      as_residue=as_residue, plot_it=False, limit_water=False, messages=messages)

    if ncr == nspecies:
        # We get here if there are only solids
        m_balance = None
        Astar = None
        loga_equil = []
        for i in range(len(aout[&#39;values&#39;])):
            la = np.array(aout[&#39;values&#39;][i], copy=True)
            la[:] = np.nan
            loga_equil.append(la)
    else:
        # We get here if there are any aqueous species
        # Take selected species in &#39;ispecies&#39;
        if len(ispecies) == 0:
            raise ValueError(&#34;the length of ispecies is zero&#34;)

        # Convert boolean to indices if needed
        if isinstance(ispecies, list) and len(ispecies) &gt; 0:
            if isinstance(ispecies[0], bool):
                ispecies = [i for i, x in enumerate(ispecies) if x]

        # Take out species that have NA affinities
        ina = [all(np.isnan(np.array(x).flatten())) for x in aout[&#39;values&#39;]]
        ispecies = [i for i in ispecies if not ina[i]]

        if len(ispecies) == 0:
            raise ValueError(&#34;all species have NA affinities&#34;)

        if ispecies != list(range(nspecies)):
            if messages:
                print(f&#34;equilibrate: using {len(ispecies)} of {nspecies} species&#34;)
            aout_species_df = aout[&#39;species&#39;]
            aout[&#39;species&#39;] = aout_species_df.iloc[ispecies].reset_index(drop=True)
            aout[&#39;values&#39;] = [aout[&#39;values&#39;][i] for i in ispecies]
            n_balance = [n_balance[i] for i in ispecies]

        # Number of species that are left
        nspecies = len(aout[&#39;values&#39;])

        # Say what the balancing coefficients are
        if len(n_balance) &lt; 100:
            if messages:
                print(f&#34;equilibrate: n.balance is {&#39;, &#39;.join(map(str, n_balance))}&#34;)

        # Logarithm of total activity of the balancing basis species
        if loga_balance is None:
            # Sum up the activities, then take absolute value
            # in case n.balance is negative
            logact = np.array([aout[&#39;species&#39;][&#39;logact&#39;].iloc[i] for i in range(len(aout[&#39;species&#39;]))])
            sumact = abs(sum(10**logact * n_balance))
            loga_balance = np.log10(sumact)

        # Make loga.balance the same length as the values of affinity
        if isinstance(loga_balance, (int, float)):
            loga_balance = float(loga_balance)
        else:
            loga_balance = np.array(loga_balance).flatten()

        nvalues = len(np.array(aout[&#39;values&#39;][0]).flatten())

        if isinstance(loga_balance, float) or len(np.atleast_1d(loga_balance)) == 1:
            # We have a constant loga.balance
            if isinstance(loga_balance, np.ndarray):
                loga_balance = float(loga_balance[0])
            if messages:
                print(f&#34;equilibrate: loga.balance is {loga_balance}&#34;)
            loga_balance = np.full(nvalues, loga_balance)
        else:
            # We are using a variable loga.balance (supplied by the user)
            if len(loga_balance) != nvalues:
                raise ValueError(f&#34;length of loga.balance ({len(loga_balance)}) doesn&#39;t match &#34;
                               f&#34;the affinity values ({nvalues})&#34;)
            if messages:
                print(f&#34;equilibrate: loga.balance has same length as affinity values ({len(loga_balance)})&#34;)

        # Normalize the molar formula by the balance coefficients
        m_balance = n_balance.copy()
        isprotein = [&#39;_&#39; in str(name) for name in aout[&#39;species&#39;][&#39;name&#39;]]

        # Handle normalize parameter
        if isinstance(normalize, bool):
            normalize = [normalize] * nspecies
        elif not isinstance(normalize, list):
            normalize = list(normalize)

        if any(normalize) or as_residue:
            if any(n &lt; 0 for n in n_balance):
                raise ValueError(&#34;one or more negative balancing coefficients prohibit using normalized molar formulas&#34;)

            for i in range(nspecies):
                if normalize[i] or as_residue:
                    n_balance[i] = 1

            if as_residue:
                if messages:
                    print(&#34;equilibrate: using &#39;as.residue&#39; for molar formulas&#34;)
            else:
                if messages:
                    print(&#34;equilibrate: using &#39;normalize&#39; for molar formulas&#34;)

            # Set the formula divisor (m.balance) to 1 for species whose formulas are *not* normalized
            m_balance = [m_balance[i] if (normalize[i] or as_residue) else 1
                        for i in range(nspecies)]
        else:
            m_balance = [1] * nspecies

        # Astar: the affinities/2.303RT of formation reactions with
        # formed species in their standard-state activities
        Astar = []
        for i in range(nspecies):
            # &#39;starve&#39; the affinity of the activity of the species,
            # and normalize the value by the molar ratio
            logact_i = aout[&#39;species&#39;][&#39;logact&#39;].iloc[i]
            astar_i = (np.array(aout[&#39;values&#39;][i]) + logact_i) / m_balance[i]
            Astar.append(astar_i)

        # Choose a method and compute the equilibrium activities of species
        if method is None:
            if all(n == 1 for n in n_balance):
                method = [&#34;boltzmann&#34;]
            else:
                method = [&#34;reaction&#34;]
        elif isinstance(method, str):
            method = [method]

        if messages:
            print(f&#34;equilibrate: using {method[0]} method&#34;)

        if method[0] == &#34;boltzmann&#34;:
            loga_equil = equil_boltzmann(Astar, n_balance, loga_balance)
        elif method[0] == &#34;reaction&#34;:
            loga_equil = equil_reaction(Astar, n_balance, loga_balance, tol)
        else:
            raise ValueError(f&#34;unknown method: {method[0]}&#34;)

        # If we normalized the formulas, get back to activities of species
        if any(normalize) and not as_residue:
            loga_equil = [loga_equil[i] - np.log10(m_balance[i])
                         for i in range(nspecies)]

    # Process cr species
    if ncr &gt; 0:
        # cr species were excluded from equilibrium calculation,
        # so get values back to original lengths
        norig = len(dout[&#39;values&#39;])
        n_balance = n_balance_orig

        # Ensure ispecies is in index form (not boolean)
        # When ncr == nspecies, ispecies was never converted from boolean to indices
        if isinstance(ispecies, list) and len(ispecies) &gt; 0:
            if isinstance(ispecies[0], bool):
                ispecies = [i for i, x in enumerate(ispecies) if x]

        # Match indices back to original
        imatch = [None] * norig
        for j, orig_idx in enumerate(range(norig)):
            if orig_idx in ispecies:
                imatch[orig_idx] = ispecies.index(orig_idx)

        # Handle None values (when ncr == nspecies, these are set to None)
        # In R, indexing NULL returns NULL, so we need to check for None in Python
        if m_balance is not None:
            m_balance = [m_balance[imatch[i]] if imatch[i] is not None else None
                        for i in range(norig)]
        if Astar is not None:
            Astar = [Astar[imatch[i]] if imatch[i] is not None else None
                    for i in range(norig)]

        # Get a template from first loga_equil to determine shape
        loga_equil1 = loga_equil[0]
        loga_equil_orig = [None] * norig

        for i in range(norig):
            if imatch[i] is not None:
                loga_equil_orig[i] = loga_equil[imatch[i]]

        # Replace None loga_equil with -999 for cr-only species (will be set to 0 where predominant)
        # Use np.full with shape, not full_like, to avoid inheriting NaN values
        ina = [i for i in range(norig) if imatch[i] is None]
        for i in ina:
            loga_equil_orig[i] = np.full(loga_equil1.shape, -999.0)
        loga_equil = loga_equil_orig
        aout[&#39;species&#39;] = dout[&#39;species&#39;]
        aout[&#39;values&#39;] = dout[&#39;values&#39;]

        # Find the grid points where any cr species is predominant
        icr = [i for i in range(len(dout[&#39;species&#39;]))
               if &#39;cr&#39; in str(dout[&#39;species&#39;][&#39;state&#39;].iloc[i])]

        # predominant uses 1-based R indexing (1, 2, 3, ...), convert to 0-based for Python
        predominant = dout[&#39;predominant&#39;]
        iscr_mask = np.zeros_like(predominant, dtype=bool)
        for icr_idx in icr:
            # Compare with icr_idx + 1 because predominant is 1-based
            iscr_mask |= (predominant == icr_idx + 1)

        # At those grid points, make the aqueous species&#39; activities practically zero
        for i in range(norig):
            if i not in icr:
                loga_equil[i] = np.array(loga_equil[i], copy=True)
                loga_equil[i][iscr_mask] = -999

        # At the grid points where cr species predominate, set their loga_equil to 0 (standard state)
        for i in icr:
            # Compare with i + 1 because predominant is 1-based
            ispredom = (predominant == i + 1)
            loga_equil[i] = np.array(loga_equil[i], copy=True)
            # Set to standard state activity (logact, typically 0) where predominant
            loga_equil[i][ispredom] = dout[&#39;species&#39;][&#39;logact&#39;].iloc[i]

    # Put together the output
    out = aout.copy()
    out[&#39;fun&#39;] = &#39;equilibrate&#39;  # Mark this as equilibrate output
    out[&#39;balance&#39;] = balance
    out[&#39;m_balance&#39;] = m_balance
    out[&#39;n_balance&#39;] = n_balance
    out[&#39;loga_balance&#39;] = loga_balance
    out[&#39;Astar&#39;] = Astar
    out[&#39;loga_equil&#39;] = loga_equil

    return out</code></pre>
</details>
<div class="desc"><p>Calculate equilibrium activities of species from affinities.</p>
<p>This function calculates the equilibrium activities of species in
(metastable) equilibrium from the affinities of their formation reactions
from basis species at given activities.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>aout</code></strong> :&ensp;<code>dict</code></dt>
<dd>Output from affinity() containing chemical affinities</dd>
<dt><strong><code>balance</code></strong> :&ensp;<code>str, int,</code> or <code>list</code> of <code>float</code>, optional</dt>
<dd>Balancing method:
- None: Autoselect using which_balance()
- str: Name of basis species to balance on
- "length": Balance on protein length (for proteins)
- "volume": Balance on standard-state volume
- 1: Balance on one mole of species (formula units)
- list: User-defined balancing coefficients</dd>
<dt><strong><code>loga_balance</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, optional</dt>
<dd>Logarithm of total activity of the balancing basis species
If None, calculated from species initial activities and n.balance</dd>
<dt><strong><code>ispecies</code></strong> :&ensp;<code>list</code> of <code>int</code> or <code>list</code> of <code>bool</code>, optional</dt>
<dd>Indices or boolean mask of species to include in equilibration
Default: all species except those with state "cr" (crystalline)</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code> or <code>list</code> of <code>bool</code>, default <code>False</code></dt>
<dd>Normalize formulas by balancing coefficients?</dd>
<dt><strong><code>as_residue</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Use residue basis for proteins?</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, optional</dt>
<dd>Equilibration method:
- "boltzmann": Boltzmann distribution (for n.balance = 1)
- "reaction": Reaction-based equilibration (general method)
If None, chooses "boltzmann" if all n.balance == 1, else "reaction"</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, default <code>np.finfo(float).eps**0.25</code></dt>
<dd>Tolerance for root-finding in reaction method</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing all aout contents plus:
- balance : str or list, Balancing description
- m_balance : list, Molar formula divisors
- n_balance : list, Balancing coefficients
- loga_balance : float or array, Log activity of balanced quantity
- Astar : list of arrays, Normalized affinities
- loga_equil : list of arrays, Equilibrium log activities</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.basis(&quot;CHNOS&quot;)
&gt;&gt;&gt; pychnosz.basis(&quot;NH3&quot;, -2)
&gt;&gt;&gt; pychnosz.species([&quot;alanine&quot;, &quot;glycine&quot;, &quot;serine&quot;])
&gt;&gt;&gt; a = pychnosz.affinity(NH3=[-80, 60], T=55, P=2000)
&gt;&gt;&gt; e = pychnosz.equilibrate(a, balance=&quot;CO2&quot;)
</code></pre>
<h2 id="notes">Notes</h2>
<p>This is a 1:1 replica of the R CHNOSZ equilibrate() function.
- Handles both Boltzmann and reaction-based equilibration
- Supports normalization and residue basis for proteins
- Properly handles crystalline species via predominance diagrams
- Implements identical balancing logic to R version</p></div>
</dd>
<dt id="pychnosz.expr_species"><code class="name flex">
<span>def <span class="ident">expr_species</span></span>(<span>formula: str, state: str | None = None, use_state: bool = False) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expr_species(formula: str, state: Optional[str] = None, use_state: bool = False) -&gt; str:
    &#34;&#34;&#34;
    Format a chemical species formula for display.

    This is a simplified version that returns LaTeX-formatted strings
    suitable for matplotlib. The R version returns plotmath expressions.

    Parameters
    ----------
    formula : str
        Chemical formula
    state : str, optional
        Physical state (aq, cr, gas, liq)
    use_state : bool, default False
        Whether to include state in the formatted output

    Returns
    -------
    str
        LaTeX-formatted formula string

    Examples
    --------
    &gt;&gt;&gt; expr_species(&#34;H2O&#34;)
    &#39;$H_{2}O$&#39;

    &gt;&gt;&gt; expr_species(&#34;Ca+2&#34;)
    &#39;$Ca^{2+}$&#39;

    &gt;&gt;&gt; expr_species(&#34;SO4-2&#34;)
    &#39;$SO_{4}^{2-}$&#39;
    &#34;&#34;&#34;
    formatted = _format_species_latex(formula)

    if use_state and state:
        # Add state subscript
        return f&#34;${formatted}_{{{state}}}$&#34;
    else:
        return f&#34;${formatted}$&#34;</code></pre>
</details>
<div class="desc"><p>Format a chemical species formula for display.</p>
<p>This is a simplified version that returns LaTeX-formatted strings
suitable for matplotlib. The R version returns plotmath expressions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>Chemical formula</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Physical state (aq, cr, gas, liq)</dd>
<dt><strong><code>use_state</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Whether to include state in the formatted output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>LaTeX-formatted formula string</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; expr_species(&quot;H2O&quot;)
'$H_{2}O$'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; expr_species(&quot;Ca+2&quot;)
'$Ca^{2+}$'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; expr_species(&quot;SO4-2&quot;)
'$SO_{4}^{2-}$'
</code></pre></div>
</dd>
<dt id="pychnosz.find_tp"><code class="name flex">
<span>def <span class="ident">find_tp</span></span>(<span>predominant: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_tp(predominant: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Find triple points in a predominance diagram.

    This function identifies the approximate positions of triple points
    (where three phases meet) in a 2-D predominance diagram by locating
    cells with the greatest number of different neighboring values.

    Parameters
    ----------
    predominant : np.ndarray
        Matrix of integers from diagram() output indicating which species
        predominates at each point. Should be a 2-D array where each value
        represents a different species/phase.

    Returns
    -------
    np.ndarray
        Array of shape (n, 2) where n is the number of triple points found.
        Each row contains [row_index, col_index] of a triple point location.
        Indices are 1-based to match R behavior.

    Examples
    --------
    &gt;&gt;&gt; from pychnosz import *
    &gt;&gt;&gt; reset()
    &gt;&gt;&gt; basis([&#34;corundum&#34;, &#34;quartz&#34;, &#34;oxygen&#34;])
    &gt;&gt;&gt; species([&#34;kyanite&#34;, &#34;sillimanite&#34;, &#34;andalusite&#34;])
    &gt;&gt;&gt; a = affinity(T=[200, 900, 99], P=[0, 9000, 101], exceed_Ttr=True)
    &gt;&gt;&gt; d = diagram(a)
    &gt;&gt;&gt; tp = find_tp(d[&#39;predominant&#39;])
    &gt;&gt;&gt; # Get T and P at the triple point
    &gt;&gt;&gt; Ttp = a[&#39;vals&#39;][0][tp[0, 1] - 1]  # -1 for 0-based indexing
    &gt;&gt;&gt; Ptp = a[&#39;vals&#39;][1][::-1][tp[0, 0] - 1]  # reversed and -1

    Notes
    -----
    This is a Python translation of the R function find.tp() from CHNOSZ.
    The R version returns 1-based indices, and this Python version does too
    for consistency. When using these indices to access Python arrays,
    remember to subtract 1.

    The function works by:
    1. Rearranging the matrix as done by diagram() for plotting
    2. For each position, examining a 3x3 neighborhood
    3. Counting the number of unique values in that neighborhood
    4. Returning positions with the maximum count (typically 3 or more)
    &#34;&#34;&#34;
    # Rearrange the matrix in the same way that diagram() does for 2-D predominance diagrams
    # R code: x &lt;- t(x[, ncol(x):1])
    # This means: first reverse columns, then transpose
    x = np.transpose(predominant[:, ::-1])

    # Get all positions with valid values (&gt; 0)
    valid_positions = np.argwhere(x &gt; 0)

    if len(valid_positions) == 0:
        return np.array([])

    # For each position, count unique values in 3x3 neighborhood
    counts = []
    for pos in valid_positions:
        row, col = pos

        # Define the range to look at (3x3 except at edges)
        r1 = max(row - 1, 0)
        r2 = min(row + 1, x.shape[0] - 1)
        c1 = max(col - 1, 0)
        c2 = min(col + 1, x.shape[1] - 1)

        # Extract the neighborhood
        neighborhood = x[r1:r2+1, c1:c2+1]

        # Count unique values
        n_unique = len(np.unique(neighborhood))
        counts.append(n_unique)

    counts = np.array(counts)

    # Find positions with the maximum count
    max_count = np.max(counts)
    max_positions = valid_positions[counts == max_count]

    # Convert to 1-based indexing (to match R)
    # Return as [row, col] with 1-based indices
    result = max_positions + 1

    return result</code></pre>
</details>
<div class="desc"><p>Find triple points in a predominance diagram.</p>
<p>This function identifies the approximate positions of triple points
(where three phases meet) in a 2-D predominance diagram by locating
cells with the greatest number of different neighboring values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>predominant</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Matrix of integers from diagram() output indicating which species
predominates at each point. Should be a 2-D array where each value
represents a different species/phase.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Array of shape (n, 2) where n is the number of triple points found.
Each row contains [row_index, col_index] of a triple point location.
Indices are 1-based to match R behavior.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz import *
&gt;&gt;&gt; reset()
&gt;&gt;&gt; basis([&quot;corundum&quot;, &quot;quartz&quot;, &quot;oxygen&quot;])
&gt;&gt;&gt; species([&quot;kyanite&quot;, &quot;sillimanite&quot;, &quot;andalusite&quot;])
&gt;&gt;&gt; a = affinity(T=[200, 900, 99], P=[0, 9000, 101], exceed_Ttr=True)
&gt;&gt;&gt; d = diagram(a)
&gt;&gt;&gt; tp = find_tp(d['predominant'])
&gt;&gt;&gt; # Get T and P at the triple point
&gt;&gt;&gt; Ttp = a['vals'][0][tp[0, 1] - 1]  # -1 for 0-based indexing
&gt;&gt;&gt; Ptp = a['vals'][1][::-1][tp[0, 0] - 1]  # reversed and -1
</code></pre>
<h2 id="notes">Notes</h2>
<p>This is a Python translation of the R function find.tp() from CHNOSZ.
The R version returns 1-based indices, and this Python version does too
for consistency. When using these indices to access Python arrays,
remember to subtract 1.</p>
<p>The function works by:
1. Rearranging the matrix as done by diagram() for plotting
2. For each position, examining a 3x3 neighborhood
3. Counting the number of unique values in that neighborhood
4. Returning positions with the maximum count (typically 3 or more)</p></div>
</dd>
<dt id="pychnosz.format_reaction"><code class="name flex">
<span>def <span class="ident">format_reaction</span></span>(<span>species: List[str | int], coeffs: List[float]) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_reaction(species: List[Union[str, int]], coeffs: List[float]) -&gt; str:
    &#34;&#34;&#34;
    Format a reaction as a string for EQ3/6 input.

    Parameters
    ----------
    species : list
        Species names or indices
    coeffs : list
        Stoichiometric coefficients

    Returns
    -------
    str
        Formatted reaction string like &#34;-1.0000 Fe+3 1.0000 Fe+2 0.2500 O2(g)&#34;
    &#34;&#34;&#34;
    thermo_sys = thermo()
    parts = []

    for sp, coeff in zip(species, coeffs):
        # Get species name if we have an index
        if isinstance(sp, (int, np.integer)):
            sp_name = thermo_sys.obigt.loc[int(sp)][&#39;name&#39;]
        else:
            sp_name = sp

        # Replace &#39;water&#39; with &#39;H2O&#39; for EQ3 compatibility
        if sp_name == &#39;water&#39;:
            sp_name = &#39;H2O&#39;

        parts.append(f&#34;{coeff:.4f}&#34;)
        parts.append(sp_name)

    return &#34; &#34;.join(parts)</code></pre>
</details>
<div class="desc"><p>Format a reaction as a string for EQ3/6 input.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species</code></strong> :&ensp;<code>list</code></dt>
<dd>Species names or indices</dd>
<dt><strong><code>coeffs</code></strong> :&ensp;<code>list</code></dt>
<dd>Stoichiometric coefficients</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Formatted reaction string like "-1.0000 Fe+3 1.0000 Fe+2 0.2500 O2(g)"</dd>
</dl></div>
</dd>
<dt id="pychnosz.get_formula_ox"><code class="name flex">
<span>def <span class="ident">get_formula_ox</span></span>(<span>name: str | int) ‑> Dict[str, float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_formula_ox(name: Union[str, int]) -&gt; Dict[str, float]:
    &#34;&#34;&#34;
    Get quantities of elements and their oxidation states in a chemical compound.

    This function only works when a thermodynamic database with the &#39;formula_ox&#39;
    column is loaded (e.g., the WORM database). For example, an input of &#34;magnetite&#34;
    would return the following: {&#39;Fe+3&#39;: 2.0, &#39;Fe+2&#39;: 1.0, &#39;O-2&#39;: 4.0}.

    Parameters
    ----------
    name : str or int
        The name or database index of the chemical species of interest. Example:
        &#34;magnetite&#34; or 738.

    Returns
    -------
    dict
        A dictionary where each key represents an element in a specific
        oxidation state, and its value is the number of that element in the
        chemical species&#39; formula.

    Raises
    ------
    TypeError
        If input is not a string or integer.
    AttributeError
        If the WORM thermodynamic database is not loaded (no formula_ox attribute).
    ValueError
        If the species is not found in the database or does not have oxidation
        state information.

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; # Load the WORM database
    &gt;&gt;&gt; pychnosz.thermo(&#34;WORM&#34;)
    &gt;&gt;&gt; # Get formula with oxidation states for magnetite
    &gt;&gt;&gt; pychnosz.get_formula_ox(&#34;magnetite&#34;)
    {&#39;Fe+3&#39;: 2.0, &#39;Fe+2&#39;: 1.0, &#39;O-2&#39;: 4.0}
    &gt;&gt;&gt; # Can also use species index
    &gt;&gt;&gt; pychnosz.get_formula_ox(738)
    {&#39;Fe+3&#39;: 2.0, &#39;Fe+2&#39;: 1.0, &#39;O-2&#39;: 4.0}

    Notes
    -----
    This function requires the wormutils package to be installed for parsing
    the formula_ox strings. Install it with: pip install wormutils
    &#34;&#34;&#34;

    # Import parse_formula_ox from wormutils
    try:
        from wormutils import parse_formula_ox
    except ImportError:
        raise ImportError(
            &#34;The wormutils package is required to use get_formula_ox(). &#34;
            &#34;Install it with: pip install wormutils&#34;
        )

    # Validate input type
    if not isinstance(name, str) and not isinstance(name, int):
        raise TypeError(
            &#34;Must provide input as a string (chemical species name) or &#34;
            &#34;an integer (chemical species index).&#34;
        )

    # Get the thermo system
    thermo_sys = thermo()

    # Convert index to name if necessary
    if isinstance(name, int):
        species_info = info(name, messages=False)
        if species_info is None or len(species_info) == 0:
            raise ValueError(f&#34;Species index {name} not found in the database.&#34;)
        name = species_info.name.iloc[0]

    # Check if formula_ox exists in thermo()
    if not hasattr(thermo_sys, &#39;formula_ox&#39;) or thermo_sys.formula_ox is None:
        raise AttributeError(
            &#34;The &#39;formula_ox&#39; attribute is not available. &#34;
            &#34;This function only works when the WORM thermodynamic database &#34;
            &#34;is loaded. Load it with: pychnosz.thermo(&#39;WORM&#39;)&#34;
        )

    df = thermo_sys.formula_ox

    # Check if the species name exists in the database
    if name not in list(df[&#34;name&#34;]):
        raise ValueError(
            f&#34;The species &#39;{name}&#39; was not found in the loaded thermodynamic database.&#34;
        )

    # Get the formula_ox string for this species
    try:
        formula_ox_str = df[df[&#34;name&#34;] == name][&#34;formula_ox&#34;].iloc[0]
    except (KeyError, IndexError):
        raise ValueError(
            f&#34;The species &#39;{name}&#39; does not have elemental oxidation states &#34;
            &#34;given in the &#39;formula_ox&#39; column of the loaded thermodynamic database.&#34;
        )

    # Check if formula_ox is valid (not NaN or empty)
    if formula_ox_str is None or (isinstance(formula_ox_str, float) and pd.isna(formula_ox_str)) or formula_ox_str == &#34;&#34;:
        raise ValueError(
            f&#34;The species &#39;{name}&#39; does not have elemental oxidation states &#34;
            &#34;given in the &#39;formula_ox&#39; column of the loaded thermodynamic database.&#34;
        )

    # Parse the formula_ox string and return
    return parse_formula_ox(formula_ox_str)</code></pre>
</details>
<div class="desc"><p>Get quantities of elements and their oxidation states in a chemical compound.</p>
<p>This function only works when a thermodynamic database with the 'formula_ox'
column is loaded (e.g., the WORM database). For example, an input of "magnetite"
would return the following: {'Fe+3': 2.0, 'Fe+2': 1.0, 'O-2': 4.0}.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code> or <code>int</code></dt>
<dd>The name or database index of the chemical species of interest. Example:
"magnetite" or 738.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>A dictionary where each key represents an element in a specific
oxidation state, and its value is the number of that element in the
chemical species' formula.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>If input is not a string or integer.</dd>
<dt><code>AttributeError</code></dt>
<dd>If the WORM thermodynamic database is not loaded (no formula_ox attribute).</dd>
<dt><code>ValueError</code></dt>
<dd>If the species is not found in the database or does not have oxidation
state information.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; # Load the WORM database
&gt;&gt;&gt; pychnosz.thermo(&quot;WORM&quot;)
&gt;&gt;&gt; # Get formula with oxidation states for magnetite
&gt;&gt;&gt; pychnosz.get_formula_ox(&quot;magnetite&quot;)
{'Fe+3': 2.0, 'Fe+2': 1.0, 'O-2': 4.0}
&gt;&gt;&gt; # Can also use species index
&gt;&gt;&gt; pychnosz.get_formula_ox(738)
{'Fe+3': 2.0, 'Fe+2': 1.0, 'O-2': 4.0}
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function requires the wormutils package to be installed for parsing
the formula_ox strings. Install it with: pip install wormutils</p></div>
</dd>
<dt id="pychnosz.get_n_element_ox"><code class="name flex">
<span>def <span class="ident">get_n_element_ox</span></span>(<span>names: str | int | List[str | int] | pandas.core.series.Series,<br>element_ox: str,<br>binary: bool = False) ‑> List[float | bool]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_n_element_ox(names: Union[str, int, List[Union[str, int]], pd.Series],
                     element_ox: str,
                     binary: bool = False) -&gt; List[Union[float, bool]]:
    &#34;&#34;&#34;
    Get the number of an element of a chosen oxidation state in chemical species formulas.

    This function only works when a thermodynamic database with the &#39;formula_ox&#39;
    column is loaded (e.g., the WORM database).

    If binary is False, returns a list containing the number of the chosen
    element and oxidation state in the chemical species. For example, how many
    ferrous irons are in the formulae of hematite, fayalite, and magnetite,
    respectively?

    &gt;&gt;&gt; get_n_element_ox(names=[&#34;hematite&#34;, &#34;fayalite&#34;, &#34;magnetite&#34;],
    ...                  element_ox=&#34;Fe+2&#34;,
    ...                  binary=False)
    [0, 2.0, 1.0]

    If binary is True, returns a list of whether or not ferrous iron is in their
    formulas:

    &gt;&gt;&gt; get_n_element_ox(names=[&#34;hematite&#34;, &#34;fayalite&#34;, &#34;magnetite&#34;],
    ...                  element_ox=&#34;Fe+2&#34;,
    ...                  binary=True)
    [False, True, True]

    Parameters
    ----------
    names : str, int, list of str/int, or pd.Series
        The name or database index of a chemical species, or a list of
        names or indices. Can also be a pandas Series (e.g., from retrieve()).
        Example: [&#34;hematite&#34;, &#34;fayalite&#34;, &#34;magnetite&#34;] or [788, 782, 798].
    element_ox : str
        An element with a specific oxidation state. For example: &#34;Fe+2&#34; for
        ferrous iron.
    binary : bool, default False
        Should the output list show True/False for presence or absence of the
        element defined by `element_ox`? By default, this parameter is set to
        False so the output list shows quantities of the element instead.

    Returns
    -------
    list of float or list of bool
        A list containing quantities of the chosen element oxidation state in
        the formulas of the chemical species (if `binary=False`) or whether the
        chosen element oxidation state is present in the formulae (if `binary=True`).

    Raises
    ------
    AttributeError
        If the WORM thermodynamic database is not loaded (no formula_ox attribute).
    ValueError
        If a species is not found in the database or does not have oxidation
        state information.

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; # Load the WORM database
    &gt;&gt;&gt; pychnosz.thermo(&#34;WORM&#34;)
    &gt;&gt;&gt; # Get counts of Fe+2 in several minerals
    &gt;&gt;&gt; pychnosz.get_n_element_ox([&#34;hematite&#34;, &#34;fayalite&#34;, &#34;magnetite&#34;], &#34;Fe+2&#34;)
    [0, 2.0, 1.0]
    &gt;&gt;&gt; # Get binary presence/absence
    &gt;&gt;&gt; pychnosz.get_n_element_ox([&#34;hematite&#34;, &#34;fayalite&#34;, &#34;magnetite&#34;], &#34;Fe+2&#34;, binary=True)
    [False, True, True]
    &gt;&gt;&gt; # Can also use with retrieve()
    &gt;&gt;&gt; r = pychnosz.retrieve(&#34;Fe&#34;, [&#34;Si&#34;, &#34;O&#34;, &#34;H&#34;], state=[&#34;cr&#34;])
    &gt;&gt;&gt; pychnosz.get_n_element_ox(r, &#34;Fe+2&#34;)
    [1, 0, 0, 2.0, 1, 0, 1, 3.0, 1, 3.0, 0, 7.0]

    Notes
    -----
    This function requires the wormutils package to be installed for parsing
    the formula_ox strings. Install it with: pip install wormutils
    &#34;&#34;&#34;

    # Handle pandas Series (e.g., from retrieve())
    if isinstance(names, pd.Series):
        # Convert Series to list of indices
        names = names.values.tolist()
    # Handle single name/index
    elif not isinstance(names, list):
        names = [names]

    # Get the count of element_ox for each species
    n_list = []
    for name in names:
        # Get the formula_ox dictionary for this species
        formula_ox_dict = get_formula_ox(name)
        # Get the count of element_ox (default to 0 if not present)
        count = formula_ox_dict.get(element_ox, 0)
        n_list.append(count)

    # Convert to binary if requested
    if binary:
        out_list = [True if n != 0 else False for n in n_list]
    else:
        out_list = n_list

    return out_list</code></pre>
</details>
<div class="desc"><p>Get the number of an element of a chosen oxidation state in chemical species formulas.</p>
<p>This function only works when a thermodynamic database with the 'formula_ox'
column is loaded (e.g., the WORM database).</p>
<p>If binary is False, returns a list containing the number of the chosen
element and oxidation state in the chemical species. For example, how many
ferrous irons are in the formulae of hematite, fayalite, and magnetite,
respectively?</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; get_n_element_ox(names=[&quot;hematite&quot;, &quot;fayalite&quot;, &quot;magnetite&quot;],
...                  element_ox=&quot;Fe+2&quot;,
...                  binary=False)
[0, 2.0, 1.0]
</code></pre>
<p>If binary is True, returns a list of whether or not ferrous iron is in their
formulas:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; get_n_element_ox(names=[&quot;hematite&quot;, &quot;fayalite&quot;, &quot;magnetite&quot;],
...                  element_ox=&quot;Fe+2&quot;,
...                  binary=True)
[False, True, True]
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>names</code></strong> :&ensp;<code>str, int, list</code> of <code>str/int,</code> or <code>pd.Series</code></dt>
<dd>The name or database index of a chemical species, or a list of
names or indices. Can also be a pandas Series (e.g., from retrieve()).
Example: ["hematite", "fayalite", "magnetite"] or [788, 782, 798].</dd>
<dt><strong><code>element_ox</code></strong> :&ensp;<code>str</code></dt>
<dd>An element with a specific oxidation state. For example: "Fe+2" for
ferrous iron.</dd>
<dt><strong><code>binary</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Should the output list show True/False for presence or absence of the
element defined by <code>element_ox</code>? By default, this parameter is set to
False so the output list shows quantities of the element instead.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>float</code> or <code>list</code> of <code>bool</code></dt>
<dd>A list containing quantities of the chosen element oxidation state in
the formulas of the chemical species (if <code>binary=False</code>) or whether the
chosen element oxidation state is present in the formulae (if <code>binary=True</code>).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>If the WORM thermodynamic database is not loaded (no formula_ox attribute).</dd>
<dt><code>ValueError</code></dt>
<dd>If a species is not found in the database or does not have oxidation
state information.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; # Load the WORM database
&gt;&gt;&gt; pychnosz.thermo(&quot;WORM&quot;)
&gt;&gt;&gt; # Get counts of Fe+2 in several minerals
&gt;&gt;&gt; pychnosz.get_n_element_ox([&quot;hematite&quot;, &quot;fayalite&quot;, &quot;magnetite&quot;], &quot;Fe+2&quot;)
[0, 2.0, 1.0]
&gt;&gt;&gt; # Get binary presence/absence
&gt;&gt;&gt; pychnosz.get_n_element_ox([&quot;hematite&quot;, &quot;fayalite&quot;, &quot;magnetite&quot;], &quot;Fe+2&quot;, binary=True)
[False, True, True]
&gt;&gt;&gt; # Can also use with retrieve()
&gt;&gt;&gt; r = pychnosz.retrieve(&quot;Fe&quot;, [&quot;Si&quot;, &quot;O&quot;, &quot;H&quot;], state=[&quot;cr&quot;])
&gt;&gt;&gt; pychnosz.get_n_element_ox(r, &quot;Fe+2&quot;)
[1, 0, 0, 2.0, 1, 0, 1, 3.0, 1, 3.0, 0, 7.0]
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function requires the wormutils package to be installed for parsing
the formula_ox strings. Install it with: pip install wormutils</p></div>
</dd>
<dt id="pychnosz.gfun"><code class="name flex">
<span>def <span class="ident">gfun</span></span>(<span>rhohat, Tc, P, alpha, daldT, beta)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gfun(rhohat, Tc, P, alpha, daldT, beta):
    ## g and f functions for describing effective electrostatic radii of ions
    ## split from hkf() 20120123 jmd
    ## based on equations in
    ## Shock EL, Oelkers EH, Johnson JW, Sverjensky DA, Helgeson HC, 1992
    ## Calculation of the Thermodynamic Properties of Aqueous Species at High Pressures
    ## and Temperatures: Effective Electrostatic Radii, Dissociation Constants and
    ## Standard Partial Molal Properties to 1000 degrees C and 5 kbar
    ## J. Chem. Soc. Faraday Trans., 88(6), 803-826  doi:10.1039/FT9928800803
    # rhohat - density of water in g/cm3
    # Tc - temperature in degrees Celsius
    # P - pressure in bars

    # Vectorized version - handle both scalars and arrays
    rhohat = np.atleast_1d(rhohat)
    Tc = np.atleast_1d(Tc)
    P = np.atleast_1d(P)
    alpha = np.atleast_1d(alpha)
    daldT = np.atleast_1d(daldT)
    beta = np.atleast_1d(beta)

    # Broadcast to same shape
    shape = np.broadcast_shapes(rhohat.shape, Tc.shape, P.shape, alpha.shape, daldT.shape, beta.shape)
    rhohat = np.broadcast_to(rhohat, shape)
    Tc = np.broadcast_to(Tc, shape)
    P = np.broadcast_to(P, shape)
    alpha = np.broadcast_to(alpha, shape)
    daldT = np.broadcast_to(daldT, shape)
    beta = np.broadcast_to(beta, shape)

    # Initialize output arrays
    g = np.zeros(shape)
    dgdT = np.zeros(shape)
    d2gdT2 = np.zeros(shape)
    dgdP = np.zeros(shape)

    # only rhohat less than 1 will give results other than zero
    mask = rhohat &lt; 1
    if not np.any(mask):
        return {&#34;g&#34;: g, &#34;dgdT&#34;: dgdT, &#34;d2gdT2&#34;: d2gdT2, &#34;dgdP&#34;: dgdP}

    # eta in Eq. 1
    eta = 1.66027E5
    # Table 3
    ag1 = -2.037662
    ag2 = 5.747000E-3
    ag3 = -6.557892E-6
    bg1 = 6.107361
    bg2 = -1.074377E-2
    bg3 = 1.268348E-5

    # Work only with masked values
    Tc_m = Tc[mask]
    P_m = P[mask]
    rhohat_m = rhohat[mask]
    alpha_m = alpha[mask]
    daldT_m = daldT[mask]
    beta_m = beta[mask]

    # Eq. 25
    ag = ag1 + ag2 * Tc_m + ag3 * Tc_m ** 2
    # Eq. 26
    bg = bg1 + bg2 * Tc_m + bg3 * Tc_m ** 2
    # Eq. 24
    g_m = ag * (1 - rhohat_m) ** bg

    # Table 4
    af1 = 0.3666666E2
    af2 = -0.1504956E-9
    af3 = 0.5017997E-13

    # Eq. 33
    f = ( ((Tc_m - 155) / 300) ** 4.8 + af1 * ((Tc_m - 155) / 300) ** 16 ) * \
        ( af2 * (1000 - P_m) ** 3 + af3 * (1000 - P_m) ** 4 )

    # limits of the f function (region II of Fig. 6)
    ifg = (Tc_m &gt; 155) &amp; (P_m &lt; 1000) &amp; (Tc_m &lt; 355)

    # Eq. 32 - apply f correction where ifg is True
    # Check for complex values
    f_is_real = ~np.iscomplex(f)
    apply_f = ifg &amp; f_is_real
    g_m = np.where(apply_f, g_m - f.real, g_m)

    # at P &gt; 6000 bar (in DEW calculations), g is zero 20170926
    g_m = np.where(P_m &gt; 6000, 0, g_m)

    ## now we have g at P, T
    # put the results in their right place (where rhohat &lt; 1)
    g[mask] = g_m
    
    ## the rest is to get its partial derivatives with pressure and temperature
    ## after Johnson et al., 1992
    # alpha - coefficient of isobaric expansivity (K^-1)
    # daldT - temperature derivative of coefficient of isobaric expansivity (K^-2)
    # beta - coefficient of isothermal compressibility (bar^-1)

    # Eqn. 76
    d2fdT2 = (0.0608/300*((Tc_m-155)/300)**2.8 + af1/375*((Tc_m-155)/300)**14) * (af2*(1000-P_m)**3 + af3*(1000-P_m)**4)
    # Eqn. 75
    dfdT = (0.016*((Tc_m-155)/300)**3.8 + 16*af1/300*((Tc_m-155)/300)**15) * \
        (af2*(1000-P_m)**3 + af3*(1000-P_m)**4)
    # Eqn. 74
    dfdP = -(((Tc_m-155)/300)**4.8 + af1*((Tc_m-155)/300)**16) * \
        (3*af2*(1000-P_m)**2 + 4*af3*(1000-P_m)**3)
    d2bdT2 = 2 * bg3  # Eqn. 73
    d2adT2 = 2 * ag3  # Eqn. 72
    dbdT = bg2 + 2*bg3*Tc_m  # Eqn. 71
    dadT = ag2 + 2*ag3*Tc_m  # Eqn. 70

    # Convert complex to NaN
    d2fdT2 = np.where(np.iscomplex(d2fdT2), np.nan, np.real(d2fdT2))
    dfdT = np.where(np.iscomplex(dfdT), np.nan, np.real(dfdT))
    dfdP = np.where(np.iscomplex(dfdP), np.nan, np.real(dfdP))

    # Initialize derivative arrays for masked region
    dgdT_m = np.zeros_like(g_m)
    d2gdT2_m = np.zeros_like(g_m)
    dgdP_m = np.zeros_like(g_m)

    # Calculate derivatives where alpha and daldT are not NaN
    alpha_valid = ~np.isnan(alpha_m) &amp; ~np.isnan(daldT_m)
    if np.any(alpha_valid):
        # Work with valid subset
        av_idx = alpha_valid
        bg_av = bg[av_idx]
        rhohat_av = rhohat_m[av_idx]
        alpha_av = alpha_m[av_idx]
        daldT_av = daldT_m[av_idx]
        g_av = g_m[av_idx]
        ag_av = ag[av_idx]
        Tc_av = Tc_m[av_idx]
        dbdT_av = dbdT[av_idx]
        dadT_av = dadT[av_idx]

        # Handle log of (1-rhohat) safely
        with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
            log_term = np.log(1 - rhohat_av)
            log_term = np.where(np.isfinite(log_term), log_term, 0)

        # Eqn. 69
        dgadT = bg_av*rhohat_av*alpha_av*(1-rhohat_av)**(bg_av-1) + log_term*g_av/ag_av*dbdT_av
        D = rhohat_av

        # transcribed from SUPCRT92/reac92.f
        dDdT = -D * alpha_av
        dDdTT = -D * (daldT_av - alpha_av**2)
        Db = (1-D)**bg_av
        dDbdT = -bg_av*(1-D)**(bg_av-1)*dDdT + log_term*Db*dbdT_av
        dDbdTT = -(bg_av*(1-D)**(bg_av-1)*dDdTT + (1-D)**(bg_av-1)*dDdT*dbdT_av + \
            bg_av*dDdT*(-(bg_av-1)*(1-D)**(bg_av-2)*dDdT + log_term*(1-D)**(bg_av-1)*dbdT_av)) + \
            log_term*(1-D)**bg_av*d2bdT2 - (1-D)**bg_av*dbdT_av*dDdT/(1-D) + log_term*dbdT_av*dDbdT
        d2gdT2_calc = ag_av*dDbdTT + 2*dDbdT*dadT_av + Db*d2adT2

        # Apply f correction where ifg is True
        ifg_av = ifg[av_idx]
        d2fdT2_av = d2fdT2[av_idx]
        dfdT_av = dfdT[av_idx]
        d2gdT2_calc = np.where(ifg_av, d2gdT2_calc - d2fdT2_av, d2gdT2_calc)

        dgdT_calc = g_av/ag_av*dadT_av + ag_av*dgadT  # Eqn. 67
        dgdT_calc = np.where(ifg_av, dgdT_calc - dfdT_av, dgdT_calc)

        dgdT_m[av_idx] = dgdT_calc
        d2gdT2_m[av_idx] = d2gdT2_calc

    # Calculate dgdP where beta is not NaN
    beta_valid = ~np.isnan(beta_m)
    if np.any(beta_valid):
        bv_idx = beta_valid
        bg_bv = bg[bv_idx]
        rhohat_bv = rhohat_m[bv_idx]
        beta_bv = beta_m[bv_idx]
        g_bv = g_m[bv_idx]

        dgdP_calc = -bg_bv*rhohat_bv*beta_bv*g_bv*(1-rhohat_bv)**-1  # Eqn. 66
        ifg_bv = ifg[bv_idx]
        dfdP_bv = dfdP[bv_idx]
        dgdP_calc = np.where(ifg_bv, dgdP_calc - dfdP_bv, dgdP_calc)
        dgdP_m[bv_idx] = dgdP_calc

    # Put results back into full arrays
    dgdT[mask] = dgdT_m
    d2gdT2[mask] = d2gdT2_m
    dgdP[mask] = dgdP_m

    return {&#34;g&#34;: g, &#34;dgdT&#34;: dgdT, &#34;d2gdT2&#34;: d2gdT2, &#34;dgdP&#34;: dgdP}</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.group_formulas"><code class="name flex">
<span>def <span class="ident">group_formulas</span></span>(<span>) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_formulas() -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Return chemical formulas of amino acid residues.

    This function returns a DataFrame with the chemical formulas of
    H2O, the 20 amino acid sidechain groups, and the unfolded protein
    backbone group [UPBB].

    Returns
    -------
    DataFrame
        Chemical formulas with elements C, H, N, O, S as columns
        and residues as rows
    &#34;&#34;&#34;
    # Chemical formulas as a numpy array
    # Rows: water, [Ala], [Cys], [Asp], [Glu], [Phe], [Gly], [His], [Ile], [Lys], [Leu],
    #       [Met], [Asn], [Pro], [Gln], [Arg], [Ser], [Thr], [Val], [Trp], [Tyr], [UPBB]
    # Columns: C, H, N, O, S
    A = np.array([
        [0, 2, 0, 1, 0],      # H2O
        [1, 3, 0, 0, 0],      # [Ala]
        [1, 3, 0, 0, 1],      # [Cys]
        [2, 3, 0, 2, 0],      # [Asp]
        [3, 5, 0, 2, 0],      # [Glu]
        [7, 7, 0, 0, 0],      # [Phe]
        [0, 1, 0, 0, 0],      # [Gly]
        [4, 5, 2, 0, 0],      # [His]
        [4, 9, 0, 0, 0],      # [Ile]
        [4, 10, 1, 0, 0],     # [Lys]
        [4, 9, 0, 0, 0],      # [Leu]
        [3, 7, 0, 0, 1],      # [Met]
        [2, 4, 1, 1, 0],      # [Asn]
        [3, 5, 0, 0, 0],      # [Pro]
        [3, 6, 1, 1, 0],      # [Gln]
        [4, 10, 3, 0, 0],     # [Arg]
        [1, 3, 0, 1, 0],      # [Ser]
        [2, 5, 0, 1, 0],      # [Thr]
        [3, 7, 0, 0, 0],      # [Val]
        [9, 8, 1, 0, 0],      # [Trp]
        [7, 7, 0, 1, 0],      # [Tyr]
        [2, 2, 1, 1, 0]       # [UPBB]
    ])

    rownames = [&#39;H2O&#39;, &#39;[Ala]&#39;, &#39;[Cys]&#39;, &#39;[Asp]&#39;, &#39;[Glu]&#39;, &#39;[Phe]&#39;, &#39;[Gly]&#39;,
                &#39;[His]&#39;, &#39;[Ile]&#39;, &#39;[Lys]&#39;, &#39;[Leu]&#39;, &#39;[Met]&#39;, &#39;[Asn]&#39;, &#39;[Pro]&#39;,
                &#39;[Gln]&#39;, &#39;[Arg]&#39;, &#39;[Ser]&#39;, &#39;[Thr]&#39;, &#39;[Val]&#39;, &#39;[Trp]&#39;, &#39;[Tyr]&#39;,
                &#39;[UPBB]&#39;]

    # Add [UPBB] to the sidechain groups to get residues
    out = A.copy()
    # Add [UPBB] (last row) to each sidechain group (rows 1-20)
    out[1:21, :] = out[1:21, :] + A[21, :]

    # Create DataFrame
    df = pd.DataFrame(out[0:21, :],
                     index=rownames[0:21],
                     columns=[&#39;C&#39;, &#39;H&#39;, &#39;N&#39;, &#39;O&#39;, &#39;S&#39;])

    return df</code></pre>
</details>
<div class="desc"><p>Return chemical formulas of amino acid residues.</p>
<p>This function returns a DataFrame with the chemical formulas of
H2O, the 20 amino acid sidechain groups, and the unfolded protein
backbone group [UPBB].</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Chemical formulas with elements C, H, N, O, S as columns
and residues as rows</dd>
</dl></div>
</dd>
<dt id="pychnosz.hkf"><code class="name flex">
<span>def <span class="ident">hkf</span></span>(<span>property=None,<br>parameters=None,<br>T=298.15,<br>P=1,<br>contrib=['n', 's', 'o'],<br>H2O_props=['rho'],<br>water_model='SUPCRT92')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hkf(property=None, parameters=None, T=298.15, P=1,
    contrib = [&#34;n&#34;, &#34;s&#34;, &#34;o&#34;], H2O_props=[&#34;rho&#34;], water_model=&#34;SUPCRT92&#34;):
    # calculate G, H, S, Cp, V, kT, and/or E using
    # the revised HKF equations of state
    # H2O_props - H2O properties needed for subcrt() output
    # constants
    Tr = 298.15 # K
    Pr = 1      # bar
    Theta = 228 # K
    Psi = 2600  # bar

    # Convert T and P to arrays for vectorized operations
    T = np.atleast_1d(T)
    P = np.atleast_1d(P)

    # DEBUG
    if False:
        print(f&#34;\nDEBUG HKF input:&#34;)
        print(f&#34;  T (K): {T}&#34;)
        print(f&#34;  P (bar): {P}&#34;)

    # make T and P equal length
    if P.size &lt; T.size:
        P = np.full_like(T, P[0] if P.size == 1 else P)
    if T.size &lt; P.size:
        T = np.full_like(P, T[0] if T.size == 1 else T)

    n_conditions = T.size
    
    # GB conversion note: handle error messages later
#     # nonsolvation, solvation, and origination contribution
#     notcontrib &lt;- ! contrib %in% c(&#34;n&#34;, &#34;s&#34;, &#34;o&#34;)
#     if(TRUE %in% notcontrib) stop(paste(&#34;contrib must be in c(&#39;n&#39;, &#39;s&#39;, &#39;o); got&#34;, c2s(contrib[notcontrib])))
    
    # get water properties
    # rho - for subcrt() output and g function
    # Born functions and epsilon - for HKF calculations
    H2O_props += [&#34;QBorn&#34;, &#34;XBorn&#34;, &#34;YBorn&#34;, &#34;epsilon&#34;]

    if water_model == &#34;SUPCRT92&#34;:
      # using H2O92D.f from SUPCRT92: alpha, daldT, beta - for partial derivatives of omega (g function)
      H2O_props += [&#34;alpha&#34;, &#34;daldT&#34;, &#34;beta&#34;]
    
    elif water_model == &#34;IAPWS95&#34;:
      # using IAPWS-95: NBorn, UBorn - for compressibility, expansibility
      H2O_props += [&#34;alpha&#34;, &#34;daldT&#34;, &#34;beta&#34;, &#34;NBorn&#34;, &#34;UBorn&#34;]
    
    elif water_model == &#34;DEW&#34;:
      # using DEW model: get beta to calculate dgdP
      H2O_props += [&#34;alpha&#34;, &#34;daldT&#34;, &#34;beta&#34;]

    # DEBUG: Print T and P being passed to water
    if False:
        print(f&#34;DEBUG HKF calling water():&#34;)
        print(f&#34;  T type: {type(T)}, T: {T}&#34;)
        print(f&#34;  P type: {type(P)}, P: {P}&#34;)
        print(f&#34;  H2O_props: {H2O_props}&#34;)

    H2O_PrTr = water(H2O_props, T=Tr, P=Pr)
    H2O_PT = water(H2O_props, T=T, P=P)

    # DEBUG: Print what water returned
    if False:
        print(f&#34;DEBUG HKF water() returned:&#34;)
        print(f&#34;  H2O_PT type: {type(H2O_PT)}&#34;)
        if isinstance(H2O_PT, dict):
            print(f&#34;  H2O_PT keys: {H2O_PT.keys()}&#34;)
            print(f&#34;  epsilon: {H2O_PT.get(&#39;epsilon&#39;, &#39;NOT FOUND&#39;)}&#34;)

    # Handle dict output from water function
    def get_water_prop(water_dict, prop):
        &#34;&#34;&#34;Helper function to get water property from dict or DataFrame&#34;&#34;&#34;
        if isinstance(water_dict, dict):
            return water_dict[prop]
        else:
            return water_dict.loc[&#34;1&#34;, prop]

    # Get epsilon values and handle potential zeros
    epsilon_PT = get_water_prop(H2O_PT, &#34;epsilon&#34;)
    epsilon_PrTr = get_water_prop(H2O_PrTr, &#34;epsilon&#34;)

    # Check for zero or very small epsilon values and warn
    if np.any(epsilon_PT == 0) or np.any(np.abs(epsilon_PT) &lt; 1e-10):
        warnings.warn(f&#34;HKF: epsilon at P,T is zero or very small: {epsilon_PT}. H2O_PT keys: {H2O_PT.keys() if isinstance(H2O_PT, dict) else &#39;not dict&#39;}&#34;)

    with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
        ZBorn = -1 / epsilon_PT
        ZBorn_PrTr = -1 / epsilon_PrTr
    
    # a class to store the result
    out_dict = {} # dictionary to store output
    
    for k in parameters.index:
        
        if parameters[&#34;state&#34;][k] != &#34;aq&#34;:
            out_dict[k] = {p:float(&#39;NaN&#39;) for p in property}
        else:
            sp = parameters[&#34;name&#34;][k]

            # loop over each species
            PAR = copy.copy(parameters.loc[k, :])

            PAR[&#34;a1.a&#34;] = copy.copy(PAR[&#34;a1.a&#34;]*10**-1)
            PAR[&#34;a2.b&#34;] = copy.copy(PAR[&#34;a2.b&#34;]*10**2)
            PAR[&#34;a4.d&#34;] = copy.copy(PAR[&#34;a4.d&#34;]*10**4)
            PAR[&#34;c2.f&#34;] = copy.copy(PAR[&#34;c2.f&#34;]*10**4)
            PAR[&#34;omega.lambda&#34;] = copy.copy(PAR[&#34;omega.lambda&#34;]*10**5)

            # substitute Cp and V for missing EoS parameters
            # here we assume that the parameters are in the same position as in thermo()$OBIGT
            # we don&#39;t need this if we&#39;re just looking at solvation properties (Cp_s_var, V_s_var)

            # GB conversion note: this block checks various things about EOS parameters.
            # for now, just set hasEOS to True
            hasEOS = True # delete this once the following block is converted to python
    #         if &#34;n&#34; in contrib:
    #             # put the heat capacity in for c1 if both c1 and c2 are missing
    #             if all(is.na(PAR[, 18:19])):
    #                 PAR[, 18] = PAR[&#34;Cp&#34;]
    #             # put the volume in for a1 if a1, a2, a3 and a4 are missing
    #             if all(is.na(PAR[, 14:17])):
    #                 PAR[, 14] = convert(PAR[&#34;V&#34;], &#34;calories&#34;)
    #             # test for availability of the EoS parameters
    #             hasEOS = any(!is.na(PAR[, 14:21]))
    #             # if at least one of the EoS parameters is available, zero out any NA&#39;s in the rest
    #             if hasEOS:
    #                 PAR[, 14:21][, is.na(PAR[, 14:21])] = 0

            # compute values of omega(P,T) from those of omega(Pr,Tr)
            # using g function etc. (Shock et al., 1992 and others)
            omega = PAR[&#34;omega.lambda&#34;]  # omega_PrTr
            # its derivatives are zero unless the g function kicks in
            dwdP = np.zeros(n_conditions)
            dwdT = np.zeros(n_conditions)
            d2wdT2 = np.zeros(n_conditions)
            Z = PAR[&#34;z.T&#34;]

            omega_PT = np.full(n_conditions, PAR[&#34;omega.lambda&#34;])
            if Z != 0 and Z != &#34;NA&#34; and PAR[&#34;name&#34;] != &#34;H+&#34;:
                # compute derivatives of omega: g and f functions (Shock et al., 1992; Johnson et al., 1992)
                rhohat = get_water_prop(H2O_PT, &#34;rho&#34;)/1000  # just converting kg/m3 to g/cm3

                # temporarily filter out Python&#39;s warnings about dividing by zero, which is possible
                # with the equations in the gfunction
                # Possible complex output is acounted for in gfun().
                with warnings.catch_warnings():
                    warnings.simplefilter(&#39;ignore&#39;)
                    g = gfun(rhohat, T-273.15, P, get_water_prop(H2O_PT, &#34;alpha&#34;), get_water_prop(H2O_PT, &#34;daldT&#34;), get_water_prop(H2O_PT, &#34;beta&#34;))

                # after SUPCRT92/reac92.f
                eta = 1.66027E5
                reref = (Z**2) / (omega/eta + Z/(3.082 + 0))
                re = reref + abs(Z) * g[&#34;g&#34;]
                omega_PT = eta * (Z**2/re - Z/(3.082 + g[&#34;g&#34;]))
                Z3 = abs(Z**3)/re**2 - Z/(3.082 + g[&#34;g&#34;])**2
                Z4 = abs(Z**4)/re**3 - Z/(3.082 + g[&#34;g&#34;])**3
                dwdP = (-eta * Z3 * g[&#34;dgdP&#34;])
                dwdT = (-eta * Z3 * g[&#34;dgdT&#34;])
                d2wdT2 = (2 * eta * Z4 * g[&#34;dgdT&#34;]**2 - eta * Z3 * g[&#34;d2gdT2&#34;])

            # loop over each property
            w = float(&#39;NaN&#39;)
            for i,PROP in enumerate(property) :

                # over nonsolvation, solvation, or origination contributions - vectorized
                hkf_p = np.zeros(n_conditions)

                for icontrib in contrib :
                    # various contributions to the properties
                    if icontrib == &#34;n&#34;:
                        # nonsolvation ghs equations
                        if PROP == &#34;H&#34;:
                            p_c = PAR[&#34;c1.e&#34;]*(T-Tr) - PAR[&#34;c2.f&#34;]*(1/(T-Theta)-1/(Tr-Theta))
                            p_a = PAR[&#34;a1.a&#34;]*(P-Pr) + PAR[&#34;a2.b&#34;]*np.log((Psi+P)/(Psi+Pr)) + \
                              ((2*T-Theta)/(T-Theta)**2)*(PAR[&#34;a3.c&#34;]*(P-Pr)+PAR[&#34;a4.d&#34;]*np.log((Psi+P)/(Psi+Pr)))
                            p = p_c + p_a
                        elif PROP == &#34;S&#34;:
                            p_c = PAR[&#34;c1.e&#34;]*np.log(T/Tr) - \
                              (PAR[&#34;c2.f&#34;]/Theta)*( 1/(T-Theta)-1/(Tr-Theta) + \
                              np.log( (Tr*(T-Theta))/(T*(Tr-Theta)) )/Theta )
                            p_a = (T-Theta)**(-2)*(PAR[&#34;a3.c&#34;]*(P-Pr)+PAR[&#34;a4.d&#34;]*np.log((Psi+P)/(Psi+Pr)))
                            p = p_c + p_a
                        elif PROP == &#34;G&#34;:
                            p_c = -PAR[&#34;c1.e&#34;]*(T*np.log(T/Tr)-T+Tr) - \
                              PAR[&#34;c2.f&#34;]*( (1/(T-Theta)-1/(Tr-Theta))*((Theta-T)/Theta) - \
                              (T/Theta**2)*np.log((Tr*(T-Theta))/(T*(Tr-Theta))) )
                            p_a = PAR[&#34;a1.a&#34;]*(P-Pr) + PAR[&#34;a2.b&#34;]*np.log((Psi+P)/(Psi+Pr)) + \
                              (PAR[&#34;a3.c&#34;]*(P-Pr) + PAR[&#34;a4.d&#34;]*np.log((Psi+P)/(Psi+Pr)))/(T-Theta)
                            p = p_c + p_a
                            # at Tr,Pr, if the origination contribution is not NA, ensure the solvation contribution is 0, not NA
                            if not np.isnan(PAR[&#34;G&#34;]):
                                p = np.where((T==Tr) &amp; (P==Pr), 0, p)
                        # nonsolvation cp v kt e equations
                        elif PROP == &#34;Cp&#34;:
                            p = PAR[&#34;c1.e&#34;] + PAR[&#34;c2.f&#34;] * ( T - Theta ) ** (-2)
                        elif PROP == &#34;V&#34;:
                            p = convert_cm3bar(PAR[&#34;a1.a&#34;]) + \
                              convert_cm3bar(PAR[&#34;a2.b&#34;]) / (Psi + P) + \
                              (convert_cm3bar(PAR[&#34;a3.c&#34;]) + convert_cm3bar(PAR[&#34;a4.d&#34;]) / (Psi + P)) / (T - Theta)
#                         elif PROP == &#34;kT&#34;:
#                             p = (convert(PAR[&#34;a2.b&#34;], &#34;cm3bar&#34;) + \
#                               convert(PAR[&#34;a4.d&#34;], &#34;cm3bar&#34;) / (T - Theta)) * (Psi + P) ** (-2)
#                         elif PROP == &#34;E&#34;:
#                             p = convert( - (PAR[&#34;a3.c&#34;] + PAR[&#34;a4.d&#34;] / convert((Psi + P), &#34;calories&#34;)) * \
#                               (T - Theta) ** (-2), &#34;cm3bar&#34;)
                        else:
                            print(&#34;BAD&#34;)

                    if icontrib == &#34;s&#34;:
                        # solvation ghs equations
                        if PROP == &#34;G&#34;:
                            p = -omega_PT*(ZBorn+1) + omega*(ZBorn_PrTr+1) + omega*get_water_prop(H2O_PrTr, &#34;YBorn&#34;)*(T-Tr)
                            # at Tr,Pr, if the origination contribution is not NA, ensure the solvation contribution is 0, not NA
                            if(np.isnan(PAR[&#34;G&#34;])):
                                p = np.where((T==Tr) &amp; (P==Pr), 0, p)
                        if PROP == &#34;H&#34;:
                            p = -omega_PT*(ZBorn+1) + omega_PT*T*get_water_prop(H2O_PT, &#34;YBorn&#34;) + T*(ZBorn+1)*dwdT + \
                                   omega*(ZBorn_PrTr+1) - omega*Tr*get_water_prop(H2O_PrTr, &#34;YBorn&#34;)
                        if PROP == &#34;S&#34;:
                            p = omega_PT*get_water_prop(H2O_PT, &#34;YBorn&#34;) + (ZBorn+1)*dwdT - omega*get_water_prop(H2O_PrTr, &#34;YBorn&#34;)
                        # solvation cp v kt e equations
                        if PROP == &#34;Cp&#34;:
                            p = omega_PT*T*get_water_prop(H2O_PT, &#34;XBorn&#34;) + 2*T*get_water_prop(H2O_PT, &#34;YBorn&#34;)*dwdT + T*(ZBorn+1)*d2wdT2
                        if PROP == &#34;V&#34;:
                            term1 = -convert_cm3bar(omega_PT) * get_water_prop(H2O_PT, &#34;QBorn&#34;)
                            term2 = convert_cm3bar(dwdP) * (-ZBorn - 1)
                            p = term1 + term2

                            # DEBUG
                            if False:
                                print(f&#34;\nDEBUG solvation V terms:&#34;)
                                print(f&#34;  omega_PT: {omega_PT}&#34;)
                                print(f&#34;  QBorn: {get_water_prop(H2O_PT, &#39;QBorn&#39;)}&#34;)
                                print(f&#34;  dwdP: {dwdP}&#34;)
                                print(f&#34;  ZBorn: {ZBorn}&#34;)
                                print(f&#34;  term1 (-ω*QBorn): {term1}&#34;)
                                print(f&#34;  term2 (dwdP*(-Z-1)): {term2}&#34;)
                                print(f&#34;  total p: {p}&#34;)
                        # TODO: the partial derivatives of omega are not included here here for kt and e
                        # (to do it, see p. 820 of SOJ+92 ... but kt requires d2wdP2 which we don&#34;t have yet)
                        if PROP == &#34;kT&#34;:
                            p = convert_cm3bar(omega) * get_water_prop(H2O_PT, &#34;NBorn&#34;)
                        if PROP == &#34;E&#34;:
                            p = -convert_cm3bar(omega) * get_water_prop(H2O_PT, &#34;UBorn&#34;)

                    if icontrib == &#34;o&#34;:
                        # origination ghs equations
                        if PROP == &#34;G&#34;:
                            p = PAR[&#34;G&#34;] - PAR[&#34;S&#34;] * (T-Tr)
                            # don&#34;t inherit NA from PAR$S at Tr
                            p = np.where(T == Tr, PAR[&#34;G&#34;], p)
                        elif PROP == &#34;H&#34;:
                            p = np.full(n_conditions, PAR[&#34;H&#34;])
                        elif PROP == &#34;S&#34;:
                            p = np.full(n_conditions, PAR[&#34;S&#34;])
                        # origination eos equations (Cp, V, kT, E): senseless
                        else:
                            p = np.zeros(n_conditions)

                    # accumulate the contribution
                    hkf_p = hkf_p + p

                    # DEBUG
                    if False and PROP == &#34;V&#34;:
                        print(f&#34;\nDEBUG HKF V calculation (species {k}, contrib={icontrib}):&#34;)
                        print(f&#34;  T: {T}&#34;)
                        print(f&#34;  P: {P}&#34;)
                        print(f&#34;  contribution p: {p}&#34;)
                        print(f&#34;  accumulated hkf_p: {hkf_p}&#34;)

                # species have to be numbered (k) instead of named because of name repeats in db (e.g., cr polymorphs)
                if i &gt; 0:
                    out_dict[k][PROP] = hkf_p
                else:
                    out_dict[k] = {PROP:hkf_p}

                # DEBUG
                if False and PROP == &#34;V&#34;:
                    print(f&#34;\nDEBUG HKF final V for species {k}: {hkf_p}&#34;)

    return(out_dict, H2O_PT)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>species: str | int | List[str | int] | pandas.core.series.Series | None = None,<br>state: str | List[str] | None = None,<br>check_it: bool = True,<br>messages: bool = True) ‑> pandas.core.frame.DataFrame | int | List[int] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(species: Optional[Union[str, int, List[Union[str, int]], pd.Series]] = None,
         state: Optional[Union[str, List[str]]] = None,
         check_it: bool = True,
         messages: bool = True) -&gt; Union[pd.DataFrame, int, List[int], None]:
    &#34;&#34;&#34;
    Search for species in the thermodynamic database.

    Parameters
    ----------
    species : str, int, list of str/int, pd.Series, or None
        Species name, formula, abbreviation, or OBIGT index.
        Can also be a pandas Series (e.g., from retrieve()).
        If None, returns summary information about the database.
    state : str, list of str, or None
        Physical state(s) to match (&#39;aq&#39;, &#39;cr&#39;, &#39;gas&#39;, &#39;liq&#39;)
    check_it : bool, default True
        Whether to perform consistency checks on thermodynamic data
    messages : bool, default True
        Whether to print informational messages

    Returns
    -------
    pd.DataFrame, int, list of int, or None
        - If species is None: prints database summary, returns None
        - If species is numeric: returns DataFrame with species data
        - If species is string: returns species index(es) or NA if not found

    Examples
    --------
    &gt;&gt;&gt; # Get database summary
    &gt;&gt;&gt; info()

    &gt;&gt;&gt; # Find species index
    &gt;&gt;&gt; info(&#34;H2O&#34;)

    &gt;&gt;&gt; # Get species data by index
    &gt;&gt;&gt; info(1)

    &gt;&gt;&gt; # Search with specific state
    &gt;&gt;&gt; info(&#34;CO2&#34;, &#34;aq&#34;)

    &gt;&gt;&gt; # Use output from retrieve()
    &gt;&gt;&gt; zn_species = retrieve(&#34;Zn&#34;, [&#34;O&#34;, &#34;H&#34;], state=&#34;aq&#34;)
    &gt;&gt;&gt; info(zn_species)
    &#34;&#34;&#34;
    thermo_obj = thermo()

    # Initialize database if needed
    if not thermo_obj.is_initialized():
        thermo_obj.reset()

    # Return database summary if no species specified
    if species is None:
        return _print_database_summary(thermo_obj, messages)

    # Handle pandas Series (e.g., from retrieve())
    if isinstance(species, pd.Series):
        # Extract the integer indices from the Series values
        indices = species.values.tolist()
        return _info_numeric(indices, thermo_obj, check_it, messages)

    # Handle numeric species indices
    if isinstance(species, (int, list)) and all(isinstance(s, int) for s in (species if isinstance(species, list) else [species])):
        return _info_numeric(species, thermo_obj, check_it, messages)

    # Handle string species names/formulas
    if isinstance(species, (str, list)):
        return _info_character(species, state, thermo_obj, messages)

    raise ValueError(f&#34;Invalid species type: {type(species)}&#34;)</code></pre>
</details>
<div class="desc"><p>Search for species in the thermodynamic database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int, list</code> of <code>str/int, pd.Series,</code> or <code>None</code></dt>
<dd>Species name, formula, abbreviation, or OBIGT index.
Can also be a pandas Series (e.g., from retrieve()).
If None, returns summary information about the database.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>None</code></dt>
<dd>Physical state(s) to match ('aq', 'cr', 'gas', 'liq')</dd>
<dt><strong><code>check_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to perform consistency checks on thermodynamic data</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame, int, list</code> of <code>int,</code> or <code>None</code></dt>
<dd>
<ul>
<li>If species is None: prints database summary, returns None</li>
<li>If species is numeric: returns DataFrame with species data</li>
<li>If species is string: returns species index(es) or NA if not found</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get database summary
&gt;&gt;&gt; info()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Find species index
&gt;&gt;&gt; info(&quot;H2O&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get species data by index
&gt;&gt;&gt; info(1)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Search with specific state
&gt;&gt;&gt; info(&quot;CO2&quot;, &quot;aq&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Use output from retrieve()
&gt;&gt;&gt; zn_species = retrieve(&quot;Zn&quot;, [&quot;O&quot;, &quot;H&quot;], state=&quot;aq&quot;)
&gt;&gt;&gt; info(zn_species)
</code></pre></div>
</dd>
<dt id="pychnosz.ionize_aa"><code class="name flex">
<span>def <span class="ident">ionize_aa</span></span>(<span>aa: pandas.core.frame.DataFrame,<br>property: str = 'Z',<br>T: float | numpy.ndarray = 25.0,<br>P: float | str | numpy.ndarray = 'Psat',<br>pH: float | numpy.ndarray = 7.0,<br>ret_val: str | None = None,<br>suppress_Cys: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ionize_aa(aa: pd.DataFrame,
              property: str = &#34;Z&#34;,
              T: Union[float, np.ndarray] = 25.0,
              P: Union[float, str, np.ndarray] = &#34;Psat&#34;,
              pH: Union[float, np.ndarray] = 7.0,
              ret_val: Optional[str] = None,
              suppress_Cys: bool = False) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate additive ionization properties of proteins.

    This function calculates the net charge or other ionization properties
    of proteins based on amino acid composition at specified T, P, and pH.

    Parameters
    ----------
    aa : DataFrame
        Amino acid composition data
    property : str, default &#34;Z&#34;
        Property to calculate:
        - &#34;Z&#34;: net charge
        - &#34;A&#34;: chemical affinity
        - Other subcrt properties (G, H, S, Cp, V)
    T : float or array, default 25.0
        Temperature in degrees Celsius
    P : float, str, or array, default &#34;Psat&#34;
        Pressure in bar, or &#34;Psat&#34; for saturation
    pH : float or array, default 7.0
        pH value(s)
    ret_val : str, optional
        Return value type:
        - &#34;pK&#34;: return pK values
        - &#34;alpha&#34;: return degree of formation
        - &#34;aavals&#34;: return amino acid values
        - None: return ionization property (default)
    suppress_Cys : bool, default False
        Suppress cysteine ionization

    Returns
    -------
    DataFrame
        Ionization properties

    Examples
    --------
    &gt;&gt;&gt; from pychnosz import *
    &gt;&gt;&gt; aa = pinfo(pinfo(&#34;LYSC_CHICK&#34;))
    &gt;&gt;&gt; Z = ionize_aa(aa, pH=7.0)
    &#34;&#34;&#34;
    # Ensure inputs are arrays
    T = np.atleast_1d(T)
    if isinstance(P, str):
        P = np.array([P] * len(T))
    else:
        P = np.atleast_1d(P)
    pH_arr = np.atleast_1d(pH)

    # Get maximum length and replicate arrays
    lmax = max(len(T), len(P), len(pH_arr))
    T = np.resize(T, lmax)
    if isinstance(P[0], str):
        P = np.array([P[0]] * lmax)
    else:
        P = np.resize(P, lmax)
    pH_arr = np.resize(pH_arr, lmax)

    # Turn pH into a matrix with as many columns as ionizable groups (9)
    pH_matrix = np.tile(pH_arr[:, np.newaxis], (1, 9))

    # Charges for ionizable groups
    charges = np.array([-1, -1, -1, 1, 1, 1, -1, 1, -1])
    charges_matrix = np.tile(charges, (lmax, 1))

    # The ionizable groups
    neutral = [&#34;[Cys]&#34;, &#34;[Asp]&#34;, &#34;[Glu]&#34;, &#34;[His]&#34;, &#34;[Lys]&#34;, &#34;[Arg]&#34;, &#34;[Tyr]&#34;, &#34;[AABB]&#34;, &#34;[AABB]&#34;]
    charged = [&#34;[Cys-]&#34;, &#34;[Asp-]&#34;, &#34;[Glu-]&#34;, &#34;[His+]&#34;, &#34;[Lys+]&#34;, &#34;[Arg+]&#34;, &#34;[Tyr-]&#34;, &#34;[AABB+]&#34;, &#34;[AABB-]&#34;]

    # Get row numbers in OBIGT
    ineutral = [info(g, &#34;aq&#34;) for g in neutral]
    icharged = [info(g, &#34;aq&#34;) for g in charged]

    # Get unique T, P combinations
    pTP = [f&#34;{t}_{p}&#34; for t, p in zip(T, P)]
    unique_pTP = []
    seen = set()
    indices = []
    for i, tp in enumerate(pTP):
        if tp not in seen:
            unique_pTP.append(i)
            seen.add(tp)
        indices.append(list(seen).index(tp))

    # Determine which property to calculate
    sprop = [&#34;G&#34;, property] if property not in [&#34;A&#34;, &#34;Z&#34;] else [&#34;G&#34;]

    # Convert T to Kelvin for subcrt
    TK = convert(T, &#34;K&#34;)

    # Call subcrt for unique T, P combinations
    unique_T = TK[unique_pTP]
    unique_P = P[unique_pTP]

    all_species = ineutral + icharged
    sout = subcrt(all_species, T=unique_T, P=unique_P, property=sprop, convert=False)

    # Extract G values
    Gs = np.zeros((len(unique_pTP), len(all_species)))
    for i, spec_idx in enumerate(all_species):
        if isinstance(sout[&#39;out&#39;], dict):
            # Single species result
            Gs[:, i] = sout[&#39;out&#39;][&#39;G&#39;]
        else:
            # Multiple species result
            Gs[:, i] = sout[&#39;out&#39;][i][&#39;G&#39;].values

    # Gibbs energy difference for each group
    DG = Gs[:, 9:18] - Gs[:, 0:9]

    # Build matrix for all T, P values (including duplicates)
    DG_full = DG[indices, :]

    # Calculate pK values
    DG_full = DG_full * charges
    pK = np.zeros_like(DG_full)
    for i in range(pK.shape[1]):
        pK[:, i] = convert(DG_full[:, i], &#34;logK&#34;, T=TK)

    # Return pK if requested
    if ret_val == &#34;pK&#34;:
        return pd.DataFrame(pK, columns=charged)

    # Calculate alpha (degree of formation)
    alpha = 1 / (1 + 10 ** (charges_matrix * (pH_matrix - pK)))

    # Suppress cysteine ionization if requested
    if suppress_Cys:
        alpha[:, 0] = 0

    # Return alpha if requested
    if ret_val == &#34;alpha&#34;:
        return pd.DataFrame(alpha, columns=charged)

    # Calculate amino acid values
    if property == &#34;Z&#34;:
        aavals = charges_matrix.copy()
    elif property == &#34;A&#34;:
        aavals = -charges_matrix * (pH_matrix - pK)
    else:
        # Extract property values from subcrt output
        prop_vals = np.zeros((len(unique_pTP), len(all_species)))
        for i, spec_idx in enumerate(all_species):
            if isinstance(sout[&#39;out&#39;], dict):
                prop_vals[:, i] = sout[&#39;out&#39;][property]
            else:
                prop_vals[:, i] = sout[&#39;out&#39;][i][property].values

        # Build matrix for all T, P values
        prop_vals_full = prop_vals[indices, :]

        # Property difference for each group
        aavals = prop_vals_full[:, 9:18] - prop_vals_full[:, 0:9]

    # Return aavals if requested
    if ret_val == &#34;aavals&#34;:
        return pd.DataFrame(aavals, columns=charged)

    # Contribution from each group
    aavals = aavals * alpha

    # Get counts of ionizable groups from aa
    # Columns: Cys, Asp, Glu, His, Lys, Arg, Tyr, chains, chains
    ionize_cols = [&#34;Cys&#34;, &#34;Asp&#34;, &#34;Glu&#34;, &#34;His&#34;, &#34;Lys&#34;, &#34;Arg&#34;, &#34;Tyr&#34;, &#34;chains&#34;, &#34;chains&#34;]
    aa_counts = aa[ionize_cols].values.astype(float)

    # Calculate total ionization property
    out = np.dot(aavals, aa_counts.T)

    # Create DataFrame
    result = pd.DataFrame(out)

    return result</code></pre>
</details>
<div class="desc"><p>Calculate additive ionization properties of proteins.</p>
<p>This function calculates the net charge or other ionization properties
of proteins based on amino acid composition at specified T, P, and pH.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>aa</code></strong> :&ensp;<code>DataFrame</code></dt>
<dd>Amino acid composition data</dd>
<dt><strong><code>property</code></strong> :&ensp;<code>str</code>, default <code>"Z"</code></dt>
<dd>Property to calculate:
- "Z": net charge
- "A": chemical affinity
- Other subcrt properties (G, H, S, Cp, V)</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>array</code>, default <code>25.0</code></dt>
<dd>Temperature in degrees Celsius</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float, str,</code> or <code>array</code>, default <code>"Psat"</code></dt>
<dd>Pressure in bar, or "Psat" for saturation</dd>
<dt><strong><code>pH</code></strong> :&ensp;<code>float</code> or <code>array</code>, default <code>7.0</code></dt>
<dd>pH value(s)</dd>
<dt><strong><code>ret_val</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Return value type:
- "pK": return pK values
- "alpha": return degree of formation
- "aavals": return amino acid values
- None: return ionization property (default)</dd>
<dt><strong><code>suppress_Cys</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Suppress cysteine ionization</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Ionization properties</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz import *
&gt;&gt;&gt; aa = pinfo(pinfo(&quot;LYSC_CHICK&quot;))
&gt;&gt;&gt; Z = ionize_aa(aa, pH=7.0)
</code></pre></div>
</dd>
<dt id="pychnosz.list_OBIGT_files"><code class="name flex">
<span>def <span class="ident">list_OBIGT_files</span></span>(<span>) ‑> List[str]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_OBIGT_files() -&gt; List[str]:
    &#34;&#34;&#34;
    List available OBIGT database files.
    
    Returns
    -------
    list of str
        List of available .csv files in the OBIGT directory
    &#34;&#34;&#34;
    
    # Use package-relative path
    base_paths = [
        os.path.join(os.path.dirname(__file__), &#39;extdata&#39;, &#39;OBIGT&#39;),
    ]
    
    files = []
    for base_path in base_paths:
        if os.path.exists(base_path):
            csv_files = [f[:-4] for f in os.listdir(base_path) if f.endswith(&#39;.csv&#39;)]
            files.extend(csv_files)
            break
    
    return sorted(list(set(files)))  # Remove duplicates and sort</code></pre>
</details>
<div class="desc"><p>List available OBIGT database files.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>str</code></dt>
<dd>List of available .csv files in the OBIGT directory</dd>
</dl></div>
</dd>
<dt id="pychnosz.load_WORM"><code class="name flex">
<span>def <span class="ident">load_WORM</span></span>(<span>keep_default: bool = False, messages: bool = True) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_WORM(keep_default: bool = False, messages: bool = True) -&gt; bool:
    &#34;&#34;&#34;
    Load the WORM (Water-Organic-Rock-Microbe) thermodynamic database.

    This function downloads and loads the WORM database from the WORM-db GitHub
    repository. By default, it replaces the OBIGT database with WORM data,
    keeping only water, H+, and e- from the original database.

    Parameters
    ----------
    keep_default : bool, default False
        If False, replace OBIGT with minimal species (water, H+, e-) before
        loading WORM. If True, add WORM species to the existing OBIGT database.
    messages : bool, default True
        Whether to print informational messages

    Returns
    -------
    bool
        True if WORM database was loaded successfully, False otherwise

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; # Load WORM database (replaces default OBIGT)
    &gt;&gt;&gt; pychnosz.load_WORM()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Load WORM database while keeping default OBIGT species
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; pychnosz.load_WORM(keep_default=True)

    Notes
    -----
    The WORM database is downloaded from:
    - Species data: https://github.com/worm-portal/WORM-db/master/wrm_data_latest.csv
    - References: https://github.com/worm-portal/WORM-db/master/references.csv

    This feature is exclusive to the Python version of CHNOSZ.
    &#34;&#34;&#34;

    # WORM database URLs
    url_data = &#34;https://raw.githubusercontent.com/worm-portal/WORM-db/master/wrm_data_latest.csv&#34;
    url_refs = &#34;https://raw.githubusercontent.com/worm-portal/WORM-db/master/references.csv&#34;

    # Name for source_file column
    worm_source_name = &#34;wrm_data_latest.csv&#34;

    # Check if we can connect to the WORM database
    if not can_connect_to(url_data):
        if messages:
            print(&#34;load_WORM: could not reach WORM database repository&#34;)
        return False

    # Download WORM species data
    worm_data = download_worm_data(url_data)
    if worm_data is None:
        if messages:
            print(&#34;load_WORM: failed to download WORM species data&#34;)
        return False

    # Get the thermodynamic system
    thermo_sys = thermo()

    if not keep_default:
        # Keep only essential species (water, H+, e-)
        from ..core.info import info
        try:
            # Get indices for essential species
            essential_species = []
            for species in [&#34;water&#34;, &#34;H+&#34;, &#34;e-&#34;]:
                idx = info(species)
                if idx is not None:
                    if isinstance(idx, (list, tuple)):
                        essential_species.extend(idx)
                    else:
                        essential_species.append(idx)

            if essential_species:
                # Keep only essential species
                minimal_obigt = thermo_sys.obigt.loc[essential_species].copy()
                thermo_sys.obigt = minimal_obigt
        except Exception as e:
            if messages:
                print(f&#34;load_WORM: warning - error keeping essential species: {e}&#34;)

    # Add WORM species data (suppress add_OBIGT messages)
    try:
        # Add source_file column to worm_data before adding
        worm_data[&#39;source_file&#39;] = worm_source_name

        indices = add_OBIGT(worm_data, messages=False)
    except Exception as e:
        if messages:
            print(f&#34;load_WORM: failed to add WORM species: {e}&#34;)
        return False

    # Try to download and load WORM references
    if can_connect_to(url_refs):
        worm_refs = download_worm_data(url_refs)
        if worm_refs is not None:
            # Replace refs with WORM refs
            thermo_sys.refs = worm_refs

    # Update formula_ox if it exists in WORM data
    # This is already handled by add_OBIGT, but we ensure it&#39;s set correctly
    if &#39;formula_ox&#39; in thermo_sys.obigt.columns:
        formula_ox_df = pd.DataFrame({
            &#39;name&#39;: thermo_sys.obigt[&#39;name&#39;],
            &#39;formula_ox&#39;: thermo_sys.obigt[&#39;formula_ox&#39;]
        })
        formula_ox_df.index = thermo_sys.obigt.index
        thermo_sys.formula_ox = formula_ox_df

    # Print single summary message
    if messages:
        final_obigt = thermo_sys.obigt
        total_species = len(final_obigt)
        aqueous_species = len(final_obigt[final_obigt[&#39;state&#39;] == &#39;aq&#39;])
        print(f&#34;The WORM thermodynamic database has been loaded: {aqueous_species} aqueous, {total_species} total species&#34;)

    return True</code></pre>
</details>
<div class="desc"><p>Load the WORM (Water-Organic-Rock-Microbe) thermodynamic database.</p>
<p>This function downloads and loads the WORM database from the WORM-db GitHub
repository. By default, it replaces the OBIGT database with WORM data,
keeping only water, H+, and e- from the original database.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>keep_default</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If False, replace OBIGT with minimal species (water, H+, e-) before
loading WORM. If True, add WORM species to the existing OBIGT database.</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if WORM database was loaded successfully, False otherwise</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; # Load WORM database (replaces default OBIGT)
&gt;&gt;&gt; pychnosz.load_WORM()
&gt;&gt;&gt;
&gt;&gt;&gt; # Load WORM database while keeping default OBIGT species
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; pychnosz.load_WORM(keep_default=True)
</code></pre>
<h2 id="notes">Notes</h2>
<p>The WORM database is downloaded from:
- Species data: <a href="https://github.com/worm-portal/WORM-db/master/wrm_data_latest.csv">https://github.com/worm-portal/WORM-db/master/wrm_data_latest.csv</a>
- References: <a href="https://github.com/worm-portal/WORM-db/master/references.csv">https://github.com/worm-portal/WORM-db/master/references.csv</a></p>
<p>This feature is exclusive to the Python version of CHNOSZ.</p></div>
</dd>
<dt id="pychnosz.makeup"><code class="name flex">
<span>def <span class="ident">makeup</span></span>(<span>formula: str | int | List[str | int],<br>multiplier: float | List[float] = 1.0,<br>sum_formulas: bool = False,<br>count_zero: bool = False) ‑> Dict[str, float] | List[Dict[str, float]]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def makeup(formula: Union[str, int, List[Union[str, int]]], 
           multiplier: Union[float, List[float]] = 1.0,
           sum_formulas: bool = False,
           count_zero: bool = False) -&gt; Union[Dict[str, float], List[Dict[str, float]]]:
    &#34;&#34;&#34;
    Return elemental makeup (counts) of chemical formula(s).
    
    Handles formulas with parenthetical subformulas, suffixed formulas,
    charges, and fractional coefficients.
    
    Parameters
    ----------
    formula : str, int, or list
        Chemical formula(s) or species index(es)
    multiplier : float or list of float
        Multiplier(s) to apply to formula coefficients
    sum_formulas : bool
        If True, return sum of all formulas
    count_zero : bool
        If True, include zero counts for all elements appearing in any formula
        
    Returns
    -------
    dict or list of dict
        Elemental composition(s) as {element: count} dictionaries
        
    Examples
    --------
    &gt;&gt;&gt; makeup(&#34;H2O&#34;)
    {&#39;H&#39;: 2, &#39;O&#39;: 1}
    
    &gt;&gt;&gt; makeup(&#34;Ca(OH)2&#34;)
    {&#39;Ca&#39;: 1, &#39;O&#39;: 2, &#39;H&#39;: 2}
    
    &gt;&gt;&gt; makeup([&#34;H2O&#34;, &#34;CO2&#34;])
    [{&#39;H&#39;: 2, &#39;O&#39;: 1}, {&#39;C&#39;: 1, &#39;O&#39;: 2}]
    &#34;&#34;&#34;
    # Handle matrix input
    if isinstance(formula, np.ndarray) and formula.ndim == 2:
        return [makeup(formula[i, :]) for i in range(formula.shape[0])]
    
    # Handle named numeric objects (return unchanged)
    if isinstance(formula, dict) and all(isinstance(k, str) for k in formula.keys()):
        return formula
    
    # Handle list of named objects
    if isinstance(formula, list) and len(formula) &gt; 0:
        if isinstance(formula[0], dict) and all(isinstance(k, str) for k in formula[0].keys()):
            return formula
    
    # Prepare multiplier
    if not isinstance(multiplier, list):
        multiplier = [multiplier]
    
    # Handle multiple formulas
    if isinstance(formula, list):
        if len(multiplier) != 1 and len(multiplier) != len(formula):
            raise ValueError(&#34;multiplier does not have length = 1 or length = number of formulas&#34;)
        
        if len(multiplier) == 1:
            multiplier = multiplier * len(formula)
        
        # Get formulas for any species indices
        formula = get_formula(formula)
        
        results = []
        for i, f in enumerate(formula):
            result = makeup(f, multiplier[i])
            results.append(result)
        
        # Handle sum_formulas option
        if sum_formulas:
            all_elements = set()
            for result in results:
                if result is not None:
                    all_elements.update(result.keys())
            
            summed = {}
            for element in all_elements:
                summed[element] = sum(result.get(element, 0) for result in results if result is not None)
            return summed
        
        # Handle count_zero option
        elif count_zero:
            # Get all elements appearing in any formula
            all_elements = set()
            for result in results:
                if result is not None:
                    all_elements.update(result.keys())
            
            # Add zero counts for missing elements
            complete_results = []
            for result in results:
                if result is None:
                    complete_result = {element: np.nan for element in all_elements}
                else:
                    complete_result = {element: result.get(element, 0) for element in all_elements}
                complete_results.append(complete_result)
            
            return complete_results
        
        return results
    
    # Handle single formula
    if isinstance(formula, int):
        # Get formula from species index
        thermo_obj = thermo()
        if thermo_obj.obigt is not None:
            # Use .loc for label-based indexing (species indices are 1-based labels)
            if formula in thermo_obj.obigt.index:
                formula = thermo_obj.obigt.loc[formula, &#39;formula&#39;]
            else:
                raise FormulaError(f&#34;Species index {formula} not found in OBIGT database&#34;)
        else:
            raise FormulaError(&#34;Thermodynamic database not initialized&#34;)
    
    if formula is None or pd.isna(formula):
        return None
    
    # Parse single formula
    try:
        result = _parse_formula(str(formula))
        
        # Apply multiplier
        if multiplier[0] != 1.0:
            result = {element: count * multiplier[0] for element, count in result.items()}
        
        # Validate elements
        _validate_elements(result)
        
        return result
    
    except Exception as e:
        raise FormulaError(f&#34;Error parsing formula &#39;{formula}&#39;: {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Return elemental makeup (counts) of chemical formula(s).</p>
<p>Handles formulas with parenthetical subformulas, suffixed formulas,
charges, and fractional coefficients.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formula</code></strong> :&ensp;<code>str, int,</code> or <code>list</code></dt>
<dd>Chemical formula(s) or species index(es)</dd>
<dt><strong><code>multiplier</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code></dt>
<dd>Multiplier(s) to apply to formula coefficients</dd>
<dt><strong><code>sum_formulas</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, return sum of all formulas</dd>
<dt><strong><code>count_zero</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, include zero counts for all elements appearing in any formula</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> or <code>list</code> of <code>dict</code></dt>
<dd>Elemental composition(s) as {element: count} dictionaries</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; makeup(&quot;H2O&quot;)
{'H': 2, 'O': 1}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; makeup(&quot;Ca(OH)2&quot;)
{'Ca': 1, 'O': 2, 'H': 2}
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; makeup([&quot;H2O&quot;, &quot;CO2&quot;])
[{'H': 2, 'O': 1}, {'C': 1, 'O': 2}]
</code></pre></div>
</dd>
<dt id="pychnosz.mass"><code class="name flex">
<span>def <span class="ident">mass</span></span>(<span>formula: str | int | List[str | int]) ‑> float | List[float]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mass(formula: Union[str, int, List[Union[str, int]]]) -&gt; Union[float, List[float]]:
    &#34;&#34;&#34;
    Calculate molecular mass of chemical formula(s).
    
    Parameters
    ----------
    formula : str, int, or list
        Chemical formula(s) or species index(es)
        
    Returns
    -------
    float or list of float
        Molecular mass(es) in g/mol
    &#34;&#34;&#34;
    thermo_obj = thermo()
    if thermo_obj.element is None:
        raise RuntimeError(&#34;Element data not available&#34;)
    
    # Convert to stoichiometric matrix
    compositions = makeup(formula, count_zero=False)
    if not isinstance(compositions, list):
        compositions = [compositions]
    
    masses = []
    
    for comp in compositions:
        if comp is None:
            masses.append(np.nan)
            continue
        
        total_mass = 0.0
        for element, count in comp.items():
            if element == &#39;Z&#39;:
                continue  # Charge has no mass
            
            # Look up element mass
            element_data = thermo_obj.element[thermo_obj.element[&#39;element&#39;] == element]
            if len(element_data) == 0:
                raise FormulaError(f&#34;Element {element} not found in element database&#34;)
            
            element_mass = element_data.iloc[0][&#39;mass&#39;]
            total_mass += count * element_mass
        
        masses.append(total_mass)
    
    if len(masses) == 1:
        return masses[0]
    else:
        return masses</code></pre>
</details>
<div class="desc"><p>Calculate molecular mass of chemical formula(s).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formula</code></strong> :&ensp;<code>str, int,</code> or <code>list</code></dt>
<dd>Chemical formula(s) or species index(es)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code> or <code>list</code> of <code>float</code></dt>
<dd>Molecular mass(es) in g/mol</dd>
</dl></div>
</dd>
<dt id="pychnosz.mod_OBIGT"><code class="name flex">
<span>def <span class="ident">mod_OBIGT</span></span>(<span>*args, zap: bool = False, **kwargs) ‑> int | List[int]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mod_OBIGT(*args, zap: bool = False, **kwargs) -&gt; Union[int, List[int]]:
    &#34;&#34;&#34;
    Add or modify species in the thermodynamic database.

    This function replicates the behavior of R CHNOSZ mod.OBIGT() by allowing
    modification of existing species or addition of new species to thermo().obigt.

    Parameters
    ----------
    *args : int, str, list, or dict
        If first argument is numeric: species index or indices to modify
        If first argument is str: species name(s) to modify or add
        If first argument is list/dict: contains all parameters
    zap : bool, default False
        If True, clear all properties except state and model before updating
    **kwargs : any
        Named properties to set (e.g., G=-100, S=50, formula=&#34;H2O&#34;)
        Special properties: name, state, formula, model, E_units

    Returns
    -------
    int or list of int
        Species index or indices that were modified/added

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; # Add new species
    &gt;&gt;&gt; i = pychnosz.mod_OBIGT(&#34;myspecies&#34;, formula=&#34;C2H6&#34;, G=-100, S=50)

    &gt;&gt;&gt; # Modify existing species
    &gt;&gt;&gt; i = pychnosz.mod_OBIGT(&#34;water&#34;, state=&#34;liq&#34;, G=-56690)

    &gt;&gt;&gt; # Modify by index
    &gt;&gt;&gt; i_h2o = pychnosz.info(&#34;water&#34;, &#34;liq&#34;)
    &gt;&gt;&gt; i = pychnosz.mod_OBIGT(i_h2o, G=-56690)

    &gt;&gt;&gt; # Add multiple species
    &gt;&gt;&gt; i = pychnosz.mod_OBIGT([&#34;X&#34;, &#34;Y&#34;], formula=[&#34;C12&#34;, &#34;C13&#34;], state=[&#34;aq&#34;, &#34;cr&#34;])

    Notes
    -----
    This function modifies the thermo() object in place.
    The behavior exactly matches R CHNOSZ mod.OBIGT().
    &#34;&#34;&#34;

    # Get the thermo system
    thermo_sys = thermo()

    # Ensure the thermodynamic system is initialized
    if not thermo_sys.is_initialized() or thermo_sys.obigt is None:
        raise RuntimeError(&#34;Thermodynamic system not initialized. Run reset() first.&#34;)

    # Process arguments
    # If called with a dict as first arg (like R&#39;s list)
    if len(args) == 1 and isinstance(args[0], dict):
        params = args[0].copy()
    elif len(args) &gt; 0:
        # First positional argument could be species index or name
        first_arg = args[0]
        params = kwargs.copy()

        # Check if first argument is numeric (species index/indices)
        if isinstance(first_arg, (int, np.integer)):
            params[&#39;_index&#39;] = first_arg
        elif isinstance(first_arg, (list, tuple)) and len(first_arg) &gt; 0:
            if isinstance(first_arg[0], (int, np.integer)):
                params[&#39;_index&#39;] = list(first_arg)
            else:
                # First arg is list of names
                params[&#39;name&#39;] = list(first_arg)
        else:
            # First arg is species name
            # If first arg name is not in kwargs, it&#39;s the species name
            if &#39;name&#39; not in params:
                params[&#39;name&#39;] = first_arg
    else:
        params = kwargs.copy()

    # Validate we have at least a name/index and one property
    if &#39;_index&#39; not in params and &#39;name&#39; not in params:
        raise ValueError(&#34;Please supply at least a species name and a property to update&#34;)

    # Check that we have at least one property
    # When using index: exclude _index and state from property count
    # When using name: exclude name and state from property count (name is identifier, not property)
    if &#39;_index&#39; in params:
        property_keys = set(params.keys()) - {&#39;_index&#39;, &#39;state&#39;}
    else:
        property_keys = set(params.keys()) - {&#39;name&#39;, &#39;state&#39;}

    if len(property_keys) == 0:
        raise ValueError(&#34;Please supply at least a species name and a property to update&#34;)

    # Get species indices
    if &#39;_index&#39; in params:
        # Working with indices
        ispecies_input = params[&#39;_index&#39;]
        if not isinstance(ispecies_input, list):
            ispecies_input = [ispecies_input]
        del params[&#39;_index&#39;]

        # Get species names from indices
        speciesname = []
        for idx in ispecies_input:
            sp_info = info(idx)
            speciesname.append(sp_info[&#39;name&#39;].iloc[0] if isinstance(sp_info, pd.DataFrame) else sp_info[&#39;name&#39;])

        ispecies = ispecies_input
    else:
        # Working with names
        names = params.get(&#39;name&#39;)
        if not isinstance(names, list):
            names = [names]

        states = params.get(&#39;state&#39;)
        if states is not None and not isinstance(states, list):
            states = [states]

        speciesname = names

        # Find species indices
        ispecies = []
        for i, name in enumerate(names):
            state = states[i] if states and i &lt; len(states) else None
            try:
                if state:
                    idx = info(name, state)
                else:
                    idx = info(name)

                # info() returns an int if found
                if isinstance(idx, (int, np.integer)):
                    ispecies.append(int(idx))
                else:
                    # Not found
                    ispecies.append(None)
            except:
                # Species doesn&#39;t exist - will be added
                ispecies.append(None)

    # Convert params to DataFrame format
    # Handle list values vs single values
    nspecies = len(ispecies)
    param_df = {}
    for key, value in params.items():
        if isinstance(value, list):
            if len(value) != nspecies:
                raise ValueError(f&#34;Length of &#39;{key}&#39; ({len(value)}) doesn&#39;t match number of species ({nspecies})&#34;)
            param_df[key] = value
        else:
            param_df[key] = [value] * nspecies

    # Create DataFrame of arguments
    args_df = pd.DataFrame(param_df)

    # Get column names of OBIGT (handle split names with &#34;.&#34;)
    obigt_cols = thermo_sys.obigt.columns.tolist()

    # Map parameter names to column names (handle dot notation)
    # e.g., &#34;E.units&#34; can be accessed as &#34;E_units&#34;
    col_mapping = {}
    for col in obigt_cols:
        col_mapping[col] = col
        col_mapping[col.replace(&#39;_&#39;, &#39;.&#39;)] = col
        # Also map first part before dot
        if &#39;_&#39; in col:
            col_mapping[col.split(&#39;_&#39;)[0]] = col

    # Determine which columns we&#39;re updating
    icol = []
    icol_names = []
    for key in args_df.columns:
        if key in col_mapping:
            icol_names.append(col_mapping[key])
            icol.append(obigt_cols.index(col_mapping[key]))
        else:
            raise ValueError(f&#34;Property &#39;{key}&#39; not in thermo$OBIGT&#34;)

    # Separate new species from existing ones
    inew = [i for i, idx in enumerate(ispecies) if idx is None]
    iold = [i for i, idx in enumerate(ispecies) if idx is not None]

    result_indices = []

    # Add new species
    if len(inew) &gt; 0:
        # Create blank rows
        newrows = pd.DataFrame(index=range(len(inew)), columns=obigt_cols)
        newrows[:] = np.nan

        # Set defaults
        default_state = thermo_sys.opt.get(&#39;state&#39;, &#39;aq&#39;)
        default_units = thermo_sys.opt.get(&#39;E.units&#39;, &#39;J&#39;)

        newrows[&#39;state&#39;] = default_state
        newrows[&#39;E_units&#39;] = default_units

        # Set formula from name if not provided
        for i, idx in enumerate(inew):
            if &#39;formula&#39; in args_df.columns:
                newrows.at[i, &#39;formula&#39;] = args_df.iloc[idx][&#39;formula&#39;]
            else:
                newrows.at[i, &#39;formula&#39;] = args_df.iloc[idx][&#39;name&#39;]

        # Fill in provided columns
        for i, idx in enumerate(inew):
            for col_name in icol_names:
                if col_name in args_df.columns:
                    newrows.at[i, col_name] = args_df.at[idx, col_name]

        # Guess model from state
        for i in range(len(newrows)):
            if pd.isna(newrows.iloc[i][&#39;model&#39;]):
                if newrows.iloc[i][&#39;state&#39;] == &#39;aq&#39;:
                    newrows.at[i, &#39;model&#39;] = &#39;HKF&#39;
                else:
                    newrows.at[i, &#39;model&#39;] = &#39;CGL&#39;

        # Validate formulas
        for i in range(len(newrows)):
            formula = newrows.iloc[i][&#39;formula&#39;]
            try:
                makeup(formula)
            except Exception as e:
                warnings.warn(&#34;Please supply a valid chemical formula as the species name or in the &#39;formula&#39; argument&#34;)
                raise e

        # Add to OBIGT
        ntotal_before = len(thermo_sys.obigt)
        thermo_sys.obigt = pd.concat([thermo_sys.obigt, newrows], ignore_index=True)

        # Reset index to 1-based
        thermo_sys.obigt.index = range(1, len(thermo_sys.obigt) + 1)

        # Update ispecies for new entries
        for i, idx in enumerate(inew):
            new_idx = ntotal_before + i + 1
            if idx &lt; len(ispecies):
                ispecies[idx] = new_idx
            result_indices.append(new_idx)

            # Print message
            name = newrows.iloc[i][&#39;name&#39;]
            state = newrows.iloc[i][&#39;state&#39;]
            model = newrows.iloc[i][&#39;model&#39;]
            e_units = newrows.iloc[i][&#39;E_units&#39;]
            print(f&#34;mod_OBIGT: added {name}({state}) with {model} model and energy units of {e_units}&#34;)

    # Modify existing species
    if len(iold) &gt; 0:
        for i in iold:
            idx = ispecies[i]

            # Get old values
            oldprop = thermo_sys.obigt.loc[idx, icol_names].copy()
            state = thermo_sys.obigt.loc[idx, &#39;state&#39;]
            model = thermo_sys.obigt.loc[idx, &#39;model&#39;]

            # If zap, clear all values except state and model
            if zap:
                thermo_sys.obigt.loc[idx, :] = np.nan
                thermo_sys.obigt.loc[idx, &#39;state&#39;] = state
                thermo_sys.obigt.loc[idx, &#39;model&#39;] = model

            # Get new properties
            newprop = args_df.iloc[i][icol_names].copy()

            # Check if there&#39;s any change
            # Compare values element-wise, treating NaN as equal to NaN
            has_change = False
            for col in icol_names:
                old_val = oldprop[col] if col in oldprop.index else np.nan
                new_val = newprop[col] if col in newprop.index else np.nan

                # Check if both are NaN
                if pd.isna(old_val) and pd.isna(new_val):
                    continue
                # Check if one is NaN and other is not
                elif pd.isna(old_val) or pd.isna(new_val):
                    has_change = True
                    break
                # Check if values are different
                elif old_val != new_val:
                    has_change = True
                    break

            if not has_change:
                # No change
                print(f&#34;mod_OBIGT: no change for {speciesname[i]}({state})&#34;)
            else:
                # Update the data
                for col_name in icol_names:
                    if col_name in args_df.columns:
                        thermo_sys.obigt.loc[idx, col_name] = args_df.iloc[i][col_name]

                print(f&#34;mod_OBIGT: updated {speciesname[i]}({state})&#34;)

            result_indices.append(idx)

    # Return indices
    if len(result_indices) == 1:
        return result_indices[0]
    return result_indices</code></pre>
</details>
<div class="desc"><p>Add or modify species in the thermodynamic database.</p>
<p>This function replicates the behavior of R CHNOSZ mod.OBIGT() by allowing
modification of existing species or addition of new species to thermo().obigt.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>int, str, list,</code> or <code>dict</code></dt>
<dd>If first argument is numeric: species index or indices to modify
If first argument is str: species name(s) to modify or add
If first argument is list/dict: contains all parameters</dd>
<dt><strong><code>zap</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, clear all properties except state and model before updating</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>any</code></dt>
<dd>Named properties to set (e.g., G=-100, S=50, formula="H2O")
Special properties: name, state, formula, model, E_units</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>list</code> of <code>int</code></dt>
<dd>Species index or indices that were modified/added</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; # Add new species
&gt;&gt;&gt; i = pychnosz.mod_OBIGT(&quot;myspecies&quot;, formula=&quot;C2H6&quot;, G=-100, S=50)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Modify existing species
&gt;&gt;&gt; i = pychnosz.mod_OBIGT(&quot;water&quot;, state=&quot;liq&quot;, G=-56690)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Modify by index
&gt;&gt;&gt; i_h2o = pychnosz.info(&quot;water&quot;, &quot;liq&quot;)
&gt;&gt;&gt; i = pychnosz.mod_OBIGT(i_h2o, G=-56690)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Add multiple species
&gt;&gt;&gt; i = pychnosz.mod_OBIGT([&quot;X&quot;, &quot;Y&quot;], formula=[&quot;C12&quot;, &quot;C13&quot;], state=[&quot;aq&quot;, &quot;cr&quot;])
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function modifies the thermo() object in place.
The behavior exactly matches R CHNOSZ mod.OBIGT().</p></div>
</dd>
<dt id="pychnosz.pinfo"><code class="name flex">
<span>def <span class="ident">pinfo</span></span>(<span>protein: str | int | pandas.core.frame.DataFrame | List,<br>organism: str | None = None,<br>residue: bool = False,<br>regexp: bool = False) ‑> pandas.core.frame.DataFrame | numpy.ndarray | int</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pinfo(protein: Union[str, int, pd.DataFrame, List],
          organism: Optional[str] = None,
          residue: bool = False,
          regexp: bool = False) -&gt; Union[pd.DataFrame, np.ndarray, int]:
    &#34;&#34;&#34;
    Get protein information from thermo().protein.

    This function retrieves protein data from the thermodynamic database.
    The behavior depends on the input type:
    - DataFrame: returns the DataFrame (possibly per residue)
    - int or list of ints: returns rows from thermo().protein
    - str: searches for protein by name, returns row number(s)

    Parameters
    ----------
    protein : str, int, DataFrame, or list
        Protein identifier(s) or data
    organism : str, optional
        Organism identifier (used with protein name)
    residue : bool, default False
        Return per-residue amino acid composition
    regexp : bool, default False
        Use regular expression matching for protein search

    Returns
    -------
    DataFrame, array, or int
        Protein information or row numbers

    Examples
    --------
    &gt;&gt;&gt; # Get protein by name
    &gt;&gt;&gt; iprotein = pinfo(&#34;LYSC_CHICK&#34;)
    &gt;&gt;&gt; # Get protein data by row number
    &gt;&gt;&gt; protein_data = pinfo(iprotein)
    &#34;&#34;&#34;
    t_p = thermo().protein

    if t_p is None:
        raise RuntimeError(&#34;Protein database not loaded. Run reset() first.&#34;)

    # If input is a DataFrame, return it (possibly per residue)
    if isinstance(protein, pd.DataFrame):
        out = protein.copy()
        if residue:
            # Normalize by total amino acid count (columns 5:25)
            row_sums = out.iloc[:, 5:25].sum(axis=1)
            out.iloc[:, 4:24] = out.iloc[:, 4:24].div(row_sums, axis=0)
        return out

    # If input is numeric, get rows from thermo().protein
    if isinstance(protein, (int, np.integer)):
        protein = [protein]

    if isinstance(protein, (list, np.ndarray)) and all(isinstance(x, (int, np.integer)) for x in protein):
        # Get amino acid counts
        iproteins = list(range(len(t_p)))
        # Replace invalid indices with NaN
        protein_clean = [p if p in iproteins else np.nan for p in protein]
        # Filter out NaN values for indexing
        valid_indices = [p for p in protein_clean if not np.isnan(p)]

        if not valid_indices:
            return pd.DataFrame()

        out = t_p.iloc[valid_indices].copy()

        # Compute per-residue counts if requested
        if residue:
            row_sums = out.iloc[:, 5:25].sum(axis=1)
            out.iloc[:, 4:24] = out.iloc[:, 4:24].div(row_sums, axis=0)

        return out

    # If input is string or list of strings, search for protein
    if isinstance(protein, str):
        protein = [protein]

    if isinstance(protein, list) and all(isinstance(x, str) for x in protein):
        # Search for protein or protein_organism in thermo().protein
        t_p_names = t_p[&#39;protein&#39;] + &#39;_&#39; + t_p[&#39;organism&#39;]

        if regexp:
            # Use regular expression matching
            matches = []
            for prot in protein:
                iprotein = t_p[&#39;protein&#39;].str.contains(prot, regex=True, na=False)
                if organism is not None:
                    iorganism = t_p[&#39;organism&#39;].str.contains(organism, regex=True, na=False)
                    iprotein = iprotein &amp; iorganism
                indices = np.where(iprotein)[0]
                if len(indices) &gt; 0:
                    matches.extend(indices.tolist())
                else:
                    matches.append(np.nan)

            if len(matches) == 1:
                if np.isnan(matches[0]):
                    return np.nan
                return int(matches[0])
            return np.array(matches)
        else:
            # Exact matching
            if organism is None:
                my_names = protein
            else:
                my_names = [f&#34;{p}_{organism}&#34; for p in protein]

            # Find matches
            matches = []
            for name in my_names:
                idx = np.where(t_p_names == name)[0]
                if len(idx) &gt; 0:
                    matches.append(idx[0])
                else:
                    matches.append(np.nan)

            if len(matches) == 1:
                if np.isnan(matches[0]):
                    return np.nan
                return int(matches[0])
            return np.array(matches)

    raise TypeError(f&#34;Unsupported protein type: {type(protein)}&#34;)</code></pre>
</details>
<div class="desc"><p>Get protein information from thermo().protein.</p>
<p>This function retrieves protein data from the thermodynamic database.
The behavior depends on the input type:
- DataFrame: returns the DataFrame (possibly per residue)
- int or list of ints: returns rows from thermo().protein
- str: searches for protein by name, returns row number(s)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>protein</code></strong> :&ensp;<code>str, int, DataFrame,</code> or <code>list</code></dt>
<dd>Protein identifier(s) or data</dd>
<dt><strong><code>organism</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Organism identifier (used with protein name)</dd>
<dt><strong><code>residue</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Return per-residue amino acid composition</dd>
<dt><strong><code>regexp</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Use regular expression matching for protein search</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame, array,</code> or <code>int</code></dt>
<dd>Protein information or row numbers</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get protein by name
&gt;&gt;&gt; iprotein = pinfo(&quot;LYSC_CHICK&quot;)
&gt;&gt;&gt; # Get protein data by row number
&gt;&gt;&gt; protein_data = pinfo(iprotein)
</code></pre></div>
</dd>
<dt id="pychnosz.protein_OBIGT"><code class="name flex">
<span>def <span class="ident">protein_OBIGT</span></span>(<span>protein: int | List[int] | pandas.core.frame.DataFrame,<br>organism: str | None = None,<br>state: str | None = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protein_OBIGT(protein: Union[int, List[int], pd.DataFrame],
                 organism: Optional[str] = None,
                 state: Optional[str] = None) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate protein properties using group additivity.

    This function calculates thermodynamic properties of proteins
    from amino acid composition using the group additivity approach.

    Parameters
    ----------
    protein : int, list of int, or DataFrame
        Protein identifier(s) or amino acid composition data
    organism : str, optional
        Organism identifier
    state : str, optional
        Physical state (&#39;aq&#39; or &#39;cr&#39;). If None, uses thermo().opt[&#39;state&#39;]

    Returns
    -------
    DataFrame
        Thermodynamic properties in OBIGT format

    Examples
    --------
    &gt;&gt;&gt; iprotein = pinfo(&#34;LYSC_CHICK&#34;)
    &gt;&gt;&gt; props = protein_OBIGT(iprotein)
    &#34;&#34;&#34;
    # Get amino acid composition
    aa = pinfo(pinfo(protein, organism))

    if not isinstance(aa, pd.DataFrame):
        raise TypeError(&#34;Could not retrieve protein data&#34;)

    # Get state
    if state is None:
        state = thermo().opt.get(&#39;state&#39;, &#39;aq&#39;)

    # The names of the protein backbone groups depend on the state
    # [UPBB] for aq or [PBB] for cr
    if state == &#39;aq&#39;:
        bbgroup = &#39;UPBB&#39;
    else:
        bbgroup = &#39;PBB&#39;

    # Names of the AABB, sidechain and protein backbone groups
    aa_cols = aa.columns[5:25].tolist()  # Get amino acid column names
    groups = [&#39;AABB&#39;] + aa_cols + [bbgroup]

    # Put brackets around the group names
    groups = [f&#34;[{g}]&#34; for g in groups]

    # The row numbers of the groups in thermo().OBIGT
    from ..core.info import info

    groups_state = [f&#34;{g}&#34; for g in groups]
    obigt = thermo().obigt

    # Find groups in OBIGT
    igroup = []
    for group_name in groups_state:
        # Search for the group with the specified state
        matches = obigt[(obigt[&#39;name&#39;] == group_name) &amp; (obigt[&#39;state&#39;] == state)]
        if len(matches) &gt; 0:
            igroup.append(matches.index[0])
        else:
            # Try without brackets if not found
            group_alt = group_name.strip(&#39;[]&#39;)
            matches = obigt[(obigt[&#39;name&#39;] == group_alt) &amp; (obigt[&#39;state&#39;] == state)]
            if len(matches) &gt; 0:
                igroup.append(matches.index[0])
            else:
                raise ValueError(f&#34;Group {group_name} not found in OBIGT for state {state}&#34;)

    # The properties are in columns 9:21 of thermo().OBIGT (G, H, S, Cp, V, etc.)
    # Column indices: G=9, H=10, S=11, Cp=12, V=13, a1.a=14, a2.b=15, a3.c=16, a4.d=17, c1.e=18, c2.f=19, omega.lambda=20, z.T=21
    groupprops = obigt.loc[igroup, obigt.columns[9:22]]

    # The elements in each of the groups
    groupelements = i2A(igroup)

    results = []

    # Process each protein
    for idx in range(len(aa)):
        aa_row = aa.iloc[idx]

        # Numbers of groups: chains [=AABB], sidechains, protein backbone
        nchains = float(aa_row.iloc[4])  # chains column
        length = float(aa_row.iloc[5:25].sum())  # sum of amino acids
        npbb = length - nchains

        # Create ngroups array
        ngroups = np.array([nchains] + aa_row.iloc[5:25].tolist() + [npbb], dtype=float)

        # Calculate thermodynamic properties by group additivity
        eos = (groupprops.values * ngroups[:, np.newaxis]).sum(axis=0)

        # Calculate formula
        f_in = (groupelements.values * ngroups[:, np.newaxis]).sum(axis=0).round(3)

        # Remove elements that don&#39;t appear
        element_names = groupelements.columns
        f_dict = {elem: f_in[i] for i, elem in enumerate(element_names) if f_in[i] != 0}

        # Turn it into a formula string
        f = as_chemical_formula(f_dict)

        # Species name
        name = f&#34;{aa_row[&#39;protein&#39;]}_{aa_row[&#39;organism&#39;]}&#34;

        # Print message
        print(f&#34;protein_OBIGT: found {name} ({f}, {round(length, 3)} residues)&#34;)

        ref = aa_row[&#39;ref&#39;]

        # Include &#39;model&#39; column
        model = &#39;HKF&#39; if state == &#39;aq&#39; else &#39;CGL&#39;

        # Create header
        header = {
            &#39;name&#39;: name,
            &#39;abbrv&#39;: None,
            &#39;formula&#39;: f,
            &#39;state&#39;: state,
            &#39;ref1&#39;: ref,
            &#39;ref2&#39;: None,
            &#39;date&#39;: None,
            &#39;model&#39;: model,
            &#39;E_units&#39;: &#39;cal&#39;
        }

        # Combine header and eos
        eosout = {**header, **dict(zip(groupprops.columns, eos))}
        results.append(eosout)

    # Convert to DataFrame
    out = pd.DataFrame(results)
    out.reset_index(drop=True, inplace=True)

    return out</code></pre>
</details>
<div class="desc"><p>Calculate protein properties using group additivity.</p>
<p>This function calculates thermodynamic properties of proteins
from amino acid composition using the group additivity approach.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>protein</code></strong> :&ensp;<code>int, list</code> of <code>int,</code> or <code>DataFrame</code></dt>
<dd>Protein identifier(s) or amino acid composition data</dd>
<dt><strong><code>organism</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Organism identifier</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Physical state ('aq' or 'cr'). If None, uses thermo().opt['state']</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Thermodynamic properties in OBIGT format</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; iprotein = pinfo(&quot;LYSC_CHICK&quot;)
&gt;&gt;&gt; props = protein_OBIGT(iprotein)
</code></pre></div>
</dd>
<dt id="pychnosz.protein_basis"><code class="name flex">
<span>def <span class="ident">protein_basis</span></span>(<span>protein: int | List[int] | pandas.core.frame.DataFrame,<br>T: float = 25.0,<br>normalize: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protein_basis(protein: Union[int, List[int], pd.DataFrame],
                 T: float = 25.0,
                 normalize: bool = False) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate coefficients of basis species in protein formation reactions.

    Parameters
    ----------
    protein : int, list of int, or DataFrame
        Protein identifier(s) or amino acid composition data
    T : float, default 25.0
        Temperature in degrees Celsius
    normalize : bool, default False
        Normalize by protein length

    Returns
    -------
    DataFrame
        Coefficients of basis species

    Examples
    --------
    &gt;&gt;&gt; from pychnosz import *
    &gt;&gt;&gt; basis(&#34;CHNOSe&#34;)
    &gt;&gt;&gt; iprotein = pinfo(&#34;LYSC_CHICK&#34;)
    &gt;&gt;&gt; coeffs = protein_basis(iprotein)
    &#34;&#34;&#34;
    # Get amino acid composition
    aa = pinfo(pinfo(protein))

    if not isinstance(aa, pd.DataFrame):
        raise TypeError(&#34;Could not retrieve protein data&#34;)

    # Get protein formulas
    pf = protein_formula(aa)

    # Calculate coefficients of basis species in formation reactions
    sb = species_basis(pf)

    # Calculate ionization states if H+ is a basis species
    t = thermo()
    if t.basis is not None:
        basis_species = t.basis.index.tolist()
        if &#39;H+&#39; in basis_species:
            iHplus = basis_species.index(&#39;H+&#39;)
            pH = -t.basis.loc[&#39;H+&#39;, &#39;logact&#39;]
            Z = ionize_aa(aa, T=T, pH=pH).iloc[0, :]
            sb.iloc[:, iHplus] = sb.iloc[:, iHplus] + Z.values

    # Normalize by length if requested
    if normalize:
        plen = protein_length(aa)
        sb = sb.div(plen, axis=0)

    return sb</code></pre>
</details>
<div class="desc"><p>Calculate coefficients of basis species in protein formation reactions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>protein</code></strong> :&ensp;<code>int, list</code> of <code>int,</code> or <code>DataFrame</code></dt>
<dd>Protein identifier(s) or amino acid composition data</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code>, default <code>25.0</code></dt>
<dd>Temperature in degrees Celsius</dd>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Normalize by protein length</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Coefficients of basis species</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz import *
&gt;&gt;&gt; basis(&quot;CHNOSe&quot;)
&gt;&gt;&gt; iprotein = pinfo(&quot;LYSC_CHICK&quot;)
&gt;&gt;&gt; coeffs = protein_basis(iprotein)
</code></pre></div>
</dd>
<dt id="pychnosz.protein_formula"><code class="name flex">
<span>def <span class="ident">protein_formula</span></span>(<span>protein: int | List[int] | pandas.core.frame.DataFrame,<br>organism: str | None = None,<br>residue: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protein_formula(protein: Union[int, List[int], pd.DataFrame],
                   organism: Optional[str] = None,
                   residue: bool = False) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Calculate chemical formulas of proteins.

    Parameters
    ----------
    protein : int, list of int, or DataFrame
        Protein identifier(s) or amino acid composition data
    organism : str, optional
        Organism identifier (used with protein number)
    residue : bool, default False
        Return per-residue formula

    Returns
    -------
    DataFrame
        Chemical formulas with elements C, H, N, O, S as columns

    Examples
    --------
    &gt;&gt;&gt; iprotein = pinfo(&#34;LYSC_CHICK&#34;)
    &gt;&gt;&gt; formula = protein_formula(iprotein)
    &#34;&#34;&#34;
    # Get amino acid composition
    aa = pinfo(pinfo(protein, organism))

    if not isinstance(aa, pd.DataFrame):
        raise TypeError(&#34;Could not retrieve protein data&#34;)

    # Get group formulas
    rf = group_formulas()

    # Matrix multiplication: amino acid counts * residue formulas
    # Columns 5:25 contain amino acid counts (excluding chains column at 4)
    # We need to add H2O (chains column) separately
    aa_counts = aa.iloc[:, 5:25].values.astype(float)
    chains = aa.iloc[:, 4].values.astype(float)
    rf_values = rf.iloc[1:, :].values.astype(float)  # Skip H2O row, use amino acid residues
    rf_H2O = rf.iloc[0, :].values.astype(float)  # H2O row

    # Calculate protein formula: amino acids + H2O for chains
    out = np.dot(aa_counts, rf_values) + np.outer(chains, rf_H2O)

    # Normalize by residue if requested
    if residue:
        row_sums = aa.iloc[:, 5:25].sum(axis=1).values
        out = out / row_sums[:, np.newaxis]

    # Create DataFrame with protein names as index
    protein_names = aa[&#39;protein&#39;] + &#39;_&#39; + aa[&#39;organism&#39;]
    # Make names unique if there are duplicates
    if protein_names.duplicated().any():
        counts = {}
        unique_names = []
        for name in protein_names:
            if name in counts:
                counts[name] += 1
                unique_names.append(f&#34;{name}.{counts[name]}&#34;)
            else:
                counts[name] = 0
                unique_names.append(name)
        protein_names = unique_names

    result = pd.DataFrame(out,
                         index=protein_names,
                         columns=[&#39;C&#39;, &#39;H&#39;, &#39;N&#39;, &#39;O&#39;, &#39;S&#39;])

    return result</code></pre>
</details>
<div class="desc"><p>Calculate chemical formulas of proteins.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>protein</code></strong> :&ensp;<code>int, list</code> of <code>int,</code> or <code>DataFrame</code></dt>
<dd>Protein identifier(s) or amino acid composition data</dd>
<dt><strong><code>organism</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Organism identifier (used with protein number)</dd>
<dt><strong><code>residue</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Return per-residue formula</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DataFrame</code></dt>
<dd>Chemical formulas with elements C, H, N, O, S as columns</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; iprotein = pinfo(&quot;LYSC_CHICK&quot;)
&gt;&gt;&gt; formula = protein_formula(iprotein)
</code></pre></div>
</dd>
<dt id="pychnosz.protein_length"><code class="name flex">
<span>def <span class="ident">protein_length</span></span>(<span>protein: int | List[int] | pandas.core.frame.DataFrame,<br>organism: str | None = None) ‑> int | numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def protein_length(protein: Union[int, List[int], pd.DataFrame],
                   organism: Optional[str] = None) -&gt; Union[int, np.ndarray]:
    &#34;&#34;&#34;
    Calculate the length(s) of proteins.

    Parameters
    ----------
    protein : int, list of int, or DataFrame
        Protein identifier(s) or amino acid composition data
    organism : str, optional
        Organism identifier (used with protein number)

    Returns
    -------
    int or array
        Protein length(s) in amino acid residues

    Examples
    --------
    &gt;&gt;&gt; iprotein = pinfo(&#34;LYSC_CHICK&#34;)
    &gt;&gt;&gt; length = protein_length(iprotein)
    &#34;&#34;&#34;
    # Get amino acid composition
    aa = pinfo(pinfo(protein, organism))

    if isinstance(aa, pd.DataFrame):
        # Use sum on the columns containing amino acid counts (columns 5:25)
        pl = aa.iloc[:, 5:25].sum(axis=1).values
        return pl
    else:
        return 0</code></pre>
</details>
<div class="desc"><p>Calculate the length(s) of proteins.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>protein</code></strong> :&ensp;<code>int, list</code> of <code>int,</code> or <code>DataFrame</code></dt>
<dd>Protein identifier(s) or amino acid composition data</dd>
<dt><strong><code>organism</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Organism identifier (used with protein number)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code> or <code>array</code></dt>
<dd>Protein length(s) in amino acid residues</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; iprotein = pinfo(&quot;LYSC_CHICK&quot;)
&gt;&gt;&gt; length = protein_length(iprotein)
</code></pre></div>
</dd>
<dt id="pychnosz.quartz_coesite"><code class="name flex">
<span>def <span class="ident">quartz_coesite</span></span>(<span>PAR, T, P)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def quartz_coesite(PAR, T, P):
    # the corrections are 0 for anything other than quartz and coesite
    if not PAR[&#34;name&#34;] in [&#34;quartz&#34;, &#34;coesite&#34;]:
        n = T.size if isinstance(T, np.ndarray) else 1
        return(dict(G=np.zeros(n), H=np.zeros(n), S=np.zeros(n), V=np.zeros(n)))

    # Vectorized version
    T = np.atleast_1d(T)
    P = np.atleast_1d(P)

    # Tr, Pr and TtPr (transition temperature at Pr)
    Pr = 1      # bar
    Tr = 298.15 # K
    TtPr = 848  # K
    # constants from SUP92D.f
    aa = 549.824
    ba = 0.65995
    ca = -0.4973e-4
    VPtTta = 23.348
    VPrTtb = 23.72
    Stran = 0.342
    # constants from REAC92D.f
    VPrTra = 22.688 # VPrTr(a-quartz)
    Vdiff = 2.047   # VPrTr(a-quartz) - VPrTr(coesite)
    k = 38.5       # dPdTtr(a/b-quartz)
    #k &lt;- 38.45834    # calculated in CHNOSZ: dPdTtr(info(&#34;quartz&#34;))
    # code adapted from REAC92D.f
    qphase = PAR[&#34;state&#34;].replace(&#34;cr&#34;, &#34;&#34;)

    if qphase == &#34;2&#34;:
        Pstar = P.copy()
        Sstar = np.zeros_like(T)
        V = np.full_like(T, VPrTtb)
    else:
        Pstar = Pr + k * (T - TtPr)
        Sstar = np.full_like(T, Stran)
        V = VPrTra + ca*(P-Pr) + (VPtTta - VPrTra - ca*(P-Pr))*(T-Tr) / (TtPr + (P-Pr)/k - Tr)

    # Apply condition: if T &lt; TtPr
    below_transition = T &lt; TtPr
    Pstar = np.where(below_transition, Pr, Pstar)
    Sstar = np.where(below_transition, 0, Sstar)

    if PAR[&#34;name&#34;] == &#34;coesite&#34;:
        VPrTra = VPrTra - Vdiff
        VPrTtb = VPrTtb - Vdiff
        V = V - Vdiff

    cm3bar_to_cal = 0.023901488

    # Vectorized log calculation
    with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
        log_term = np.log((aa + P/k) / (aa + Pstar/k))
        log_term = np.where(np.isfinite(log_term), log_term, 0)

    GVterm = cm3bar_to_cal * (VPrTra * (P - Pstar) + VPrTtb * (Pstar - Pr) - \
        0.5 * ca * (2 * Pr * (P - Pstar) - (P**2 - Pstar**2)) - \
        ca * k * (T - Tr) * (P - Pstar) + \
        k * (ba + aa * ca * k) * (T - Tr) * log_term)
    SVterm = cm3bar_to_cal * (-k * (ba + aa * ca * k) * log_term + ca * k * (P - Pstar)) - Sstar

    # note the minus sign on &#34;SVterm&#34; in order that intdVdTdP has the correct sign
    return dict(intVdP=GVterm, intdVdTdP=-SVterm, V=V)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="pychnosz.ratlab"><code class="name flex">
<span>def <span class="ident">ratlab</span></span>(<span>top: str = 'K+',<br>bottom: str = 'H+',<br>molality: bool = False,<br>reverse_charge: bool = False) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ratlab(top: str = &#34;K+&#34;, bottom: str = &#34;H+&#34;, molality: bool = False,
           reverse_charge: bool = False) -&gt; str:
    &#34;&#34;&#34;
    Create formatted text label for activity ratio.

    This function generates a LaTeX-formatted string suitable for use as
    axis labels in matplotlib plots, showing the ratio of activities of
    two ions raised to appropriate powers based on their charges.

    Parameters
    ----------
    top : str, default &#34;K+&#34;
        Chemical formula for the numerator ion
    bottom : str, default &#34;H+&#34;
        Chemical formula for the denominator ion
    molality : bool, default False
        If True, use &#39;m&#39; (molality) instead of &#39;a&#39; (activity)
    reverse_charge : bool, default False
        If True, reverse charge order in formatting (e.g., &#34;Fe+3&#34; becomes &#34;Fe^{3+}&#34;)
        If False, keep original order (e.g., &#34;Fe+3&#34; becomes &#34;Fe^{+3}&#34;)

    Returns
    -------
    str
        LaTeX-formatted string for the activity ratio label

    Examples
    --------
    &gt;&gt;&gt; ratlab(&#34;K+&#34;, &#34;H+&#34;)
    &#39;log($a_{K^{+}}$ / $a_{H^{+}}$)&#39;

    &gt;&gt;&gt; ratlab(&#34;Ca+2&#34;, &#34;H+&#34;)
    &#39;log($a_{Ca^{+2}}$ / $a_{H^{+}}^{2}$)&#39;

    &gt;&gt;&gt; ratlab(&#34;Ca+2&#34;, &#34;H+&#34;, reverse_charge=True)
    &#39;log($a_{Ca^{2+}}$ / $a_{H^{+}}^{2}$)&#39;

    &gt;&gt;&gt; ratlab(&#34;Mg+2&#34;, &#34;Ca+2&#34;)
    &#39;log($a_{Mg^{+2}}$ / $a_{Ca^{+2}}$)&#39;

    Notes
    -----
    The exponents are determined by the charges of the ions to maintain
    charge balance in the ratio. For example, for Ca+2/H+, the H+ term
    is squared because Ca has a +2 charge.

    The output format is compatible with matplotlib&#39;s LaTeX rendering.
    In R CHNOSZ, this uses plotmath expressions; here we use LaTeX strings
    that matplotlib can render.
    &#34;&#34;&#34;
    # Get the charges of the ions
    makeup_top = makeup(top)
    makeup_bottom = makeup(bottom)

    Z_top = makeup_top.get(&#39;Z&#39;, 0)
    Z_bottom = makeup_bottom.get(&#39;Z&#39;, 0)

    # The exponents for charge balance
    # If top has charge +2 and bottom has +1, bottom gets exponent 2
    exp_bottom = abs(Z_top)
    exp_top = abs(Z_bottom)

    # Format exponents (don&#39;t show if = 1)
    exp_top_str = &#34;&#34; if exp_top == 1 else f&#34;^{{{int(exp_top)}}}&#34;
    exp_bottom_str = &#34;&#34; if exp_bottom == 1 else f&#34;^{{{int(exp_bottom)}}}&#34;

    # Format the ion formulas for display
    top_formatted = _format_species_latex(top, reverse_charge=reverse_charge)
    bottom_formatted = _format_species_latex(bottom, reverse_charge=reverse_charge)

    # Choose activity or molality symbol
    a = &#34;m&#34; if molality else &#34;a&#34;

    # Build the expression
    # Format: log(a_top^exp / a_bottom^exp)
    numerator = f&#34;${a}_{{{top_formatted}}}{exp_top_str}$&#34;
    denominator = f&#34;${a}_{{{bottom_formatted}}}{exp_bottom_str}$&#34;

    label = f&#34;log({numerator} / {denominator})&#34;

    return label</code></pre>
</details>
<div class="desc"><p>Create formatted text label for activity ratio.</p>
<p>This function generates a LaTeX-formatted string suitable for use as
axis labels in matplotlib plots, showing the ratio of activities of
two ions raised to appropriate powers based on their charges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>top</code></strong> :&ensp;<code>str</code>, default <code>"K+"</code></dt>
<dd>Chemical formula for the numerator ion</dd>
<dt><strong><code>bottom</code></strong> :&ensp;<code>str</code>, default <code>"H+"</code></dt>
<dd>Chemical formula for the denominator ion</dd>
<dt><strong><code>molality</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, use 'm' (molality) instead of 'a' (activity)</dd>
<dt><strong><code>reverse_charge</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, reverse charge order in formatting (e.g., "Fe+3" becomes "Fe^{3+}")
If False, keep original order (e.g., "Fe+3" becomes "Fe^{+3}")</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>LaTeX-formatted string for the activity ratio label</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ratlab(&quot;K+&quot;, &quot;H+&quot;)
'log($a_{K^{+}}$ / $a_{H^{+}}$)'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; ratlab(&quot;Ca+2&quot;, &quot;H+&quot;)
'log($a_{Ca^{+2}}$ / $a_{H^{+}}^{2}$)'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; ratlab(&quot;Ca+2&quot;, &quot;H+&quot;, reverse_charge=True)
'log($a_{Ca^{2+}}$ / $a_{H^{+}}^{2}$)'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; ratlab(&quot;Mg+2&quot;, &quot;Ca+2&quot;)
'log($a_{Mg^{+2}}$ / $a_{Ca^{+2}}$)'
</code></pre>
<h2 id="notes">Notes</h2>
<p>The exponents are determined by the charges of the ions to maintain
charge balance in the ratio. For example, for Ca+2/H+, the H+ term
is squared because Ca has a +2 charge.</p>
<p>The output format is compatible with matplotlib's LaTeX rendering.
In R CHNOSZ, this uses plotmath expressions; here we use LaTeX strings
that matplotlib can render.</p></div>
</dd>
<dt id="pychnosz.ratlab_html"><code class="name flex">
<span>def <span class="ident">ratlab_html</span></span>(<span>top: str = 'K+', bottom: str = 'H+', molality: bool = False) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ratlab_html(top: str = &#34;K+&#34;, bottom: str = &#34;H+&#34;, molality: bool = False) -&gt; str:
    &#34;&#34;&#34;
    Create HTML-formatted text label for activity ratio (for Plotly/HTML rendering).

    This function generates an HTML-formatted string suitable for use with
    Plotly interactive plots, showing the ratio of activities of two ions
    raised to appropriate powers based on their charges.

    This is a companion function to ratlab() which produces LaTeX format for
    matplotlib. Use ratlab_html() when creating labels for diagram(..., interactive=True).

    Parameters
    ----------
    top : str, default &#34;K+&#34;
        Chemical formula for the numerator ion
    bottom : str, default &#34;H+&#34;
        Chemical formula for the denominator ion
    molality : bool, default False
        If True, use &#39;m&#39; (molality) instead of &#39;a&#39; (activity)

    Returns
    -------
    str
        HTML-formatted string for the activity ratio label

    Examples
    --------
    &gt;&gt;&gt; ratlab_html(&#34;K+&#34;, &#34;H+&#34;)
    &#39;log(a&lt;sub&gt;K&lt;sup&gt;+&lt;/sup&gt;&lt;/sub&gt;/a&lt;sub&gt;H&lt;sup&gt;+&lt;/sup&gt;&lt;/sub&gt;)&#39;

    &gt;&gt;&gt; ratlab_html(&#34;Ca+2&#34;, &#34;H+&#34;)
    &#39;log(a&lt;sub&gt;Ca&lt;sup&gt;2+&lt;/sup&gt;&lt;/sub&gt;/a&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;H&lt;sup&gt;+&lt;/sup&gt;&lt;/sub&gt;)&#39;

    &gt;&gt;&gt; ratlab_html(&#34;Mg+2&#34;, &#34;Ca+2&#34;)
    &#39;log(a&lt;sub&gt;Mg&lt;sup&gt;2+&lt;/sup&gt;&lt;/sub&gt;/a&lt;sub&gt;Ca&lt;sup&gt;2+&lt;/sup&gt;&lt;/sub&gt;)&#39;

    Notes
    -----
    The exponents are determined by the charges of the ions to maintain
    charge balance in the ratio. For example, for Ca+2/H+, the H+ term
    is squared because Ca has a +2 charge.

    The output format uses HTML tags (&lt;sub&gt;, &lt;sup&gt;) compatible with Plotly.
    For matplotlib plots with LaTeX rendering, use ratlab() instead.

    Requires: WORMutils (for chemlabel) and chemparse (for parse_formula)

    See Also
    --------
    ratlab : LaTeX version for matplotlib
    &#34;&#34;&#34;
    if not _HTML_DEPS_AVAILABLE:
        raise ImportError(
            &#34;ratlab_html() requires &#39;WORMutils&#39; and &#39;chemparse&#39; packages.\n&#34;
            &#34;Install with: pip install WORMutils chemparse&#34;
        )

    # Parse the formulas to get charges
    top_formula = parse_formula(top)
    if &#34;+&#34; in top_formula.keys():
        top_charge = top_formula[&#34;+&#34;]
    elif &#34;-&#34; in top_formula.keys():
        top_charge = -top_formula[&#34;-&#34;]
    else:
        raise ValueError(&#34;Cannot create an ion ratio involving one or more neutral species.&#34;)

    bottom_formula = parse_formula(bottom)
    if &#34;+&#34; in bottom_formula.keys():
        bottom_charge = bottom_formula[&#34;+&#34;]
    elif &#34;-&#34; in bottom_formula.keys():
        bottom_charge = -bottom_formula[&#34;-&#34;]
    else:
        raise ValueError(&#34;Cannot create an ion ratio involving one or more neutral species.&#34;)

    # Convert to integers if whole numbers
    if top_charge.is_integer():
        top_charge = int(top_charge)

    if bottom_charge.is_integer():
        bottom_charge = int(bottom_charge)

    # The exponents for charge balance
    # If top has charge +2 and bottom has +1, bottom gets exponent 2
    exp_bottom = abs(top_charge)
    exp_top = abs(bottom_charge)

    # Format exponents as superscripts (don&#39;t show if = 1)
    if exp_top != 1:
        top_exp_str = &#34;&lt;sup&gt;&#34; + str(exp_top) + &#34;&lt;/sup&gt;&#34;
    else:
        top_exp_str = &#34;&#34;

    if exp_bottom != 1:
        bottom_exp_str = &#34;&lt;sup&gt;&#34; + str(exp_bottom) + &#34;&lt;/sup&gt;&#34;
    else:
        bottom_exp_str = &#34;&#34;

    # Choose activity or molality symbol
    if molality:
        sym = &#34;m&#34;
    else:
        sym = &#34;a&#34;

    # Format the chemical formulas with chemlabel
    top_formatted = chemlabel(top)
    bottom_formatted = chemlabel(bottom)

    # Build the HTML expression
    # Format: log(a_top^exp / a_bottom^exp)
    return f&#34;log({sym}{top_exp_str}&lt;sub&gt;{top_formatted}&lt;/sub&gt;/{sym}{bottom_exp_str}&lt;sub&gt;{bottom_formatted}&lt;/sub&gt;)&#34;</code></pre>
</details>
<div class="desc"><p>Create HTML-formatted text label for activity ratio (for Plotly/HTML rendering).</p>
<p>This function generates an HTML-formatted string suitable for use with
Plotly interactive plots, showing the ratio of activities of two ions
raised to appropriate powers based on their charges.</p>
<p>This is a companion function to ratlab() which produces LaTeX format for
matplotlib. Use ratlab_html() when creating labels for diagram(&hellip;, interactive=True).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>top</code></strong> :&ensp;<code>str</code>, default <code>"K+"</code></dt>
<dd>Chemical formula for the numerator ion</dd>
<dt><strong><code>bottom</code></strong> :&ensp;<code>str</code>, default <code>"H+"</code></dt>
<dd>Chemical formula for the denominator ion</dd>
<dt><strong><code>molality</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, use 'm' (molality) instead of 'a' (activity)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>HTML-formatted string for the activity ratio label</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; ratlab_html(&quot;K+&quot;, &quot;H+&quot;)
'log(a&lt;sub&gt;K&lt;sup&gt;+&lt;/sup&gt;&lt;/sub&gt;/a&lt;sub&gt;H&lt;sup&gt;+&lt;/sup&gt;&lt;/sub&gt;)'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; ratlab_html(&quot;Ca+2&quot;, &quot;H+&quot;)
'log(a&lt;sub&gt;Ca&lt;sup&gt;2+&lt;/sup&gt;&lt;/sub&gt;/a&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;H&lt;sup&gt;+&lt;/sup&gt;&lt;/sub&gt;)'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; ratlab_html(&quot;Mg+2&quot;, &quot;Ca+2&quot;)
'log(a&lt;sub&gt;Mg&lt;sup&gt;2+&lt;/sup&gt;&lt;/sub&gt;/a&lt;sub&gt;Ca&lt;sup&gt;2+&lt;/sup&gt;&lt;/sub&gt;)'
</code></pre>
<h2 id="notes">Notes</h2>
<p>The exponents are determined by the charges of the ions to maintain
charge balance in the ratio. For example, for Ca+2/H+, the H+ term
is squared because Ca has a +2 charge.</p>
<p>The output format uses HTML tags (<sub>, <sup>) compatible with Plotly.
For matplotlib plots with LaTeX rendering, use ratlab() instead.</p>
<p>Requires: WORMutils (for chemlabel) and chemparse (for parse_formula)</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="pychnosz.ratlab" href="#pychnosz.ratlab">ratlab()</a></code></dt>
<dd>LaTeX version for matplotlib</dd>
</dl></div>
</dd>
<dt id="pychnosz.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>messages: bool = True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(messages: bool = True):
    &#34;&#34;&#34;
    Initialize or reset the CHNOSZ thermodynamic system.

    This function initializes the global thermodynamic system by loading
    all thermodynamic data files, setting up the OBIGT database, and
    preparing the system for calculations.

    This is equivalent to the reset() function in the R version of CHNOSZ.

    Parameters
    ----------
    messages : bool, default True
        Whether to print informational messages

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.reset()  # Initialize the system
    reset: thermodynamic system initialized
    &#34;&#34;&#34;
    thermo_system = get_thermo_system()
    thermo_system.reset(messages=messages)</code></pre>
</details>
<div class="desc"><p>Initialize or reset the CHNOSZ thermodynamic system.</p>
<p>This function initializes the global thermodynamic system by loading
all thermodynamic data files, setting up the OBIGT database, and
preparing the system for calculations.</p>
<p>This is equivalent to the reset() function in the R version of CHNOSZ.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.reset()  # Initialize the system
reset: thermodynamic system initialized
</code></pre></div>
</dd>
<dt id="pychnosz.reset_OBIGT"><code class="name flex">
<span>def <span class="ident">reset_OBIGT</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_OBIGT() -&gt; None:
    &#34;&#34;&#34;
    Reset OBIGT database to default state.
    
    This function reloads the default thermodynamic database,
    removing any modifications made by add_OBIGT().
    &#34;&#34;&#34;
    from ..utils.reset import reset
    reset()
    print(&#34;OBIGT database reset to default state&#34;)</code></pre>
</details>
<div class="desc"><p>Reset OBIGT database to default state.</p>
<p>This function reloads the default thermodynamic database,
removing any modifications made by add_OBIGT().</p></div>
</dd>
<dt id="pychnosz.reset_WORM"><code class="name flex">
<span>def <span class="ident">reset_WORM</span></span>(<span>messages: bool = True) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_WORM(messages: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Initialize the thermodynamic system with the WORM database.

    This is a convenience function that combines reset() and load_WORM().
    It initializes the system and loads the WORM database in one step.

    Parameters
    ----------
    messages : bool, default True
        Whether to print informational messages

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; # Initialize with WORM database
    &gt;&gt;&gt; pychnosz.reset_WORM()

    Notes
    -----
    This is equivalent to:
        pychnosz.reset()
        pychnosz.load_WORM()
    &#34;&#34;&#34;
    from ..utils.reset import reset

    # Reset the system first
    reset(messages=messages)

    # Load WORM database
    success = load_WORM(keep_default=False, messages=messages)

    if not success:
        if messages:
            print(&#34;reset_WORM: falling back to default OBIGT database&#34;)</code></pre>
</details>
<div class="desc"><p>Initialize the thermodynamic system with the WORM database.</p>
<p>This is a convenience function that combines reset() and load_WORM().
It initializes the system and loads the WORM database in one step.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; # Initialize with WORM database
&gt;&gt;&gt; pychnosz.reset_WORM()
</code></pre>
<h2 id="notes">Notes</h2>
<p>This is equivalent to:
pychnosz.reset()
pychnosz.load_WORM()</p></div>
</dd>
<dt id="pychnosz.retrieve"><code class="name flex">
<span>def <span class="ident">retrieve</span></span>(<span>elements: str | List[str] | Tuple[str] | None = None,<br>ligands: str | List[str] | Tuple[str] | None = None,<br>state: str | List[str] | Tuple[str] | None = None,<br>T: float | List[float] | None = None,<br>P: str | float | List[float] = 'Psat',<br>add_charge: bool = True,<br>hide_groups: bool = True,<br>messages: bool = True) ‑> pandas.core.series.Series</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve(elements: Optional[Union[str, List[str], Tuple[str]]] = None,
            ligands: Optional[Union[str, List[str], Tuple[str]]] = None,
            state: Optional[Union[str, List[str], Tuple[str]]] = None,
            T: Optional[Union[float, List[float]]] = None,
            P: Union[str, float, List[float]] = &#34;Psat&#34;,
            add_charge: bool = True,
            hide_groups: bool = True,
            messages: bool = True) -&gt; pd.Series:
    &#34;&#34;&#34;
    Retrieve species containing specified elements.

    Parameters
    ----------
    elements : str, list of str, or tuple of str, optional
        Elements in a chemical system. If `elements` is a string, retrieve
        species containing that element.

        E.g., `retrieve(&#34;Au&#34;)` will return all species containing Au.

        If `elements` is a list, retrieve species that have all of the elements
        in the list.

        E.g., `retrieve([&#34;Au&#34;, &#34;Cl&#34;])` will return all species that have both
        Au and Cl.

        If `elements` is a tuple, retrieve species relevant to the system,
        including charged species.

        E.g., `retrieve((&#34;Au&#34;, &#34;Cl&#34;))` will return species that have Au
        and/or Cl, including charged species, but no other elements.

    ligands : str, list of str, or tuple of str, optional
        Elements present in any ligands. This affects the species search:
        - If ligands is a state (&#39;cr&#39;, &#39;liq&#39;, &#39;gas&#39;, &#39;aq&#39;), use that as the state filter
        - Otherwise, include elements in the system defined by ligands

    state : str, list of str, or tuple of str, optional
        Filter the result on these state(s) (&#39;aq&#39;, &#39;cr&#39;, &#39;gas&#39;, &#39;liq&#39;).

    T : float or list of float, optional
        Temperature (K) for filtering species with non-NA Gibbs energy.

    P : str, float, or list of float, default &#34;Psat&#34;
        Pressure for Gibbs energy calculation. Default is &#34;Psat&#34; (saturation).

    add_charge : bool, default True
        For chemical systems (tuple input), automatically include charge (Z).

    hide_groups : bool, default True
        Exclude group species (names in brackets like [CH2]).

    messages : bool, default True
        Print informational messages. If False, suppress messages about
        updating the stoichiometric matrix and other information.

    Returns
    -------
    pd.Series
        Series of species indices (1-based) with chemical formulas as index.
        This behaves like R&#39;s named vector - you can access by name or position.
        Names are chemical formulas (or &#39;e-&#39; for electrons).
        Values are species indices that match the criteria.

    Examples
    --------
    &gt;&gt;&gt; # All species containing Au
    &gt;&gt;&gt; retrieve(&#34;Au&#34;)

    &gt;&gt;&gt; # All species that have both Au and Cl
    &gt;&gt;&gt; retrieve([&#34;Au&#34;, &#34;Cl&#34;])

    &gt;&gt;&gt; # Au-Cl system: species with Au and/or Cl, including charged species
    &gt;&gt;&gt; retrieve((&#34;Au&#34;, &#34;Cl&#34;))

    &gt;&gt;&gt; # All Au-bearing species in the Au-Cl system
    &gt;&gt;&gt; retrieve(&#34;Au&#34;, (&#34;Cl&#34;,))

    &gt;&gt;&gt; # All uncharged Au-bearing species in the Au-Cl system
    &gt;&gt;&gt; retrieve(&#34;Au&#34;, (&#34;Cl&#34;,), add_charge=False)

    &gt;&gt;&gt; # Minerals in the system SiO2-MgO-CaO-CO2
    &gt;&gt;&gt; retrieve((&#34;Si&#34;, &#34;Mg&#34;, &#34;Ca&#34;, &#34;C&#34;, &#34;O&#34;), state=&#34;cr&#34;)

    Notes
    -----
    This function uses 1-based indexing to match R CHNOSZ conventions.
    The returned indices are labels that can be used with .loc[], not positions.
    &#34;&#34;&#34;
    # Empty argument handling
    if elements is None:
        return pd.Series([], dtype=int)

    thermo_obj = thermo()

    # Initialize database if needed
    if not thermo_obj.is_initialized():
        thermo_obj.reset()

    ## Stoichiometric matrix
    # Get stoichiometric matrix from thermo object
    stoich = _get_or_update_stoich(thermo_obj, messages=messages)

    ## Generate error for missing element(s)
    allelements = []
    if elements is not None:
        if isinstance(elements, (list, tuple)):
            allelements.extend(elements)
        else:
            allelements.append(elements)
    if ligands is not None:
        if isinstance(ligands, (list, tuple)):
            allelements.extend(ligands)
        else:
            allelements.append(ligands)

    not_present = [elem for elem in allelements if elem not in stoich.columns and elem != &#34;all&#34;]
    if not_present:
        if len(not_present) == 1:
            raise ValueError(f&#39;&#34;{not_present[0]}&#34; is not an element that is present in any species in the database&#39;)
        else:
            raise ValueError(f&#39;&#34;{&#34;, &#34;.join(not_present)}&#34; are not elements that are present in any species in the database&#39;)

    ## Handle &#39;ligands&#39; argument
    if ligands is not None:
        # If &#39;ligands&#39; is cr, liq, gas, or aq, use that as the state
        if ligands in [&#39;cr&#39;, &#39;liq&#39;, &#39;gas&#39;, &#39;aq&#39;]:
            state = ligands
            ispecies = retrieve(elements, add_charge=add_charge, messages=messages)
        else:
            # Include the element in the system defined by the ligands list
            # Convert ligands to tuple if it&#39;s a string or list
            if isinstance(ligands, str):
                ligands_tuple = (ligands,)
            elif isinstance(ligands, list):
                ligands_tuple = tuple(ligands)
            else:
                ligands_tuple = ligands

            # Combine elements with ligands
            if isinstance(elements, str):
                combined = (elements,) + ligands_tuple
            elif isinstance(elements, list):
                combined = tuple(elements) + ligands_tuple
            else:
                combined = elements + ligands_tuple

            # Call retrieve() for each argument and take the intersection
            r1 = retrieve(elements, add_charge=add_charge, messages=messages)
            r2 = retrieve(combined, add_charge=add_charge, messages=messages)
            ispecies = np.intersect1d(r1, r2)
    else:
        ## Species identification
        ispecies_list = []

        # Determine if elements is a tuple (chemical system)
        is_system = isinstance(elements, tuple)

        # Convert single string to list for iteration
        if isinstance(elements, str):
            elements_iter = [elements]
        else:
            elements_iter = list(elements)

        # Automatically add charge to a system
        if add_charge and is_system and &#34;Z&#34; not in elements_iter:
            elements_iter.append(&#34;Z&#34;)

        # Proceed element-by-element
        for element in elements_iter:
            if element == &#34;all&#34;:
                ispecies_list.append(np.array(thermo_obj.obigt.index.tolist()))
            else:
                # Identify the species that have the element
                has_element = (stoich[element] != 0)
                ispecies_list.append(np.array(stoich.index[has_element].tolist()))

        # Now we have a list of ispecies (one array for each element)
        # What we do next depends on whether the argument is a tuple or not
        if is_system:
            # For a chemical system, all species are included that do not contain any other elements
            ispecies = np.unique(np.concatenate(ispecies_list))

            # Get columns not in elements
            other_columns = [col for col in stoich.columns if col not in elements_iter]

            if other_columns:
                # Check which species have other elements
                otherstoich = stoich.loc[ispecies, other_columns]
                iother = (otherstoich != 0).any(axis=1)
                ispecies = ispecies[~iother.values]
        else:
            # Get species that have all the elements; the species must be present in each array
            # This is the intersection of all arrays
            ispecies = ispecies_list[0]
            for arr in ispecies_list[1:]:
                ispecies = np.intersect1d(ispecies, arr)

    # Exclude groups
    if hide_groups:
        obigt = thermo_obj.obigt
        names = obigt.loc[ispecies, &#39;name&#39;].values
        is_group = np.array([bool(re.match(r&#39;^\[.*\]$&#39;, str(name))) for name in names])
        ispecies = ispecies[~is_group]

    # Filter on state
    if state is not None:
        obigt = thermo_obj.obigt

        # Ensure state is a list
        if isinstance(state, str):
            state_list = [state]
        elif isinstance(state, tuple):
            state_list = list(state)
        else:
            state_list = state

        species_states = obigt.loc[ispecies, &#39;state&#39;].values
        istate = np.array([s in state_list for s in species_states])
        ispecies = ispecies[istate]

    # Require non-NA Delta G0 at specific temperature
    if T is not None:
        from .subcrt import subcrt
        # Suppress warnings and (optionally) messages
        with warnings.catch_warnings():
            warnings.simplefilter(&#34;ignore&#34;)
            try:
                result = subcrt(ispecies.tolist(), T=T, P=P, messages=False, show=False)
                if result is not None and &#39;out&#39; in result:
                    G_values = []
                    for species_out in result[&#39;out&#39;]:
                        if isinstance(species_out, dict) and &#39;G&#39; in species_out:
                            G = species_out[&#39;G&#39;]
                            if isinstance(G, (list, np.ndarray)):
                                G_values.append(G[0] if len(G) &gt; 0 else np.nan)
                            else:
                                G_values.append(G)
                        else:
                            G_values.append(np.nan)

                    # Filter out species with NA G values
                    has_G = np.array([not pd.isna(g) for g in G_values])
                    ispecies = ispecies[has_G]
            except:
                # If subcrt fails, keep all species
                pass

    # Create a pandas Series with formula names (R-style named vector)
    obigt = thermo_obj.obigt
    formulas = obigt.loc[ispecies, &#39;formula&#39;].values

    # Use e- instead of (Z-1) for electron
    formulas = np.array([f if f != &#39;(Z-1)&#39; else &#39;e-&#39; for f in formulas])

    # Return empty Series if nothing found
    if len(ispecies) == 0:
        return pd.Series([], dtype=int)

    # Create a pandas Series with formulas as index (R-style named vector)
    # This allows both named access (result[&#34;Au&#34;]) and positional access (result[0])
    result = pd.Series(ispecies, index=formulas)

    return result</code></pre>
</details>
<div class="desc"><p>Retrieve species containing specified elements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>elements</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>tuple</code> of <code>str</code>, optional</dt>
<dd>
<p>Elements in a chemical system. If <code>elements</code> is a string, retrieve
species containing that element.</p>
<p>E.g., <code>retrieve("Au")</code> will return all species containing Au.</p>
<p>If <code>elements</code> is a list, retrieve species that have all of the elements
in the list.</p>
<p>E.g., <code>retrieve(["Au", "Cl"])</code> will return all species that have both
Au and Cl.</p>
<p>If <code>elements</code> is a tuple, retrieve species relevant to the system,
including charged species.</p>
<p>E.g., <code>retrieve(("Au", "Cl"))</code> will return species that have Au
and/or Cl, including charged species, but no other elements.</p>
</dd>
<dt><strong><code>ligands</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>tuple</code> of <code>str</code>, optional</dt>
<dd>Elements present in any ligands. This affects the species search:
- If ligands is a state ('cr', 'liq', 'gas', 'aq'), use that as the state filter
- Otherwise, include elements in the system defined by ligands</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>tuple</code> of <code>str</code>, optional</dt>
<dd>Filter the result on these state(s) ('aq', 'cr', 'gas', 'liq').</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, optional</dt>
<dd>Temperature (K) for filtering species with non-NA Gibbs energy.</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>str, float,</code> or <code>list</code> of <code>float</code>, default <code>"Psat"</code></dt>
<dd>Pressure for Gibbs energy calculation. Default is "Psat" (saturation).</dd>
<dt><strong><code>add_charge</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>For chemical systems (tuple input), automatically include charge (Z).</dd>
<dt><strong><code>hide_groups</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Exclude group species (names in brackets like [CH2]).</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Print informational messages. If False, suppress messages about
updating the stoichiometric matrix and other information.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.Series</code></dt>
<dd>Series of species indices (1-based) with chemical formulas as index.
This behaves like R's named vector - you can access by name or position.
Names are chemical formulas (or 'e-' for electrons).
Values are species indices that match the criteria.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # All species containing Au
&gt;&gt;&gt; retrieve(&quot;Au&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # All species that have both Au and Cl
&gt;&gt;&gt; retrieve([&quot;Au&quot;, &quot;Cl&quot;])
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Au-Cl system: species with Au and/or Cl, including charged species
&gt;&gt;&gt; retrieve((&quot;Au&quot;, &quot;Cl&quot;))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # All Au-bearing species in the Au-Cl system
&gt;&gt;&gt; retrieve(&quot;Au&quot;, (&quot;Cl&quot;,))
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # All uncharged Au-bearing species in the Au-Cl system
&gt;&gt;&gt; retrieve(&quot;Au&quot;, (&quot;Cl&quot;,), add_charge=False)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Minerals in the system SiO2-MgO-CaO-CO2
&gt;&gt;&gt; retrieve((&quot;Si&quot;, &quot;Mg&quot;, &quot;Ca&quot;, &quot;C&quot;, &quot;O&quot;), state=&quot;cr&quot;)
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function uses 1-based indexing to match R CHNOSZ conventions.
The returned indices are labels that can be used with .loc[], not positions.</p></div>
</dd>
<dt id="pychnosz.set_title"><code class="name flex">
<span>def <span class="ident">set_title</span></span>(<span>ax_or_fig, title: str, fontsize: float = 12, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_title(ax_or_fig, title: str, fontsize: float = 12, **kwargs):
    &#34;&#34;&#34;
    Set title on a matplotlib axes or Plotly figure.

    This function provides a unified interface for setting titles on both
    matplotlib and Plotly plots, allowing seamless switching between
    interactive=True and interactive=False.

    Parameters
    ----------
    ax_or_fig : matplotlib.axes.Axes or plotly.graph_objs.Figure
        Axes or Figure object to set title on
    title : str
        The title text
    fontsize : float, default 12
        Font size for the title
    **kwargs
        Additional arguments passed to matplotlib set_title() or Plotly update_layout()

    Returns
    -------
    matplotlib.text.Text or plotly.graph_objs.Figure
        The title object (matplotlib) or the figure (Plotly)

    Examples
    --------
    &gt;&gt;&gt; from pychnosz.utils.expression import set_title, syslab
    &gt;&gt;&gt; # Matplotlib diagram
    &gt;&gt;&gt; d1 = diagram(a, interactive=False, plot_it=False)
    &gt;&gt;&gt; title_text = syslab([&#34;H2O&#34;, &#34;CO2&#34;, &#34;CaO&#34;, &#34;MgO&#34;, &#34;SiO2&#34;])
    &gt;&gt;&gt; set_title(d1[&#39;ax&#39;], title_text, fontsize=12)
    &gt;&gt;&gt; # Display the figure in Jupyter:
    &gt;&gt;&gt; from IPython.display import display
    &gt;&gt;&gt; display(d1[&#39;fig&#39;])

    &gt;&gt;&gt; # Plotly diagram
    &gt;&gt;&gt; d1 = diagram(a, interactive=True, plot_it=False)
    &gt;&gt;&gt; title_text = syslab_html([&#34;H2O&#34;, &#34;CO2&#34;, &#34;CaO&#34;, &#34;MgO&#34;, &#34;SiO2&#34;])
    &gt;&gt;&gt; set_title(d1[&#39;ax&#39;], title_text, fontsize=12)
    &gt;&gt;&gt; d1[&#39;fig&#39;].show()

    Notes
    -----
    When using plot_it=False, you need to explicitly display the figure after
    setting the title. In Jupyter notebooks, use display(d[&#39;fig&#39;]) or d[&#39;fig&#39;].show()
    for Plotly diagrams. Outside Jupyter, use plt.show() or save with d[&#39;fig&#39;].savefig().
    &#34;&#34;&#34;
    is_plotly = _is_plotly_figure(ax_or_fig)

    if is_plotly:
        # Plotly figure
        title_dict = {&#39;text&#39;: title, &#39;x&#39;: 0.5, &#39;xanchor&#39;: &#39;center&#39;}
        if fontsize:
            title_dict[&#39;font&#39;] = {&#39;size&#39;: fontsize}
        ax_or_fig.update_layout(title=title_dict, **kwargs)
        return ax_or_fig
    else:
        # Matplotlib axes
        return ax_or_fig.set_title(title, fontsize=fontsize, **kwargs)</code></pre>
</details>
<div class="desc"><p>Set title on a matplotlib axes or Plotly figure.</p>
<p>This function provides a unified interface for setting titles on both
matplotlib and Plotly plots, allowing seamless switching between
interactive=True and interactive=False.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax_or_fig</code></strong> :&ensp;<code>matplotlib.axes.Axes</code> or <code>plotly.graph_objs.Figure</code></dt>
<dd>Axes or Figure object to set title on</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code></dt>
<dd>The title text</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>float</code>, default <code>12</code></dt>
<dd>Font size for the title</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional arguments passed to matplotlib set_title() or Plotly update_layout()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>matplotlib.text.Text</code> or <code>plotly.graph_objs.Figure</code></dt>
<dd>The title object (matplotlib) or the figure (Plotly)</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz.utils.expression import set_title, syslab
&gt;&gt;&gt; # Matplotlib diagram
&gt;&gt;&gt; d1 = diagram(a, interactive=False, plot_it=False)
&gt;&gt;&gt; title_text = syslab([&quot;H2O&quot;, &quot;CO2&quot;, &quot;CaO&quot;, &quot;MgO&quot;, &quot;SiO2&quot;])
&gt;&gt;&gt; set_title(d1['ax'], title_text, fontsize=12)
&gt;&gt;&gt; # Display the figure in Jupyter:
&gt;&gt;&gt; from IPython.display import display
&gt;&gt;&gt; display(d1['fig'])
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Plotly diagram
&gt;&gt;&gt; d1 = diagram(a, interactive=True, plot_it=False)
&gt;&gt;&gt; title_text = syslab_html([&quot;H2O&quot;, &quot;CO2&quot;, &quot;CaO&quot;, &quot;MgO&quot;, &quot;SiO2&quot;])
&gt;&gt;&gt; set_title(d1['ax'], title_text, fontsize=12)
&gt;&gt;&gt; d1['fig'].show()
</code></pre>
<h2 id="notes">Notes</h2>
<p>When using plot_it=False, you need to explicitly display the figure after
setting the title. In Jupyter notebooks, use display(d['fig']) or d['fig'].show()
for Plotly diagrams. Outside Jupyter, use plt.show() or save with d['fig'].savefig().</p></div>
</dd>
<dt id="pychnosz.species"><code class="name flex">
<span>def <span class="ident">species</span></span>(<span>species: str | int | List[str | int] | pandas.core.series.Series | None = None,<br>state: str | List[str] | None = None,<br>delete: bool = False,<br>add: bool = False,<br>index_return: bool = False,<br>global_state: bool = True,<br>basis: pandas.core.frame.DataFrame | None = None,<br>messages: bool = True) ‑> pandas.core.frame.DataFrame | List[int] | None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def species(species: Optional[Union[str, int, List[Union[str, int]], pd.Series]] = None,
            state: Optional[Union[str, List[str]]] = None,
            delete: bool = False,
            add: bool = False,
            index_return: bool = False,
            global_state: bool = True,
            basis: Optional[pd.DataFrame] = None,
            messages: bool = True) -&gt; Optional[Union[pd.DataFrame, List[int]]]:
    &#34;&#34;&#34;
    Define species of interest for thermodynamic calculations.

    Parameters
    ----------
    species : str, int, list, pd.Series, or None
        Species name(s), formula(s), or index(es).
        Can also be a pandas Series (e.g., from retrieve()).
        If None, returns current species definition.
    state : str, list of str, or None
        Physical state(s) for the species
    delete : bool, default False
        If True, delete species (all if species is None)
    add : bool, default False
        If True, add to existing species instead of replacing
    index_return : bool, default False
        If True, return species indices instead of DataFrame
    global_state : bool, default True
        If True, store species in global thermo().species (default behavior)
        If False, return species definition without storing globally (local state)
    basis : pd.DataFrame, optional
        Basis species definition to use (if not using global basis)
        Required when global_state=False and basis is not defined globally
    messages : bool, default True
        If True, print informational messages

    Returns
    -------
    pd.DataFrame, list of int, or None
        Species definition DataFrame or indices, or None if deleted

    Examples
    --------
    &gt;&gt;&gt; # Define species of interest
    &gt;&gt;&gt; species([&#34;CO2&#34;, &#34;HCO3-&#34;, &#34;CO3-2&#34;])

    &gt;&gt;&gt; # Add more species
    &gt;&gt;&gt; species([&#34;CH4&#34;, &#34;C2H4&#34;], add=True)

    &gt;&gt;&gt; # Delete specific species
    &gt;&gt;&gt; species([&#34;CO2&#34;], delete=True)

    &gt;&gt;&gt; # Delete all species
    &gt;&gt;&gt; species(delete=True)

    &gt;&gt;&gt; # Use output from retrieve()
    &gt;&gt;&gt; zn_species = retrieve(&#34;Zn&#34;, [&#34;O&#34;, &#34;H&#34;], state=&#34;aq&#34;)
    &gt;&gt;&gt; species(zn_species)
    &#34;&#34;&#34;
    thermo_obj = thermo()

    # Handle pandas Series (e.g., from retrieve())
    if isinstance(species, pd.Series):
        # Extract the integer indices from the Series values
        species = species.values.tolist()

    # Handle NA species
    if species is pd.NA or species is np.nan:
        raise SpeciesError(&#34;&#39;species&#39; is NA&#34;)
    
    # Handle deletion
    if delete:
        return _delete_species(species, thermo_obj)
    
    # Return current species if no arguments
    if species is None and state is None:
        if index_return:
            if thermo_obj.species is not None:
                return list(range(1, len(thermo_obj.species) + 1))
            else:
                return []
        return thermo_obj.species
    
    # Use all species indices if species is None but state is given
    if species is None and thermo_obj.species is not None:
        species = list(range(1, len(thermo_obj.species) + 1))
    
    # Process state argument
    state = _process_state_argument(state)
    
    # Make species and state same length
    species, state = _match_argument_lengths(species, state)
    
    # Handle numeric state (treat as logact)
    logact = None
    if state is not None and len(state) &gt; 0:
        if isinstance(state[0], (int, float)):
            logact = [float(s) for s in state]
            state = None
        elif _can_be_numeric(state[0]):
            logact = [float(s) for s in state]
            state = None
    
    # Handle species-state combinations for proteins
    if state is not None:
        species, state = _handle_protein_naming(species, state, thermo_obj)
    
    # Process species argument
    iOBIGT = None
    if isinstance(species[0], str):
        # Check if species are in current definition
        if thermo_obj.species is not None:
            existing_indices = _match_existing_species(species, thermo_obj.species)
            if all(idx is not None for idx in existing_indices) and logact is not None:
                # Update activities of existing species
                # Update activities of existing species directly
                species_indices = [i+1 for i in existing_indices]  # Convert to 1-based
                return _update_existing_species(species_indices, None, logact, index_return, thermo_obj)
        
        # Look up species in database
        iOBIGT = _lookup_species_indices(species, state, messages)
        
    else:
        # Handle numeric species
        if thermo_obj.species is not None:
            max_current = len(thermo_obj.species)
            if all(isinstance(s, int) and s &lt;= max_current for s in species):
                # Referring to existing species
                return _update_existing_species(species, state, logact, index_return, thermo_obj)
        
        # Referring to OBIGT indices
        iOBIGT = species
    
    # Create or modify species definition
    if iOBIGT is not None:
        return _create_species_definition(iOBIGT, state, logact, add, index_return, thermo_obj, global_state, basis)
    else:
        return _update_existing_species(species, state, logact, index_return, thermo_obj)</code></pre>
</details>
<div class="desc"><p>Define species of interest for thermodynamic calculations.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int, list, pd.Series,</code> or <code>None</code></dt>
<dd>Species name(s), formula(s), or index(es).
Can also be a pandas Series (e.g., from retrieve()).
If None, returns current species definition.</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>None</code></dt>
<dd>Physical state(s) for the species</dd>
<dt><strong><code>delete</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, delete species (all if species is None)</dd>
<dt><strong><code>add</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, add to existing species instead of replacing</dd>
<dt><strong><code>index_return</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>If True, return species indices instead of DataFrame</dd>
<dt><strong><code>global_state</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, store species in global thermo().species (default behavior)
If False, return species definition without storing globally (local state)</dd>
<dt><strong><code>basis</code></strong> :&ensp;<code>pd.DataFrame</code>, optional</dt>
<dd>Basis species definition to use (if not using global basis)
Required when global_state=False and basis is not defined globally</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>If True, print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame, list</code> of <code>int,</code> or <code>None</code></dt>
<dd>Species definition DataFrame or indices, or None if deleted</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Define species of interest
&gt;&gt;&gt; species([&quot;CO2&quot;, &quot;HCO3-&quot;, &quot;CO3-2&quot;])
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Add more species
&gt;&gt;&gt; species([&quot;CH4&quot;, &quot;C2H4&quot;], add=True)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Delete specific species
&gt;&gt;&gt; species([&quot;CO2&quot;], delete=True)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Delete all species
&gt;&gt;&gt; species(delete=True)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Use output from retrieve()
&gt;&gt;&gt; zn_species = retrieve(&quot;Zn&quot;, [&quot;O&quot;, &quot;H&quot;], state=&quot;aq&quot;)
&gt;&gt;&gt; species(zn_species)
</code></pre></div>
</dd>
<dt id="pychnosz.subcrt"><code class="name flex">
<span>def <span class="ident">subcrt</span></span>(<span>species: str | List[str] | int | List[int],<br>coeff: int | float | List[int | float] | None = 1,<br>state: str | List[str] | None = None,<br>property: List[str] = ['logK', 'G', 'H', 'S', 'V', 'Cp'],<br>T: float | numpy.ndarray | List[float] = array([273.16, 298.16, 323.16, 348.16, 373.16, 398.16, 423.16, 448.16,
473.16, 498.16, 523.16, 548.16, 573.16, 598.16]),<br>P: float | List[float] | numpy.ndarray | str = 'Psat',<br>grid: str | None = None,<br>convert: bool = True,<br>exceed_Ttr: bool = True,<br>exceed_rhomin: bool = False,<br>logact: List[float] | None = None,<br>autobalance: bool = True,<br>use_polymorphs: bool = True,<br>IS: float | List[float] = 0,<br>messages: bool = True,<br>show: bool = True,<br>basis: pandas.core.frame.DataFrame | None = None) ‑> pychnosz.core.subcrt.SubcrtResult</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subcrt(species: Union[str, List[str], int, List[int]],
           coeff: Union[int, float, List[Union[int, float]], None] = 1,
           state: Optional[Union[str, List[str]]] = None,
           property: List[str] = [&#34;logK&#34;, &#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;V&#34;, &#34;Cp&#34;],
           T: Union[float, List[float], np.ndarray] = np.arange(273.16, 623.16, 25),
           P: Union[float, List[float], np.ndarray, str] = &#34;Psat&#34;,
           grid: Optional[str] = None,
           convert: bool = True,
           exceed_Ttr: bool = True,
           exceed_rhomin: bool = False,
           logact: Optional[List[float]] = None,
           autobalance: bool = True,
           use_polymorphs: bool = True,
           IS: Union[float, List[float]] = 0,
           messages: bool = True,
           show: bool = True,
           basis: Optional[pd.DataFrame] = None,
           _recursion_count: int = 0) -&gt; SubcrtResult:
    &#34;&#34;&#34;
    Calculate standard molal thermodynamic properties of species and reactions.
    
    This function reproduces the behavior of R CHNOSZ subcrt() exactly, including
    all argument handling, validation, calculations, and output formatting.
    
    Parameters
    ----------
    species : str, list of str, int, or list of int
        Species names, formulas, or indices in thermodynamic database
    coeff : int, float, list, or None
        Stoichiometric coefficients for reaction calculation
        If 1 (default), calculate individual species properties
        If list, calculate reaction with given coefficients
    state : str, list of str, or None
        Physical states (&#34;aq&#34;, &#34;cr&#34;, &#34;gas&#34;, &#34;liq&#34;) for species
    property : list of str
        Properties to calculate: &#34;logK&#34;, &#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;V&#34;, &#34;Cp&#34;, &#34;rho&#34;, &#34;kT&#34;, &#34;E&#34;
    T : float, list, or ndarray
        Temperature(s) in K (default: 273.15 to 623.15 by 25 K)
    P : float, list, ndarray, or &#34;Psat&#34;
        Pressure(s) in bar or &#34;Psat&#34; for saturation pressure
    grid : str or None
        Grid calculation mode: &#34;T&#34;, &#34;P&#34;, &#34;IS&#34;, or None
    convert : bool
        Convert temperature/pressure units (default: True)
    exceed_Ttr : bool
        Allow calculations beyond transition temperatures (default: False)
    exceed_rhomin : bool
        Allow calculations below minimum water density (default: False)
    logact : list of float or None
        Activity coefficients (log10 scale)
    autobalance : bool
        Automatically balance reactions using basis species (default: True)
    use_polymorphs : bool
        Include polymorphic phases for minerals (default: True)
    IS : float or list of float
        Ionic strength for activity corrections (default: 0)
    messages : bool, default True
        Whether to print informational messages
    show : bool, default True
        Whether to display result tables in Jupyter notebooks (default: True)
        Set to False when calling subcrt() from other functions
    basis : pd.DataFrame, optional
        Basis species definition to use for autobalancing (if not using global basis)

    Returns
    -------
    SubcrtResult
        Object containing:
        - species: DataFrame with species information
        - out: DataFrame with calculated thermodynamic properties
        - reaction: DataFrame with reaction stoichiometry (if reaction)
        - warnings: List of warning messages
        
    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Single species properties
    &gt;&gt;&gt; result = subcrt(&#34;H2O&#34;, T=25, P=1)
    &gt;&gt;&gt; print(result.out[[&#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;Cp&#34;]])
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Reaction calculation
    &gt;&gt;&gt; result = subcrt([&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;], [-1, 1, 1], T=25, P=1)
    &gt;&gt;&gt; print(f&#34;Water dissociation ΔG° = {result.out.G[0]:.3f} kJ/mol&#34;)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Temperature array
    &gt;&gt;&gt; result = subcrt(&#34;quartz&#34;, T=[25, 100, 200], P=1)
    &gt;&gt;&gt; print(result.out[[&#34;T&#34;, &#34;G&#34;, &#34;H&#34;, &#34;S&#34;]])
    
    Notes
    -----
    This implementation maintains complete fidelity to R CHNOSZ subcrt():
    - Identical argument processing and validation
    - Same species lookup and polymorphic handling
    - Exact HKF and CGL equation-of-state calculations
    - Same reaction balancing and autobalance logic
    - Identical output structure and formatting
    - Same warning and error messages
    &#34;&#34;&#34;
    
    result = SubcrtResult()

    # Prevent infinite recursion in auto-balancing
    if _recursion_count &gt; 5:
        result.warnings.append(&#34;Maximum recursion depth reached in auto-balancing&#34;)
        return result

    try:
        # === Phase 1: Argument Processing and Validation ===
        # (Exactly matching R subcrt.R lines 21-77)
        
        # Handle argument reordering if states are second argument
        if coeff != 1 and isinstance(coeff, (list, str)) and isinstance(coeff[0] if isinstance(coeff, list) else coeff, str):
            # States were passed as second argument - reorder
            if state is not None:
                if isinstance(state, (int, float)) or (isinstance(state, list) and all(isinstance(x, (int, float)) for x in state)):
                    # Third argument is coefficients
                    new_coeff = state
                    new_state = coeff
                    return subcrt(species, new_coeff, new_state, property, T, P, grid,
                                convert, exceed_Ttr, exceed_rhomin, logact, autobalance, use_polymorphs, IS,
                                messages, show, basis, _recursion_count)
                else:
                    raise ValueError(&#34;If both coeff and state are given, one should be numeric coefficients&#34;)
            else:
                # Only states provided, no coefficients
                new_state = coeff
                return subcrt(species, 1, new_state, property, T, P, grid,
                            convert, exceed_Ttr, exceed_rhomin, logact, autobalance, use_polymorphs, IS,
                            messages, show, basis, _recursion_count)
        
        # Determine if this is a reaction calculation
        do_reaction = (coeff != 1 and coeff is not None and 
                      (isinstance(coeff, list) or isinstance(coeff, (int, float)) and coeff != 1))
        
        # Convert inputs to consistent formats
        species = [species] if isinstance(species, (str, int)) else list(species)
        if state is not None:
            state = [state] if isinstance(state, str) else list(state)
            # Make species and state same length
            if len(state) &gt; len(species):
                species = species * (len(state) // len(species) + 1)
                species = species[:len(state)]
            elif len(species) &gt; len(state):
                state = state * (len(species) // len(state) + 1)
                state = state[:len(species)]
        
        if do_reaction:
            if isinstance(coeff, (int, float)):
                coeff = [coeff]
            coeff = list(coeff)
        
        # Validate properties
        allowed_properties = [&#34;rho&#34;, &#34;logK&#34;, &#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;Cp&#34;, &#34;V&#34;, &#34;kT&#34;, &#34;E&#34;]
        if isinstance(property, str):
            property = [property]
        
        invalid_props = [p for p in property if p not in allowed_properties]
        if invalid_props:
            if len(invalid_props) == 1:
                raise ValueError(f&#34;invalid property name: {invalid_props[0]}&#34;)
            else:
                raise ValueError(f&#34;invalid property names: {&#39;, &#39;.join(invalid_props)}&#34;)
        
        # Length checking
        if do_reaction and len(species) != len(coeff):
            raise ValueError(&#34;the length of &#39;coeff&#39; must equal the number of species&#34;)
        
        if logact is not None and len(logact) != len(species):
            raise ValueError(&#34;the length of &#39;logact&#39; must equal the number of species&#34;)
        
        # Unit conversion
        T_array = np.atleast_1d(np.asarray(T, dtype=float))
        # Convert temperature to Kelvin if convert=True (matching R CHNOSZ behavior)
        # R: if(convert) T &lt;- envert(T, &#34;K&#34;) - converts Celsius input to Kelvin
        # Default parameter np.arange(273.16, 623.16, 25) is already in K, so only convert user input
        if convert and not np.array_equal(T_array, np.arange(273.16, 623.16, 25)[:len(T_array)]):
            # User provided temperature, assume Celsius and convert to Kelvin
            T_array = T_array + 273.15

        # Handle T=273.15K (0°C) exactly - R CHNOSZ uses 273.16K (0.01°C) instead
        # This avoids numerical issues at the freezing point
        T_array = np.where(np.abs(T_array - 273.15) &lt; 1e-10, 273.16, T_array)
        
        if isinstance(P, str) and P == &#34;Psat&#34;:
            P_array = &#34;Psat&#34;
        else:
            P_array = np.atleast_1d(np.asarray(P, dtype=float))
            # P is assumed to be in bar (R CHNOSZ standard)
        
        # Warning for high temperatures with Psat
        # Check if P is &#34;Psat&#34; (compare to the original P, not P_array which may be converted)
        if isinstance(P, str) and P == &#34;Psat&#34; and np.any(T_array &gt; 647.067):
            n_over = np.sum(T_array &gt; 647.067)
            vtext = &#34;value&#34; if n_over == 1 else &#34;values&#34;
            result.warnings.append(f&#34;P = &#39;Psat&#39; undefined for T &gt; Tcritical ({n_over} T {vtext})&#34;)
        
        # === Phase 2: Grid Processing ===
        # Handle grid calculations (T-P arrays)
        if grid is not None:
            if grid == &#34;T&#34;:
                # Grid over temperature
                new_T = []
                for temp in T_array:
                    if isinstance(P_array, str):
                        new_T.extend([temp] * 1)
                    else:
                        new_T.extend([temp] * len(P_array))
                if isinstance(P_array, str):
                    new_P = P_array
                else:
                    new_P = list(P_array) * len(T_array)
                T_array = np.array(new_T)
                P_array = new_P
            elif grid == &#34;P&#34;:
                # Grid over pressure
                if not isinstance(P_array, str):
                    new_P = []
                    for press in P_array:
                        new_P.extend([press] * len(T_array))
                    new_T = list(T_array) * len(P_array)
                    T_array = np.array(new_T)
                    P_array = np.array(new_P)
            elif grid == &#34;IS&#34;:
                # Grid over ionic strength
                IS_array = np.atleast_1d(np.asarray(IS))
                original_len = max(len(T_array), len(P_array) if not isinstance(P_array, str) else 1)
                new_IS = []
                for ionic_str in IS_array:
                    new_IS.extend([ionic_str] * original_len)
                T_array = np.tile(T_array, len(IS_array))
                if isinstance(P_array, str):
                    P_array = P_array
                else:
                    P_array = np.tile(P_array, len(IS_array))
                IS = new_IS
        else:
            # Ensure T and P are same length
            if isinstance(P_array, str):
                # P = &#34;Psat&#34;, keep T as is
                pass
            else:
                max_len = max(len(T_array), len(P_array))
                if len(T_array) &lt; max_len:
                    T_array = np.resize(T_array, max_len)
                if len(P_array) &lt; max_len:
                    P_array = np.resize(P_array, max_len)
        
        # === Phase 3: Species Lookup and Validation ===
        result.species, result.reaction, iphases, isaq, isH2O, iscgl, polymorph_species, ispecies = _process_species(
            species, state, coeff, do_reaction, use_polymorphs, messages=messages)
        
        # === Phase 4: Generate Output Message ===
        if (len(species) &gt; 1 or convert) and messages:
            _print_subcrt_message(species, T_array, P_array, isaq.any() or isH2O.any(), messages)
        
        # === Phase 5: Reaction Balance Check ===
        if do_reaction and autobalance:
            # Use original ispecies and coeff for balance check (before polymorph expansion)
            # This matches R CHNOSZ behavior where balance check happens before polymorph expansion
            rebalanced_result = _check_reaction_balance(result, species, coeff, state, property,
                                                      T_array, P_array, grid, convert, logact,
                                                      exceed_Ttr, exceed_rhomin, IS, ispecies, _recursion_count, basis, T, P, messages, show)
            if rebalanced_result is not None:  # If reaction was rebalanced, return the result
                return rebalanced_result
        
        # === Phase 6: Property Calculations ===
        result.out, calc_warnings = _calculate_properties(property, iphases, isaq, isH2O, iscgl,
                                         T_array, P_array, exceed_rhomin, exceed_Ttr, IS, logact, do_reaction)
        # Add calculation warnings to result
        result.warnings.extend(calc_warnings)
        
        # === Phase 6.5: Polymorph Selection ===
        if use_polymorphs:
            # Select stable polymorphs based on minimum Gibbs energy
            # Apply to both individual species AND reactions (matching R CHNOSZ behavior)
            thermo_sys = thermo()
            if do_reaction:
                # For reactions, also update coefficients and rebuild reaction DataFrame
                result.out, updated_coeff, updated_iphases = _select_stable_polymorphs(result.out, iphases, polymorph_species, ispecies, thermo_sys, result.reaction[&#39;coeff&#39;].tolist(), messages)
                # Rebuild reaction DataFrame with updated species list
                reaction_data = []
                for i, iph in enumerate(updated_iphases):
                    row = thermo_sys.obigt.loc[iph]
                    model = row.get(&#39;model&#39;, &#39;unknown&#39;)
                    if model == &#34;H2O&#34;:
                        water_model = thermo_sys.get_option(&#39;water&#39;, &#39;SUPCRT92&#39;)
                        model = f&#34;water.{water_model}&#34;
                    reaction_data.append({
                        &#39;coeff&#39;: updated_coeff[i],
                        &#39;name&#39;: row[&#39;name&#39;],
                        &#39;formula&#39;: row[&#39;formula&#39;],
                        &#39;state&#39;: row[&#39;state&#39;],
                        &#39;ispecies&#39;: iph,
                        &#39;model&#39;: model
                    })
                result.reaction = pd.DataFrame(reaction_data)
            else:
                # For individual species, no coefficient update needed
                result.out, _ = _select_stable_polymorphs(result.out, iphases, polymorph_species, ispecies, thermo_sys, None, messages)
            
            # For single species (non-reaction), convert back to DataFrame format
            if not do_reaction and isinstance(result.out, dict) and &#39;species_data&#39; in result.out and len(result.out[&#39;species_data&#39;]) == 1:
                result.out = result.out[&#39;species_data&#39;][0]
        
        # === Phase 7: Reaction Property Summation ===
        if do_reaction:
            result.out = _sum_reaction_properties(result.out, result.reaction[&#39;coeff&#39;])
        
        # === Phase 8: Unit Conversion (convert=True) ===
        if convert:
            # Apply R CHNOSZ compatible conversion
            # This matches the observed behavior where convert=TRUE gives different results
            # than just multiplying by 4.184
            result.out = _apply_r_chnosz_conversion(result.out, do_reaction)
            
            # Recalculate logK after unit conversion to ensure consistency
            if do_reaction and &#39;logK&#39; in property and &#39;G&#39; in result.out.columns:
                if not result.out[&#39;G&#39;].isna().all():
                    R = 8.314462618  # J/(mol·K) - CODATA 2018 value
                    T_array = np.atleast_1d(T_array)
                    result.out[&#39;logK&#39;] = -result.out[&#39;G&#39;] / (np.log(10) * R * T_array)

        # Display tables in Jupyter notebooks if show=True
        if show:
            _display_subcrt_result(result)

        # Print warnings (matching R CHNOSZ behavior - lines 621-624)
        if result.warnings and messages:
            for warn in result.warnings:
                warnings.warn(warn)

        return result
        
    except Exception as e:
        result.warnings.append(f&#34;subcrt error: {str(e)}&#34;)
        raise</code></pre>
</details>
<div class="desc"><p>Calculate standard molal thermodynamic properties of species and reactions.</p>
<p>This function reproduces the behavior of R CHNOSZ subcrt() exactly, including
all argument handling, validation, calculations, and output formatting.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>species</code></strong> :&ensp;<code>str, list</code> of <code>str, int,</code> or <code>list</code> of <code>int</code></dt>
<dd>Species names, formulas, or indices in thermodynamic database</dd>
<dt><strong><code>coeff</code></strong> :&ensp;<code>int, float, list,</code> or <code>None</code></dt>
<dd>Stoichiometric coefficients for reaction calculation
If 1 (default), calculate individual species properties
If list, calculate reaction with given coefficients</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>None</code></dt>
<dd>Physical states ("aq", "cr", "gas", "liq") for species</dd>
<dt><strong><code>property</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>Properties to calculate: "logK", "G", "H", "S", "V", "Cp", "rho", "kT", "E"</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float, list,</code> or <code>ndarray</code></dt>
<dd>Temperature(s) in K (default: 273.15 to 623.15 by 25 K)</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float, list, ndarray,</code> or <code>"Psat"</code></dt>
<dd>Pressure(s) in bar or "Psat" for saturation pressure</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>Grid calculation mode: "T", "P", "IS", or None</dd>
<dt><strong><code>convert</code></strong> :&ensp;<code>bool</code></dt>
<dd>Convert temperature/pressure units (default: True)</dd>
<dt><strong><code>exceed_Ttr</code></strong> :&ensp;<code>bool</code></dt>
<dd>Allow calculations beyond transition temperatures (default: False)</dd>
<dt><strong><code>exceed_rhomin</code></strong> :&ensp;<code>bool</code></dt>
<dd>Allow calculations below minimum water density (default: False)</dd>
<dt><strong><code>logact</code></strong> :&ensp;<code>list</code> of <code>float</code> or <code>None</code></dt>
<dd>Activity coefficients (log10 scale)</dd>
<dt><strong><code>autobalance</code></strong> :&ensp;<code>bool</code></dt>
<dd>Automatically balance reactions using basis species (default: True)</dd>
<dt><strong><code>use_polymorphs</code></strong> :&ensp;<code>bool</code></dt>
<dd>Include polymorphic phases for minerals (default: True)</dd>
<dt><strong><code>IS</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code></dt>
<dd>Ionic strength for activity corrections (default: 0)</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to display result tables in Jupyter notebooks (default: True)
Set to False when calling subcrt() from other functions</dd>
<dt><strong><code>basis</code></strong> :&ensp;<code>pd.DataFrame</code>, optional</dt>
<dd>Basis species definition to use for autobalancing (if not using global basis)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SubcrtResult</code></dt>
<dd>Object containing:
- species: DataFrame with species information
- out: DataFrame with calculated thermodynamic properties
- reaction: DataFrame with reaction stoichiometry (if reaction)
- warnings: List of warning messages</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Single species properties
&gt;&gt;&gt; result = subcrt(&quot;H2O&quot;, T=25, P=1)
&gt;&gt;&gt; print(result.out[[&quot;G&quot;, &quot;H&quot;, &quot;S&quot;, &quot;Cp&quot;]])
&gt;&gt;&gt; 
&gt;&gt;&gt; # Reaction calculation
&gt;&gt;&gt; result = subcrt([&quot;H2O&quot;, &quot;H+&quot;, &quot;OH-&quot;], [-1, 1, 1], T=25, P=1)
&gt;&gt;&gt; print(f&quot;Water dissociation ΔG° = {result.out.G[0]:.3f} kJ/mol&quot;)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Temperature array
&gt;&gt;&gt; result = subcrt(&quot;quartz&quot;, T=[25, 100, 200], P=1)
&gt;&gt;&gt; print(result.out[[&quot;T&quot;, &quot;G&quot;, &quot;H&quot;, &quot;S&quot;]])
</code></pre>
<h2 id="notes">Notes</h2>
<p>This implementation maintains complete fidelity to R CHNOSZ subcrt():
- Identical argument processing and validation
- Same species lookup and polymorphic handling
- Exact HKF and CGL equation-of-state calculations
- Same reaction balancing and autobalance logic
- Identical output structure and formatting
- Same warning and error messages</p></div>
</dd>
<dt id="pychnosz.syslab"><code class="name flex">
<span>def <span class="ident">syslab</span></span>(<span>system: list = None, dash: str = '-') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syslab(system: list = None, dash: str = &#34;-&#34;) -&gt; str:
    &#34;&#34;&#34;
    Create formatted text for thermodynamic system.

    This generates a label showing the components of a thermodynamic system,
    separated by dashes (or other separator).

    Parameters
    ----------
    system : list of str, optional
        List of component formulas. Default: [&#34;K2O&#34;, &#34;Al2O3&#34;, &#34;SiO2&#34;, &#34;H2O&#34;]
    dash : str, default &#34;-&#34;
        Separator between components

    Returns
    -------
    str
        LaTeX-formatted string for the system label

    Examples
    --------
    &gt;&gt;&gt; syslab([&#34;K2O&#34;, &#34;Al2O3&#34;, &#34;SiO2&#34;, &#34;H2O&#34;])
    &#39;$K_{2}O-Al_{2}O_{3}-SiO_{2}-H_{2}O$&#39;

    &gt;&gt;&gt; syslab([&#34;CaO&#34;, &#34;MgO&#34;, &#34;SiO2&#34;], dash=&#34;–&#34;)
    &#39;$CaO–MgO–SiO_{2}$&#39;
    &#34;&#34;&#34;
    if system is None:
        system = [&#34;K2O&#34;, &#34;Al2O3&#34;, &#34;SiO2&#34;, &#34;H2O&#34;]

    # Format each component
    formatted_components = []
    for component in system:
        formatted = _add_subscripts(component)
        formatted_components.append(formatted)

    # Join with separator
    label = dash.join(formatted_components)

    # Wrap in LaTeX math mode
    return f&#34;${label}$&#34;</code></pre>
</details>
<div class="desc"><p>Create formatted text for thermodynamic system.</p>
<p>This generates a label showing the components of a thermodynamic system,
separated by dashes (or other separator).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of component formulas. Default: ["K2O", "Al2O3", "SiO2", "H2O"]</dd>
<dt><strong><code>dash</code></strong> :&ensp;<code>str</code>, default <code>"-"</code></dt>
<dd>Separator between components</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>LaTeX-formatted string for the system label</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; syslab([&quot;K2O&quot;, &quot;Al2O3&quot;, &quot;SiO2&quot;, &quot;H2O&quot;])
'$K_{2}O-Al_{2}O_{3}-SiO_{2}-H_{2}O$'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; syslab([&quot;CaO&quot;, &quot;MgO&quot;, &quot;SiO2&quot;], dash=&quot;–&quot;)
'$CaO–MgO–SiO_{2}$'
</code></pre></div>
</dd>
<dt id="pychnosz.syslab_html"><code class="name flex">
<span>def <span class="ident">syslab_html</span></span>(<span>system: list = None, dash: str = '-') ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syslab_html(system: list = None, dash: str = &#34;-&#34;) -&gt; str:
    &#34;&#34;&#34;
    Create HTML-formatted text for thermodynamic system (for Plotly).

    This generates a label showing the components of a thermodynamic system,
    separated by dashes (or other separator), using HTML formatting compatible
    with Plotly instead of LaTeX.

    Parameters
    ----------
    system : list of str, optional
        List of component formulas. Default: [&#34;K2O&#34;, &#34;Al2O3&#34;, &#34;SiO2&#34;, &#34;H2O&#34;]
    dash : str, default &#34;-&#34;
        Separator between components

    Returns
    -------
    str
        HTML-formatted string for the system label

    Examples
    --------
    &gt;&gt;&gt; syslab_html([&#34;K2O&#34;, &#34;Al2O3&#34;, &#34;SiO2&#34;, &#34;H2O&#34;])
    &#39;K&lt;sub&gt;2&lt;/sub&gt;O-Al&lt;sub&gt;2&lt;/sub&gt;O&lt;sub&gt;3&lt;/sub&gt;-SiO&lt;sub&gt;2&lt;/sub&gt;-H&lt;sub&gt;2&lt;/sub&gt;O&#39;

    &gt;&gt;&gt; syslab_html([&#34;CaO&#34;, &#34;MgO&#34;, &#34;SiO2&#34;], dash=&#34;–&#34;)
    &#39;CaO–MgO–SiO&lt;sub&gt;2&lt;/sub&gt;&#39;

    Notes
    -----
    Use this function instead of syslab() when creating titles for interactive
    (Plotly) diagrams. The HTML formatting is compatible with Plotly&#39;s rendering.

    Requires: WORMutils (for chemlabel)
    &#34;&#34;&#34;
    if not _HTML_DEPS_AVAILABLE:
        raise ImportError(
            &#34;syslab_html() requires &#39;WORMutils&#39; package.\n&#34;
            &#34;Install with: pip install WORMutils&#34;
        )

    if system is None:
        system = [&#34;K2O&#34;, &#34;Al2O3&#34;, &#34;SiO2&#34;, &#34;H2O&#34;]

    # Format each component using HTML via chemlabel
    formatted_components = []
    for component in system:
        formatted = chemlabel(component)
        formatted_components.append(formatted)

    # Join with separator (no HTML wrapper needed)
    label = dash.join(formatted_components)

    return label</code></pre>
</details>
<div class="desc"><p>Create HTML-formatted text for thermodynamic system (for Plotly).</p>
<p>This generates a label showing the components of a thermodynamic system,
separated by dashes (or other separator), using HTML formatting compatible
with Plotly instead of LaTeX.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>system</code></strong> :&ensp;<code>list</code> of <code>str</code>, optional</dt>
<dd>List of component formulas. Default: ["K2O", "Al2O3", "SiO2", "H2O"]</dd>
<dt><strong><code>dash</code></strong> :&ensp;<code>str</code>, default <code>"-"</code></dt>
<dd>Separator between components</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>HTML-formatted string for the system label</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; syslab_html([&quot;K2O&quot;, &quot;Al2O3&quot;, &quot;SiO2&quot;, &quot;H2O&quot;])
'K&lt;sub&gt;2&lt;/sub&gt;O-Al&lt;sub&gt;2&lt;/sub&gt;O&lt;sub&gt;3&lt;/sub&gt;-SiO&lt;sub&gt;2&lt;/sub&gt;-H&lt;sub&gt;2&lt;/sub&gt;O'
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; syslab_html([&quot;CaO&quot;, &quot;MgO&quot;, &quot;SiO2&quot;], dash=&quot;–&quot;)
'CaO–MgO–SiO&lt;sub&gt;2&lt;/sub&gt;'
</code></pre>
<h2 id="notes">Notes</h2>
<p>Use this function instead of syslab() when creating titles for interactive
(Plotly) diagrams. The HTML formatting is compatible with Plotly's rendering.</p>
<p>Requires: WORMutils (for chemlabel)</p></div>
</dd>
<dt id="pychnosz.thermo"><code class="name flex">
<span>def <span class="ident">thermo</span></span>(<span>*args, messages=True, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def thermo(*args, messages=True, **kwargs):
    &#34;&#34;&#34;
    Access or modify the thermodynamic system data object.

    This function provides a convenient interface to get or set parts of the
    thermodynamic system, similar to R&#39;s par() function for graphics parameters.

    Parameters
    ----------
    *args : str or list of str
        Names of attributes to retrieve (e.g., &#34;element&#34;, &#34;opt$ideal.H&#34;)
        For nested access, use &#34;$&#34; notation (e.g., &#34;opt$E.units&#34;)
        Special values:
        - &#34;WORM&#34;: Load the WORM thermodynamic database (Python-exclusive feature)
    messages : bool, default True
        Whether to print informational messages during operations
    **kwargs : any
        Named arguments to set attributes (e.g., element=new_df, opt={&#39;E.units&#39;: &#39;cal&#39;})
        For nested attributes, use &#34;$&#34; in the name (e.g., **{&#34;opt$ideal.H&#34;: False})

    Returns
    -------
    various
        - If no arguments: returns the ThermoSystem object
        - If single unnamed argument: returns the requested value
        - If multiple unnamed arguments: returns list of requested values
        - If named arguments: returns original values before modification

    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; # Get the entire thermo object
    &gt;&gt;&gt; ts = pychnosz.thermo()

    &gt;&gt;&gt; # Get a specific attribute
    &gt;&gt;&gt; elem = pychnosz.thermo(&#34;element&#34;)

    &gt;&gt;&gt; # Get nested attribute
    &gt;&gt;&gt; e_units = pychnosz.thermo(&#34;opt$E.units&#34;)

    &gt;&gt;&gt; # Get multiple attributes
    &gt;&gt;&gt; elem, buf = pychnosz.thermo(&#34;element&#34;, &#34;buffer&#34;)

    &gt;&gt;&gt; # Set an attribute
    &gt;&gt;&gt; old_elem = pychnosz.thermo(element=new_element_df)

    &gt;&gt;&gt; # Set nested attribute
    &gt;&gt;&gt; old_units = pychnosz.thermo(**{&#34;opt$ideal.H&#34;: False})

    &gt;&gt;&gt; # Load WORM database (Python-exclusive feature)
    &gt;&gt;&gt; pychnosz.thermo(&#34;WORM&#34;)

    &gt;&gt;&gt; # Suppress messages
    &gt;&gt;&gt; pychnosz.thermo(&#34;WORM&#34;, messages=False)

    Notes
    -----
    This function mimics the behavior of R CHNOSZ thermo() function,
    providing flexible access to the thermodynamic data object.

    The &#34;WORM&#34; special argument is a Python-exclusive feature that loads
    the Water-Organic-Rock-Microbe thermodynamic database from the
    WORM-db GitHub repository.
    &#34;&#34;&#34;
    # Get the global thermo system
    thermo_sys = get_thermo_system()

    # If no arguments, return the entire object
    if len(args) == 0 and len(kwargs) == 0:
        return thermo_sys

    # Handle character vectors passed as args (like R&#39;s c(&#34;basis&#34;, &#34;species&#34;))
    # If all args are strings or lists of strings, flatten them
    flat_args = []
    for arg in args:
        if isinstance(arg, (list, tuple)) and all(isinstance(x, str) for x in arg):
            flat_args.extend(arg)
        else:
            flat_args.append(arg)
    args = flat_args

    # Prepare return values list
    return_values = []

    # Ensure system is initialized if needed (before accessing any properties)
    # This prevents auto-initialization from using hardcoded messages=True
    if not thermo_sys.is_initialized() and len(args) &gt; 0:
        thermo_sys.reset(messages=messages)

    # Process unnamed arguments (getters)
    for arg in args:
        if not isinstance(arg, str):
            raise TypeError(f&#34;Unnamed arguments must be strings, got {type(arg)}&#34;)

        # Special handling for &#34;WORM&#34; - load WORM database
        if arg.upper() == &#34;WORM&#34;:
            from ..data.worm import load_WORM
            success = load_WORM(keep_default=False, messages=messages)
            return_values.append(success)
            continue

        # Parse the argument to get slots (handle nested access with $)
        slots = arg.split(&#39;$&#39;)

        # Get the value from thermo_sys
        value = thermo_sys
        for slot in slots:
            # Handle OBIGT case-insensitively (R uses uppercase, Python uses lowercase)
            slot_lower = slot.lower()
            if hasattr(value, slot_lower):
                value = getattr(value, slot_lower)
            elif hasattr(value, slot):
                value = getattr(value, slot)
            elif isinstance(value, dict) and slot in value:
                value = value[slot]
            else:
                raise AttributeError(f&#34;Attribute &#39;{arg}&#39; not found in thermo object&#34;)

        return_values.append(value)

    # Process named arguments (setters)
    setter_returns = {}

    # Ensure system is initialized if needed (before setting any properties)
    if not thermo_sys.is_initialized() and len(kwargs) &gt; 0:
        thermo_sys.reset(messages=messages)

    for key, new_value in kwargs.items():
        # Parse the key to get slots
        slots = key.split(&#39;$&#39;)

        # Get the original value before modification
        orig_value = thermo_sys
        for slot in slots:
            # Handle case-insensitive attribute access (for OBIGT, etc.)
            slot_lower = slot.lower()
            if hasattr(orig_value, slot_lower):
                orig_value = getattr(orig_value, slot_lower)
            elif hasattr(orig_value, slot):
                orig_value = getattr(orig_value, slot)
            elif isinstance(orig_value, dict) and slot in orig_value:
                orig_value = orig_value[slot]
            else:
                raise AttributeError(f&#34;Attribute &#39;{key}&#39; not found in thermo object&#34;)

        setter_returns[key] = orig_value

        # Set the new value
        if len(slots) == 1:
            # Direct attribute
            # Special handling for OBIGT - normalize index and handle refs
            if slots[0].upper() == &#39;OBIGT&#39;:
                # Handle OBIGT replacement with proper index normalization
                _set_obigt_data(thermo_sys, new_value)
            else:
                # Use lowercase version if it exists (Python convention)
                slot_lower = slots[0].lower()
                if hasattr(thermo_sys, slot_lower):
                    setattr(thermo_sys, slot_lower, new_value)
                else:
                    setattr(thermo_sys, slots[0], new_value)
        elif len(slots) == 2:
            # Nested attribute (e.g., opt$ideal.H)
            parent = getattr(thermo_sys, slots[0])
            if isinstance(parent, dict):
                parent[slots[1]] = new_value
            else:
                setattr(parent, slots[1], new_value)
        else:
            # Deeper nesting (if needed)
            current = thermo_sys
            for i, slot in enumerate(slots[:-1]):
                if hasattr(current, slot):
                    current = getattr(current, slot)
                elif isinstance(current, dict) and slot in current:
                    current = current[slot]

            # Set the final value
            final_slot = slots[-1]
            if isinstance(current, dict):
                current[final_slot] = new_value
            else:
                setattr(current, final_slot, new_value)

    # Determine return value based on R&#39;s behavior
    if len(kwargs) &gt; 0:
        # If we had setters, return the original values as a named dict
        # In R, setters always return a named list
        if len(args) == 0:
            # Only setters - return dict (named list in R)
            return setter_returns
        else:
            # Mix of getters and setters - return all original values
            combined = {}
            for i, arg in enumerate(args):
                combined[arg] = return_values[i]
            combined.update(setter_returns)
            return combined
    else:
        # Only getters
        # Single unnamed argument returns the value directly
        if len(return_values) == 1:
            return return_values[0]
        return return_values</code></pre>
</details>
<div class="desc"><p>Access or modify the thermodynamic system data object.</p>
<p>This function provides a convenient interface to get or set parts of the
thermodynamic system, similar to R's par() function for graphics parameters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Names of attributes to retrieve (e.g., "element", "opt$ideal.H")
For nested access, use "$" notation (e.g., "opt$E.units")
Special values:
- "WORM": Load the WORM thermodynamic database (Python-exclusive feature)</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages during operations</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>any</code></dt>
<dd>Named arguments to set attributes (e.g., element=new_df, opt={'E.units': 'cal'})
For nested attributes, use "$" in the name (e.g., **{"opt$ideal.H": False})</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>various</code></dt>
<dd>
<ul>
<li>If no arguments: returns the ThermoSystem object</li>
<li>If single unnamed argument: returns the requested value</li>
<li>If multiple unnamed arguments: returns list of requested values</li>
<li>If named arguments: returns original values before modification</li>
</ul>
</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; # Get the entire thermo object
&gt;&gt;&gt; ts = pychnosz.thermo()
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get a specific attribute
&gt;&gt;&gt; elem = pychnosz.thermo(&quot;element&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get nested attribute
&gt;&gt;&gt; e_units = pychnosz.thermo(&quot;opt$E.units&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Get multiple attributes
&gt;&gt;&gt; elem, buf = pychnosz.thermo(&quot;element&quot;, &quot;buffer&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Set an attribute
&gt;&gt;&gt; old_elem = pychnosz.thermo(element=new_element_df)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Set nested attribute
&gt;&gt;&gt; old_units = pychnosz.thermo(**{&quot;opt$ideal.H&quot;: False})
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Load WORM database (Python-exclusive feature)
&gt;&gt;&gt; pychnosz.thermo(&quot;WORM&quot;)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Suppress messages
&gt;&gt;&gt; pychnosz.thermo(&quot;WORM&quot;, messages=False)
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function mimics the behavior of R CHNOSZ thermo() function,
providing flexible access to the thermodynamic data object.</p>
<p>The "WORM" special argument is a Python-exclusive feature that loads
the Water-Organic-Rock-Microbe thermodynamic database from the
WORM-db GitHub repository.</p></div>
</dd>
<dt id="pychnosz.unicurve"><code class="name flex">
<span>def <span class="ident">unicurve</span></span>(<span>logK: int | float | List[int | float],<br>species: str | List[str] | int | List[int],<br>coeff: int | float | List[int | float],<br>state: str | List[str],<br>pressures: float | List[float] = 1,<br>temperatures: float | List[float] = 25,<br>IS: float = 0,<br>minT: float = 0.1,<br>maxT: float = 100,<br>minP: float = 1,<br>maxP: float = 500,<br>tol: float | None = None,<br>solve: str = 'T',<br>messages: bool = True,<br>show: bool = True,<br>plot_it: bool = True,<br>width: int = 600,<br>height: int = 400,<br>res: int = 200) ‑> <a title="pychnosz.core.unicurve.UnivariantResult" href="core/unicurve.html#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a> | List[<a title="pychnosz.core.unicurve.UnivariantResult" href="core/unicurve.html#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unicurve(logK: Union[float, int, List[Union[float, int]]],
             species: Union[str, List[str], int, List[int]],
             coeff: Union[int, float, List[Union[int, float]]],
             state: Union[str, List[str]],
             pressures: Union[float, List[float]] = 1,
             temperatures: Union[float, List[float]] = 25,
             IS: float = 0,
             minT: float = 0.1,
             maxT: float = 100,
             minP: float = 1,
             maxP: float = 500,
             tol: Optional[float] = None,
             solve: str = &#34;T&#34;,
             messages: bool = True,
             show: bool = True,
             plot_it: bool = True,
             width: int = 600,
             height: int = 400,
             res: int = 200) -&gt; Union[UnivariantResult, List[UnivariantResult]]:
    &#34;&#34;&#34;
    Solve for temperatures or pressures of equilibration for a given logK value(s).

    This function calculates univariant curves useful for aqueous geothermometry
    and geobarometry. Given a measured equilibrium constant (logK) for a reaction,
    it solves for the temperatures (at specified pressures) or pressures (at
    specified temperatures) where the reaction would produce that logK value.

    The solver uses scipy.optimize.brentq (Brent&#39;s method), which combines
    bisection, secant, and inverse quadratic interpolation for efficient and
    robust convergence. This is ~100x faster than the original binary search
    algorithm while maintaining identical numerical accuracy.

    Parameters
    ----------
    logK : float, int, or list of float or int
        Logarithm (base 10) of the equilibrium constant(s). When a list is
        provided, each logK value is processed separately and a list of results
        is returned.
    species : str, int, or list of str or int
        Name, formula, or database index of species involved in the reaction
    coeff : int, float, or list
        Reaction stoichiometric coefficients (negative for reactants, positive for products)
    state : str or list of str
        Physical state(s) of species: &#34;aq&#34;, &#34;cr&#34;, &#34;gas&#34;, &#34;liq&#34;
    pressures : float or list of float, default 1
        Pressure(s) in bars (used when solving for temperature)
    temperatures : float or list of float, default 25
        Temperature(s) in °C (used when solving for pressure)
    IS : float, default 0
        Ionic strength for activity corrections (mol/kg)
    minT : float, default 0.1
        Minimum temperature (°C) to search (ignored when solving for pressure)
    maxT : float, default 100
        Maximum temperature (°C) to search (ignored when solving for pressure)
    minP : float, default 1
        Minimum pressure (bar) to search (ignored when solving for temperature)
    maxP : float, default 500
        Maximum pressure (bar) to search (ignored when solving for temperature)
    tol : float, optional
        Tolerance for convergence. Default: 1/(10^(n+2)) where n is number of
        decimal places in logK, with maximum default of 1e-5
    solve : str, default &#34;T&#34;
        What to solve for: &#34;T&#34; for temperature or &#34;P&#34; for pressure
    messages : bool, default True
        Print informational messages
    show : bool, default True
        Display result table
    plot_it : bool, default True
        Display interactive plotly plot showing logK vs T (or P) with target logK
        as horizontal line and intersection points marked
    width : int, default 600
        Plot width in pixels (used if plot_it=True)
    height : int, default 400
        Plot height in pixels (used if plot_it=True)
    res : int, default 200
        Number of points to calculate for plotting the logK curve
        (used if plot_it=True)

    Returns
    -------
    UnivariantResult or list of UnivariantResult
        When logK is a single value: returns a UnivariantResult object.
        When logK is a list: returns a list of UnivariantResult objects.
        Each result contains:
        - reaction: DataFrame with reaction stoichiometry
        - out: DataFrame with solved T or P values and thermodynamic properties
        - warnings: List of warning messages

    Examples
    --------
    &gt;&gt;&gt; from pychnosz import unicurve, reset
    &gt;&gt;&gt; reset()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Solve for temperature: quartz dissolution
    &gt;&gt;&gt; # SiO2(quartz) = SiO2(aq)
    &gt;&gt;&gt; result = unicurve(logK=-2.71, species=[&#34;quartz&#34;, &#34;SiO2&#34;],
    ...                   state=[&#34;cr&#34;, &#34;aq&#34;], coeff=[-1, 1],
    ...                   pressures=200, minT=1, maxT=350)
    &gt;&gt;&gt; print(result.out[[&#34;P&#34;, &#34;T&#34;, &#34;logK&#34;]])
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Solve for pressure: water dissociation
    &gt;&gt;&gt; result = unicurve(logK=-14, species=[&#34;H2O&#34;, &#34;H+&#34;, &#34;OH-&#34;],
    ...                   state=[&#34;liq&#34;, &#34;aq&#34;, &#34;aq&#34;], coeff=[-1, 1, 1],
    ...                   temperatures=[25, 50, 75], solve=&#34;P&#34;,
    ...                   minP=1, maxP=1000)
    &gt;&gt;&gt; print(result.out[[&#34;T&#34;, &#34;P&#34;, &#34;logK&#34;]])

    Notes
    -----
    This function uses scipy.optimize.brentq for root-finding, which provides:
    - Guaranteed convergence if root is bracketed
    - Typical convergence in 5-15 function evaluations
    - ~100x speedup compared to custom binary search (1600 → 15 evaluations)
    - Identical numerical results to original implementation

    The algorithm also implements &#34;warm start&#34; optimization: when solving for
    multiple pressures/temperatures, previous solutions are used to intelligently
    bracket subsequent searches, further improving performance.

    References
    ----------
    Based on univariant.r from pyCHNOSZ by Grayson Boyer
    Optimized using Brent, R. P. (1973). Algorithms for Minimization without Derivatives.
    &#34;&#34;&#34;
    # Track whether input was a single value or list
    single_logK_input = not isinstance(logK, list)

    # Ensure logK is a list for processing
    if single_logK_input:
        logK_list = [logK]
    else:
        logK_list = logK

    # Ensure species, state, and coeff are lists
    if not isinstance(species, list):
        species = [species]
    if not isinstance(state, list):
        state = [state]
    if not isinstance(coeff, list):
        coeff = [coeff]

    # Process each logK value
    results = []

    for this_logK in logK_list:
        result = UnivariantResult()

        # Set default tolerance based on logK precision
        if tol is None:
            # Count decimal places in logK
            logK_str = str(float(this_logK))
            if &#39;.&#39; in logK_str:
                n_decimals = len(logK_str.split(&#39;.&#39;)[1].rstrip(&#39;0&#39;))
            else:
                n_decimals = 0
            this_tol = 10 ** (-(n_decimals + 2))
            if this_tol &gt; 1e-5:
                this_tol = 1e-5
        else:
            this_tol = tol

        # Get reaction information from first subcrt call
        try:
            initial_calc = subcrt(species, coeff=coeff, state=state, T=25, P=1,
                                 exceed_Ttr=True, messages=False, show=False)
            result.reaction = initial_calc.reaction
        except Exception as e:
            if messages:
                warnings.warn(f&#34;Error getting reaction information: {str(e)}&#34;)
            result.reaction = None

        if solve.upper() == &#34;T&#34;:
            # Solve for temperature at given pressure(s)
            if not isinstance(pressures, list):
                pressures = [pressures]

            results_list = []
            prev_T = None  # For warm start optimization

            for i, pressure in enumerate(pressures):
                if messages:
                    print(f&#34;Solving for T at P = {pressure} bar (logK = {this_logK})...&#34;)

                # Warm start: use previous solution to narrow search range if available
                current_minT = minT
                current_maxT = maxT
                if prev_T is not None and minT &lt; prev_T &lt; maxT:
                    # Center search around previous solution with a safety margin
                    # logK typically changes by ~0.006 per °C, so ±50°C should be safe
                    margin = 50
                    current_minT = max(minT, prev_T - margin)
                    current_maxT = min(maxT, prev_T + margin)
                    if messages:
                        print(f&#34;  Using warm start: searching {current_minT:.1f} to {current_maxT:.1f}°C&#34;)

                result_dict = _solve_T_for_pressure(this_logK, species, state, coeff, pressure,
                                           IS, current_minT, current_maxT, this_tol,
                                           initial_guess=prev_T, messages=messages)

                # If warm start failed, try full range
                if result_dict[&#39;T&#39;] is None and prev_T is not None:
                    if messages:
                        print(f&#34;  Warm start failed, searching full range...&#34;)
                    result_dict = _solve_T_for_pressure(this_logK, species, state, coeff, pressure,
                                               IS, minT, maxT, this_tol, messages=messages)

                results_list.append(result_dict)

                # Update for next warm start
                if result_dict[&#39;T&#39;] is not None:
                    prev_T = result_dict[&#39;T&#39;]

            result.out = pd.DataFrame(results_list)

        elif solve.upper() == &#34;P&#34;:
            # Solve for pressure at given temperature(s)
            if not isinstance(temperatures, list):
                temperatures = [temperatures]

            results_list = []
            prev_P = None  # For warm start optimization

            for i, temperature in enumerate(temperatures):
                if messages:
                    print(f&#34;Solving for P at T = {temperature} °C (logK = {this_logK})...&#34;)

                # Warm start: use previous solution to narrow search range if available
                current_minP = minP
                current_maxP = maxP
                if prev_P is not None and minP &lt; prev_P &lt; maxP:
                    # Center search around previous solution with a safety margin
                    # Pressure effects vary, use a generous ±500 bar margin
                    margin = 500
                    current_minP = max(minP, prev_P - margin)
                    current_maxP = min(maxP, prev_P + margin)
                    if messages:
                        print(f&#34;  Using warm start: searching {current_minP:.0f} to {current_maxP:.0f} bar&#34;)

                result_dict = _solve_P_for_temperature(this_logK, species, state, coeff, temperature,
                                              IS, current_minP, current_maxP, this_tol,
                                              initial_guess=prev_P, messages=messages)

                # If warm start failed, try full range
                if result_dict[&#39;P&#39;] is None and prev_P is not None:
                    if messages:
                        print(f&#34;  Warm start failed, searching full range...&#34;)
                    result_dict = _solve_P_for_temperature(this_logK, species, state, coeff, temperature,
                                                  IS, minP, maxP, this_tol, messages=messages)

                results_list.append(result_dict)

                # Update for next warm start
                if result_dict[&#39;P&#39;] is not None:
                    prev_P = result_dict[&#39;P&#39;]

            result.out = pd.DataFrame(results_list)

        else:
            raise ValueError(f&#34;solve must be &#39;T&#39; or &#39;P&#39;, got &#39;{solve}&#39;&#34;)

        # Create interactive plot if requested
        if plot_it:
            if not PLOTLY_AVAILABLE:
                warnings.warn(&#34;plotly is not installed. Set plot_it=False to suppress this warning, &#34;
                             &#34;or install plotly with: pip install plotly&#34;)
            else:
                result.fig = _create_unicurve_plot(this_logK, species, state, coeff, result, solve,
                                                   minT, maxT, minP, maxP, IS, width, height, res, messages)

        # Display result if requested
        if show and result.out is not None:
            try:
                from IPython.display import display
                if result.reaction is not None:
                    print(&#34;\nReaction:&#34;)
                    display(result.reaction)
                print(f&#34;\nResults (logK = {this_logK}):&#34;)
                display(result.out)
            except ImportError:
                # Not in Jupyter, just print
                if result.reaction is not None:
                    print(&#34;\nReaction:&#34;)
                    print(result.reaction)
                print(f&#34;\nResults (logK = {this_logK}):&#34;)
                print(result.out)

        # Add this result to the list
        results.append(result)

    # Return single result or list based on input
    if single_logK_input:
        return results[0]
    else:
        return results</code></pre>
</details>
<div class="desc"><p>Solve for temperatures or pressures of equilibration for a given logK value(s).</p>
<p>This function calculates univariant curves useful for aqueous geothermometry
and geobarometry. Given a measured equilibrium constant (logK) for a reaction,
it solves for the temperatures (at specified pressures) or pressures (at
specified temperatures) where the reaction would produce that logK value.</p>
<p>The solver uses scipy.optimize.brentq (Brent's method), which combines
bisection, secant, and inverse quadratic interpolation for efficient and
robust convergence. This is ~100x faster than the original binary search
algorithm while maintaining identical numerical accuracy.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logK</code></strong> :&ensp;<code>float, int,</code> or <code>list</code> of <code>float</code> or <code>int</code></dt>
<dd>Logarithm (base 10) of the equilibrium constant(s). When a list is
provided, each logK value is processed separately and a list of results
is returned.</dd>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int,</code> or <code>list</code> of <code>str</code> or <code>int</code></dt>
<dd>Name, formula, or database index of species involved in the reaction</dd>
<dt><strong><code>coeff</code></strong> :&ensp;<code>int, float,</code> or <code>list</code></dt>
<dd>Reaction stoichiometric coefficients (negative for reactants, positive for products)</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Physical state(s) of species: "aq", "cr", "gas", "liq"</dd>
<dt><strong><code>pressures</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, default <code>1</code></dt>
<dd>Pressure(s) in bars (used when solving for temperature)</dd>
<dt><strong><code>temperatures</code></strong> :&ensp;<code>float</code> or <code>list</code> of <code>float</code>, default <code>25</code></dt>
<dd>Temperature(s) in °C (used when solving for pressure)</dd>
<dt><strong><code>IS</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Ionic strength for activity corrections (mol/kg)</dd>
<dt><strong><code>minT</code></strong> :&ensp;<code>float</code>, default <code>0.1</code></dt>
<dd>Minimum temperature (°C) to search (ignored when solving for pressure)</dd>
<dt><strong><code>maxT</code></strong> :&ensp;<code>float</code>, default <code>100</code></dt>
<dd>Maximum temperature (°C) to search (ignored when solving for pressure)</dd>
<dt><strong><code>minP</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Minimum pressure (bar) to search (ignored when solving for temperature)</dd>
<dt><strong><code>maxP</code></strong> :&ensp;<code>float</code>, default <code>500</code></dt>
<dd>Maximum pressure (bar) to search (ignored when solving for temperature)</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Tolerance for convergence. Default: 1/(10^(n+2)) where n is number of
decimal places in logK, with maximum default of 1e-5</dd>
<dt><strong><code>solve</code></strong> :&ensp;<code>str</code>, default <code>"T"</code></dt>
<dd>What to solve for: "T" for temperature or "P" for pressure</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Print informational messages</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display result table</dd>
<dt><strong><code>plot_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display interactive plotly plot showing logK vs T (or P) with target logK
as horizontal line and intersection points marked</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, default <code>600</code></dt>
<dd>Plot width in pixels (used if plot_it=True)</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, default <code>400</code></dt>
<dd>Plot height in pixels (used if plot_it=True)</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>int</code>, default <code>200</code></dt>
<dd>Number of points to calculate for plotting the logK curve
(used if plot_it=True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>UnivariantResult</code> or <code>list</code> of <code>UnivariantResult</code></dt>
<dd>When logK is a single value: returns a UnivariantResult object.
When logK is a list: returns a list of UnivariantResult objects.
Each result contains:
- reaction: DataFrame with reaction stoichiometry
- out: DataFrame with solved T or P values and thermodynamic properties
- warnings: List of warning messages</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz import unicurve, reset
&gt;&gt;&gt; reset()
&gt;&gt;&gt;
&gt;&gt;&gt; # Solve for temperature: quartz dissolution
&gt;&gt;&gt; # SiO2(quartz) = SiO2(aq)
&gt;&gt;&gt; result = unicurve(logK=-2.71, species=[&quot;quartz&quot;, &quot;SiO2&quot;],
...                   state=[&quot;cr&quot;, &quot;aq&quot;], coeff=[-1, 1],
...                   pressures=200, minT=1, maxT=350)
&gt;&gt;&gt; print(result.out[[&quot;P&quot;, &quot;T&quot;, &quot;logK&quot;]])
&gt;&gt;&gt;
&gt;&gt;&gt; # Solve for pressure: water dissociation
&gt;&gt;&gt; result = unicurve(logK=-14, species=[&quot;H2O&quot;, &quot;H+&quot;, &quot;OH-&quot;],
...                   state=[&quot;liq&quot;, &quot;aq&quot;, &quot;aq&quot;], coeff=[-1, 1, 1],
...                   temperatures=[25, 50, 75], solve=&quot;P&quot;,
...                   minP=1, maxP=1000)
&gt;&gt;&gt; print(result.out[[&quot;T&quot;, &quot;P&quot;, &quot;logK&quot;]])
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function uses scipy.optimize.brentq for root-finding, which provides:
- Guaranteed convergence if root is bracketed
- Typical convergence in 5-15 function evaluations
- ~100x speedup compared to custom binary search (1600 → 15 evaluations)
- Identical numerical results to original implementation</p>
<p>The algorithm also implements "warm start" optimization: when solving for
multiple pressures/temperatures, previous solutions are used to intelligently
bracket subsequent searches, further improving performance.</p>
<h2 id="references">References</h2>
<p>Based on univariant.r from pyCHNOSZ by Grayson Boyer
Optimized using Brent, R. P. (1973). Algorithms for Minimization without Derivatives.</p></div>
</dd>
<dt id="pychnosz.univariant_TP"><code class="name flex">
<span>def <span class="ident">univariant_TP</span></span>(<span>logK: int | float | List[int | float],<br>species: str | List[str] | int | List[int],<br>coeff: int | float | List[int | float],<br>state: str | List[str],<br>Trange: List[float],<br>Prange: List[float],<br>IS: float = 0,<br>xlim: List[float] | None = None,<br>ylim: List[float] | None = None,<br>line_type: str = 'markers+lines',<br>tol: float | None = None,<br>title: str | None = None,<br>res: int = 10,<br>width: int = 500,<br>height: int = 400,<br>save_as: str | None = None,<br>save_format: str = 'png',<br>save_scale: float = 1,<br>show: bool = False,<br>messages: bool = False,<br>parallel: bool = True,<br>plot_it: bool = True) ‑> List[<a title="pychnosz.core.unicurve.UnivariantResult" href="core/unicurve.html#pychnosz.core.unicurve.UnivariantResult">UnivariantResult</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def univariant_TP(logK: Union[float, int, List[Union[float, int]]],
                  species: Union[str, List[str], int, List[int]],
                  coeff: Union[int, float, List[Union[int, float]]],
                  state: Union[str, List[str]],
                  Trange: List[float],
                  Prange: List[float],
                  IS: float = 0,
                  xlim: Optional[List[float]] = None,
                  ylim: Optional[List[float]] = None,
                  line_type: str = &#34;markers+lines&#34;,
                  tol: Optional[float] = None,
                  title: Optional[str] = None,
                  res: int = 10,
                  width: int = 500,
                  height: int = 400,
                  save_as: Optional[str] = None,
                  save_format: str = &#34;png&#34;,
                  save_scale: float = 1,
                  show: bool = False,
                  messages: bool = False,
                  parallel: bool = True,
                  plot_it: bool = True) -&gt; List[UnivariantResult]:
    &#34;&#34;&#34;
    Solve for temperatures and pressures of equilibration for given logK value(s)
    and produce an interactive T-P diagram.

    This function calculates univariant curves in temperature-pressure (T-P) space
    for one or more logK values. For each pressure in a range, it solves for the
    temperature where the reaction achieves the target logK. The resulting curves
    show phase boundaries or equilibrium conditions in T-P space.

    Parameters
    ----------
    logK : float, int, or list
        Logarithm (base 10) of equilibrium constant(s). Multiple values produce
        multiple curves on the same plot.
    species : str, int, or list of str or int
        Name, formula, or database index of species involved in the reaction
    coeff : int, float, or list
        Reaction stoichiometric coefficients (negative for reactants, positive for products)
    state : str or list of str
        Physical state(s) of species: &#34;aq&#34;, &#34;cr&#34;, &#34;gas&#34;, &#34;liq&#34;
    Trange : list of two floats
        [min, max] temperature range (°C) to search for solutions
    Prange : list of two floats
        [min, max] pressure range (bar) to calculate along
    IS : float, default 0
        Ionic strength for activity corrections (mol/kg)
    xlim : list of two floats, optional
        [min, max] range for x-axis (temperature) in plot
    ylim : list of two floats, optional
        [min, max] range for y-axis (pressure) in plot
    line_type : str, default &#34;markers+lines&#34;
        Plotly line type: &#34;markers+lines&#34;, &#34;markers&#34;, or &#34;lines&#34;
    tol : float, optional
        Convergence tolerance. Default: 1/(10^(n+2)) where n is decimal places in logK
    title : str, optional
        Plot title. Default: auto-generated from reaction
    res : int, default 10
        Number of pressure points to calculate along the curve
    width : int, default 500
        Plot width in pixels
    height : int, default 400
        Plot height in pixels
    save_as : str, optional
        Filename to save plot (without extension)
    save_format : str, default &#34;png&#34;
        Save format: &#34;png&#34;, &#34;jpg&#34;, &#34;jpeg&#34;, &#34;webp&#34;, &#34;svg&#34;, &#34;pdf&#34;, &#34;html&#34;
    save_scale : float, default 1
        Scale factor for saved plot
    show : bool, default False
        Display subcrt result tables
    messages : bool, default False
        Print informational messages
    parallel : bool, default True
        Use parallel processing across multiple logK values for faster computation.
        Utilizes multiple CPU cores when processing multiple logK curves.
    plot_it : bool, default True
        Display the plot

    Returns
    -------
    list of UnivariantResult
        List of UnivariantResult objects, one for each logK value.
        Each contains reaction information and T-P curve data.

    Examples
    --------
    &gt;&gt;&gt; from pychnosz import univariant_TP, reset
    &gt;&gt;&gt; reset()
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Calcite-aragonite phase boundary
    &gt;&gt;&gt; result = univariant_TP(
    ...     logK=0,
    ...     species=[&#34;calcite&#34;, &#34;aragonite&#34;],
    ...     state=[&#34;cr&#34;, &#34;cr&#34;],
    ...     coeff=[-1, 1],
    ...     Trange=[0, 700],
    ...     Prange=[2000, 16000]
    ... )
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Multiple curves for K-feldspar stability
    &gt;&gt;&gt; result = univariant_TP(
    ...     logK=[-8, -6, -4, -2],
    ...     species=[&#34;K-feldspar&#34;, &#34;kaolinite&#34;, &#34;H2O&#34;, &#34;SiO2&#34;, &#34;muscovite&#34;],
    ...     state=[&#34;cr&#34;, &#34;cr&#34;, &#34;liq&#34;, &#34;aq&#34;, &#34;cr&#34;],
    ...     coeff=[-1, -1, 1, 2, 1],
    ...     Trange=[0, 350],
    ...     Prange=[1, 5000],
    ...     res=20
    ... )

    Notes
    -----
    This function creates T-P diagrams by:
    1. Generating a range of pressures from Prange[0] to Prange[1]
    2. For each pressure, solving for T where logK matches the target
    3. Plotting the resulting T-P points as a curve

    For multiple logK values, each curve represents a different equilibrium
    condition. This is useful for:
    - Phase diagrams (e.g., mineral stability fields)
    - Isopleths (lines of constant logK)
    - Reaction boundaries

    Requires plotly for interactive plotting. If plotly is not installed,
    set plot_it=False to just return the data without plotting.

    References
    ----------
    Based on univariant_TP from pyCHNOSZ by Grayson Boyer
    &#34;&#34;&#34;

    # Check if plotly is available
    if plot_it and not PLOTLY_AVAILABLE:
        warnings.warn(&#34;plotly is not installed. Set plot_it=False to suppress this warning, &#34;
                     &#34;or install plotly with: pip install plotly&#34;)
        plot_it = False

    # Ensure logK is a list
    if not isinstance(logK, list):
        logK = [logK]

    # Create plotly figure
    if plot_it:
        fig = go.Figure()

    output = []

    # Generate pressure array
    pressures = np.linspace(Prange[0], Prange[1], res)

    # Process each logK value (in parallel if enabled)
    if parallel and len(logK) &gt; 1:
        # Parallel processing
        max_workers = min(len(logK), multiprocessing.cpu_count())

        # Prepare arguments for each logK value
        args_list = [
            (this_logK, species, state, coeff, pressures, Trange, IS, tol, show, messages)
            for this_logK in logK
        ]

        # Process in parallel
        with ProcessPoolExecutor(max_workers=max_workers) as executor:
            # Submit all tasks
            future_to_logK = {
                executor.submit(_process_single_logK, args): args[0]
                for args in args_list
            }

            # Collect results as they complete (maintains order via logK list)
            results_dict = {}
            for future in as_completed(future_to_logK):
                this_logK = future_to_logK[future]
                try:
                    out = future.result()
                    results_dict[this_logK] = out
                except Exception as e:
                    if messages:
                        print(f&#34;Error processing logK={this_logK}: {str(e)}&#34;)
                    # Create empty result
                    results_dict[this_logK] = None

            # Reorder results to match input logK order
            for this_logK in logK:
                out = results_dict.get(this_logK)
                if out is not None:
                    output.append(out)

                    # Add to plot if we have valid data
                    if plot_it and not out.out[&#39;T&#39;].isnull().all():
                        fig.add_trace(go.Scatter(
                            x=out.out[&#39;T&#39;],
                            y=out.out[&#39;P&#39;],
                            mode=line_type,
                            name=f&#34;logK={this_logK}&#34;,
                            text=[f&#34;logK={this_logK}&#34; for _ in range(len(out.out[&#39;T&#39;]))],
                            hovertemplate=&#39;%{text}&lt;br&gt;T, °C=%{x:.2f}&lt;br&gt;P, bar=%{y:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                        ))
                    elif out.out[&#39;T&#39;].isnull().all():
                        if messages:
                            print(f&#34;Could not find any T or P values in this range that correspond to a logK value of {this_logK}&#34;)

    else:
        # Sequential processing (original code)
        for this_logK in logK:
            # Set tolerance if not specified
            if tol is None:
                logK_str = str(float(this_logK))
                if &#39;.&#39; in logK_str:
                    n_decimals = len(logK_str.split(&#39;.&#39;)[1].rstrip(&#39;0&#39;))
                else:
                    n_decimals = 0
                this_tol = 10 ** (-(n_decimals + 2))
                if this_tol &gt; 1e-5:
                    this_tol = 1e-5
            else:
                this_tol = tol

            # Solve for T at each pressure
            out = unicurve(
                solve=&#34;T&#34;,
                logK=this_logK,
                species=species,
                state=state,
                coeff=coeff,
                pressures=list(pressures),
                minT=Trange[0],
                maxT=Trange[1],
                IS=IS,
                tol=this_tol,
                show=show,
                messages=messages,
                plot_it=False  # Don&#39;t plot individual curves - univariant_TP makes its own plot
            )

            # Add to plot if we have valid data
            if plot_it and not out.out[&#39;T&#39;].isnull().all():
                fig.add_trace(go.Scatter(
                    x=out.out[&#39;T&#39;],
                    y=out.out[&#39;P&#39;],
                    mode=line_type,
                    name=f&#34;logK={this_logK}&#34;,
                    text=[f&#34;logK={this_logK}&#34; for _ in range(len(out.out[&#39;T&#39;]))],
                    hovertemplate=&#39;%{text}&lt;br&gt;T, °C=%{x:.2f}&lt;br&gt;P, bar=%{y:.2f}&lt;extra&gt;&lt;/extra&gt;&#39;,
                ))
            elif out.out[&#39;T&#39;].isnull().all():
                if messages:
                    print(f&#34;Could not find any T or P values in this range that correspond to a logK value of {this_logK}&#34;)

            output.append(out)

    # Generate plot title if not specified
    if plot_it:
        if title is None and len(output) &gt; 0 and output[0].reaction is not None:
            react_grid = output[0].reaction

            # Build reaction string
            reactants = []
            products = []
            for i, row in react_grid.iterrows():
                coeff_val = row[&#39;coeff&#39;]
                name = row[&#39;name&#39;] if row[&#39;name&#39;] != &#39;water&#39; else &#39;H2O&#39;

                if coeff_val &lt; 0:
                    coeff_str = str(int(-coeff_val)) if -coeff_val != 1 else &#34;&#34;
                    reactants.append(f&#34;{coeff_str} {name}&#34;.strip())
                elif coeff_val &gt; 0:
                    coeff_str = str(int(coeff_val)) if coeff_val != 1 else &#34;&#34;
                    products.append(f&#34;{coeff_str} {name}&#34;.strip())

            title = &#34; + &#34;.join(reactants) + &#34; = &#34; + &#34; + &#34;.join(products)

        # Update layout
        fig.update_layout(
            template=&#34;simple_white&#34;,
            title=str(title) if title else &#34;&#34;,
            xaxis_title=&#34;T, °C&#34;,
            yaxis_title=&#34;P, bar&#34;,
            width=width,
            height=height,
            hoverlabel=dict(bgcolor=&#34;white&#34;),
        )

        # Set axis limits if specified
        if xlim is not None:
            fig.update_xaxes(range=xlim)
        if ylim is not None:
            fig.update_yaxes(range=ylim)

        # Configure plot controls
        config = {
            &#39;displaylogo&#39;: False,
            &#39;modeBarButtonsToRemove&#39;: [&#39;resetScale2d&#39;, &#39;toggleSpikelines&#39;],
            &#39;toImageButtonOptions&#39;: {
                &#39;format&#39;: save_format,
                &#39;filename&#39;: save_as if save_as else &#39;univariant_TP&#39;,
                &#39;height&#39;: height,
                &#39;width&#39;: width,
                &#39;scale&#39;: save_scale,
            },
        }

        # Save plot if requested
        if save_as is not None:
            full_filename = f&#34;{save_as}.{save_format}&#34;
            if save_format == &#39;html&#39;:
                fig.write_html(full_filename)
            else:
                fig.write_image(full_filename, format=save_format,
                              width=width, height=height, scale=save_scale)
            if messages:
                print(f&#34;Plot saved to {full_filename}&#34;)

        # Display plot
        fig.show(config=config)

        # Store figure in all result objects
        for out in output:
            out.fig = fig

    return output</code></pre>
</details>
<div class="desc"><p>Solve for temperatures and pressures of equilibration for given logK value(s)
and produce an interactive T-P diagram.</p>
<p>This function calculates univariant curves in temperature-pressure (T-P) space
for one or more logK values. For each pressure in a range, it solves for the
temperature where the reaction achieves the target logK. The resulting curves
show phase boundaries or equilibrium conditions in T-P space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>logK</code></strong> :&ensp;<code>float, int,</code> or <code>list</code></dt>
<dd>Logarithm (base 10) of equilibrium constant(s). Multiple values produce
multiple curves on the same plot.</dd>
<dt><strong><code>species</code></strong> :&ensp;<code>str, int,</code> or <code>list</code> of <code>str</code> or <code>int</code></dt>
<dd>Name, formula, or database index of species involved in the reaction</dd>
<dt><strong><code>coeff</code></strong> :&ensp;<code>int, float,</code> or <code>list</code></dt>
<dd>Reaction stoichiometric coefficients (negative for reactants, positive for products)</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code></dt>
<dd>Physical state(s) of species: "aq", "cr", "gas", "liq"</dd>
<dt><strong><code>Trange</code></strong> :&ensp;<code>list</code> of <code>two floats</code></dt>
<dd>[min, max] temperature range (°C) to search for solutions</dd>
<dt><strong><code>Prange</code></strong> :&ensp;<code>list</code> of <code>two floats</code></dt>
<dd>[min, max] pressure range (bar) to calculate along</dd>
<dt><strong><code>IS</code></strong> :&ensp;<code>float</code>, default <code>0</code></dt>
<dd>Ionic strength for activity corrections (mol/kg)</dd>
<dt><strong><code>xlim</code></strong> :&ensp;<code>list</code> of <code>two floats</code>, optional</dt>
<dd>[min, max] range for x-axis (temperature) in plot</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> of <code>two floats</code>, optional</dt>
<dd>[min, max] range for y-axis (pressure) in plot</dd>
<dt><strong><code>line_type</code></strong> :&ensp;<code>str</code>, default <code>"markers+lines"</code></dt>
<dd>Plotly line type: "markers+lines", "markers", or "lines"</dd>
<dt><strong><code>tol</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Convergence tolerance. Default: 1/(10^(n+2)) where n is decimal places in logK</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Plot title. Default: auto-generated from reaction</dd>
<dt><strong><code>res</code></strong> :&ensp;<code>int</code>, default <code>10</code></dt>
<dd>Number of pressure points to calculate along the curve</dd>
<dt><strong><code>width</code></strong> :&ensp;<code>int</code>, default <code>500</code></dt>
<dd>Plot width in pixels</dd>
<dt><strong><code>height</code></strong> :&ensp;<code>int</code>, default <code>400</code></dt>
<dd>Plot height in pixels</dd>
<dt><strong><code>save_as</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Filename to save plot (without extension)</dd>
<dt><strong><code>save_format</code></strong> :&ensp;<code>str</code>, default <code>"png"</code></dt>
<dd>Save format: "png", "jpg", "jpeg", "webp", "svg", "pdf", "html"</dd>
<dt><strong><code>save_scale</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Scale factor for saved plot</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Display subcrt result tables</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Print informational messages</dd>
<dt><strong><code>parallel</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Use parallel processing across multiple logK values for faster computation.
Utilizes multiple CPU cores when processing multiple logK curves.</dd>
<dt><strong><code>plot_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Display the plot</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>UnivariantResult</code></dt>
<dd>List of UnivariantResult objects, one for each logK value.
Each contains reaction information and T-P curve data.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pychnosz import univariant_TP, reset
&gt;&gt;&gt; reset()
&gt;&gt;&gt;
&gt;&gt;&gt; # Calcite-aragonite phase boundary
&gt;&gt;&gt; result = univariant_TP(
...     logK=0,
...     species=[&quot;calcite&quot;, &quot;aragonite&quot;],
...     state=[&quot;cr&quot;, &quot;cr&quot;],
...     coeff=[-1, 1],
...     Trange=[0, 700],
...     Prange=[2000, 16000]
... )
&gt;&gt;&gt;
&gt;&gt;&gt; # Multiple curves for K-feldspar stability
&gt;&gt;&gt; result = univariant_TP(
...     logK=[-8, -6, -4, -2],
...     species=[&quot;K-feldspar&quot;, &quot;kaolinite&quot;, &quot;H2O&quot;, &quot;SiO2&quot;, &quot;muscovite&quot;],
...     state=[&quot;cr&quot;, &quot;cr&quot;, &quot;liq&quot;, &quot;aq&quot;, &quot;cr&quot;],
...     coeff=[-1, -1, 1, 2, 1],
...     Trange=[0, 350],
...     Prange=[1, 5000],
...     res=20
... )
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function creates T-P diagrams by:
1. Generating a range of pressures from Prange[0] to Prange[1]
2. For each pressure, solving for T where logK matches the target
3. Plotting the resulting T-P points as a curve</p>
<p>For multiple logK values, each curve represents a different equilibrium
condition. This is useful for:
- Phase diagrams (e.g., mineral stability fields)
- Isopleths (lines of constant logK)
- Reaction boundaries</p>
<p>Requires plotly for interactive plotting. If plotly is not installed,
set plot_it=False to just return the data without plotting.</p>
<h2 id="references">References</h2>
<p>Based on univariant_TP from pyCHNOSZ by Grayson Boyer</p></div>
</dd>
<dt id="pychnosz.water"><code class="name flex">
<span>def <span class="ident">water</span></span>(<span>property: str | List[str] | None = None,<br>T: float | numpy.ndarray | List[float] = 298.15,<br>P: float | List[float] | numpy.ndarray | str = 1.0,<br>Psat_floor: float | None = 1.0,<br>model: str | None = None,<br>messages: bool = True) ‑> str | float | numpy.ndarray | Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def water(property: Optional[Union[str, List[str]]] = None,
          T: Union[float, np.ndarray, List[float]] = 298.15,
          P: Union[float, np.ndarray, List[float], str] = 1.0,
          Psat_floor: Union[float, None] = 1.0,
          model: Optional[str] = None,
          messages: bool = True) -&gt; Union[str, float, np.ndarray, Dict[str, Any]]:
    &#34;&#34;&#34;
    Calculate thermodynamic and electrostatic properties of liquid H2O.
    
    This is the main water function that provides the same interface as the
    R CHNOSZ water() function, with support for multiple water models.
    
    Parameters
    ----------
    property : str, list of str, or None
        Properties to calculate. If None, returns current water model.
        If water model name (SUPCRT92, IAPWS95, DEW), sets the water model.
        Available properties depend on the water model used.
    T : float or array-like
        Temperature in Kelvin
    P : float, array-like, or &#34;Psat&#34;
        Pressure in bar, or &#34;Psat&#34; for saturation pressure
    Psat_floor : float or None
        Minimum pressure floor for Psat calculations (SUPCRT92 only)
    model : str, optional
        Override the default water model for this calculation
    messages : bool, default True
        Whether to print informational messages

    Returns
    -------
    str, float, array, or dict
        Current water model name, single property value, array of values,
        or dictionary with calculated properties
        
    Examples
    --------
    &gt;&gt;&gt; import pychnosz
    &gt;&gt;&gt; pychnosz.reset()
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Get current water model
    &gt;&gt;&gt; model = pychnosz.water()
    &gt;&gt;&gt; print(model)  # &#39;SUPCRT92&#39;
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Set water model
    &gt;&gt;&gt; old_model = pychnosz.water(&#39;IAPWS95&#39;)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Calculate single property
    &gt;&gt;&gt; density = pychnosz.water(&#39;rho&#39;, T=298.15, P=1.0)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Calculate multiple properties
    &gt;&gt;&gt; props = pychnosz.water([&#39;rho&#39;, &#39;epsilon&#39;], T=298.15, P=1.0)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Temperature array
    &gt;&gt;&gt; temps = np.array([273.15, 298.15, 373.15])
    &gt;&gt;&gt; densities = pychnosz.water(&#39;rho&#39;, T=temps, P=1.0)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; # Saturation pressure
    &gt;&gt;&gt; psat = pychnosz.water(&#39;Psat&#39;, T=373.15)
    &#34;&#34;&#34;
    
    # Get thermo system
    thermo_system = thermo()

    # Ensure thermo is initialized before accessing/setting options
    # This prevents reset() from clearing options later
    if not thermo_system.is_initialized():
        thermo_system.reset(messages=False)

    # Case 1: Query current water model
    if property is None:
        return thermo_system.get_option(&#39;water&#39;, &#39;SUPCRT92&#39;)

    # Case 2: Set water model
    if isinstance(property, str) and property.upper() in [&#39;SUPCRT92&#39;, &#39;SUPCRT&#39;, &#39;IAPWS95&#39;, &#39;IAPWS&#39;, &#39;DEW&#39;]:
        old_model = thermo_system.get_option(&#39;water&#39;, &#39;SUPCRT92&#39;)

        # Normalize model name
        if property.upper() in [&#39;SUPCRT92&#39;, &#39;SUPCRT&#39;]:
            new_model = &#39;SUPCRT92&#39;
        elif property.upper() in [&#39;IAPWS95&#39;, &#39;IAPWS&#39;]:
            new_model = &#39;IAPWS95&#39;
        elif property.upper() == &#39;DEW&#39;:
            new_model = &#39;DEW&#39;

        thermo_system.set_option(&#39;water&#39;, new_model)
        if messages:
            print(f&#34;water: setting water model to {new_model}&#34;)
        return  # Return None instead of the old model
    
    # Case 3: Calculate properties
    # Determine which model to use
    if model is not None:
        water_model = model.upper()
    else:
        water_model = thermo_system.get_option(&#39;water&#39;, &#39;SUPCRT92&#39;).upper()
    
    # Normalize model names
    if water_model in [&#39;SUPCRT92&#39;, &#39;SUPCRT&#39;]:
        water_model = &#39;SUPCRT92&#39;
    elif water_model in [&#39;IAPWS95&#39;, &#39;IAPWS&#39;]:
        water_model = &#39;IAPWS95&#39;
    elif water_model == &#39;DEW&#39;:
        water_model = &#39;DEW&#39;
    else:
        warnings.warn(f&#34;Unknown water model &#39;{water_model}&#39;, using SUPCRT92&#34;)
        water_model = &#39;SUPCRT92&#39;
    
    # Convert inputs
    T = np.atleast_1d(np.asarray(T, dtype=float))
    
    if isinstance(P, str):
        P_input = P
    else:
        P_input = np.atleast_1d(np.asarray(P, dtype=float))
        # Make T and P same length
        if len(P_input) &lt; len(T):
            P_input = np.resize(P_input, len(T))
        elif len(T) &lt; len(P_input):
            T = np.resize(T, len(P_input))
    
    # Call appropriate water model
    try:
        if water_model == &#39;SUPCRT92&#39;:
            result = _call_supcrt92(property, T, P_input, Psat_floor)
        elif water_model == &#39;IAPWS95&#39;:
            result = _call_iapws95(property, T, P_input, Psat_floor)  
        elif water_model == &#39;DEW&#39;:
            result = _call_dew(property, T, P_input)
        else:
            raise ValueError(f&#34;Unsupported water model: {water_model}&#34;)
            
    except Exception as e:
        raise WaterModelError(f&#34;Error calculating water properties with {water_model} model: {e}&#34;)
    
    # Apply Psat rounding to match R CHNOSZ behavior
    # Round Psat values to 4 decimal places (round up to ensure liquid phase)
    result = _apply_psat_rounding(result, property)
    
    return result</code></pre>
</details>
<div class="desc"><p>Calculate thermodynamic and electrostatic properties of liquid H2O.</p>
<p>This is the main water function that provides the same interface as the
R CHNOSZ water() function, with support for multiple water models.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>str, list</code> of <code>str,</code> or <code>None</code></dt>
<dd>Properties to calculate. If None, returns current water model.
If water model name (SUPCRT92, IAPWS95, DEW), sets the water model.
Available properties depend on the water model used.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>float</code> or <code>array-like</code></dt>
<dd>Temperature in Kelvin</dd>
<dt><strong><code>P</code></strong> :&ensp;<code>float, array-like,</code> or <code>"Psat"</code></dt>
<dd>Pressure in bar, or "Psat" for saturation pressure</dd>
<dt><strong><code>Psat_floor</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>Minimum pressure floor for Psat calculations (SUPCRT92 only)</dd>
<dt><strong><code>model</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Override the default water model for this calculation</dd>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str, float, array,</code> or <code>dict</code></dt>
<dd>Current water model name, single property value, array of values,
or dictionary with calculated properties</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import pychnosz
&gt;&gt;&gt; pychnosz.reset()
&gt;&gt;&gt; 
&gt;&gt;&gt; # Get current water model
&gt;&gt;&gt; model = pychnosz.water()
&gt;&gt;&gt; print(model)  # 'SUPCRT92'
&gt;&gt;&gt; 
&gt;&gt;&gt; # Set water model
&gt;&gt;&gt; old_model = pychnosz.water('IAPWS95')
&gt;&gt;&gt; 
&gt;&gt;&gt; # Calculate single property
&gt;&gt;&gt; density = pychnosz.water('rho', T=298.15, P=1.0)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Calculate multiple properties
&gt;&gt;&gt; props = pychnosz.water(['rho', 'epsilon'], T=298.15, P=1.0)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Temperature array
&gt;&gt;&gt; temps = np.array([273.15, 298.15, 373.15])
&gt;&gt;&gt; densities = pychnosz.water('rho', T=temps, P=1.0)
&gt;&gt;&gt; 
&gt;&gt;&gt; # Saturation pressure
&gt;&gt;&gt; psat = pychnosz.water('Psat', T=373.15)
</code></pre></div>
</dd>
<dt id="pychnosz.water_lines"><code class="name flex">
<span>def <span class="ident">water_lines</span></span>(<span>eout: Dict[str, Any],<br>which: str | List[str] = ['oxidation', 'reduction'],<br>lty: str | int = 2,<br>lwd: float = 1,<br>col: str | None = None,<br>plot_it: bool = True,<br>messages: bool = True) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def water_lines(eout: Dict[str, Any],
                which: Union[str, List[str]] = [&#39;oxidation&#39;, &#39;reduction&#39;],
                lty: Union[int, str] = 2,
                lwd: float = 1,
                col: Optional[str] = None,
                plot_it: bool = True,
                messages: bool = True) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Draw water stability limits for Eh-pH, logfO2-pH, logfO2-T or Eh-T diagrams.

    This function adds lines showing the oxidation and reduction stability limits
    of water to diagrams. Above the oxidation line, water breaks down to O2.
    Below the reduction line, water breaks down to H2.

    Parameters
    ----------
    eout : dict
        Output from affinity(), equilibrate(), or diagram()
    which : str or list of str, default [&#39;oxidation&#39;, &#39;reduction&#39;]
        Which line(s) to draw: &#39;oxidation&#39;, &#39;reduction&#39;, or both
    lty : int or str, default 2
        Line style (matplotlib linestyle or numeric code)
    lwd : float, default 1
        Line width
    col : str, optional
        Line color (matplotlib color spec). If None, uses current foreground color
    plot_it : bool, default True
        Whether to plot the lines and display the figure. When True, the lines
        are added to the diagram and the figure is displayed (useful when the
        original diagram was created with plot_it=False). When False, only
        calculates and returns the water line coordinates without plotting.

    Returns
    -------
    dict
        Dictionary containing all keys from the input diagram (including &#39;fig&#39;, &#39;ax&#39;,
        &#39;plotvar&#39;, &#39;plotvals&#39;, &#39;names&#39;, &#39;predominant&#39;, etc. if present) plus the
        following water line specific keys:
        - xpoints: x-axis values
        - y_oxidation: y values for oxidation line (or None)
        - y_reduction: y values for reduction line (or None)
        - swapped: whether axes were swapped

    Examples
    --------
    &gt;&gt;&gt; # Add water lines to an existing displayed diagram
    &gt;&gt;&gt; basis([&#34;Fe+2&#34;, &#34;SO4-2&#34;, &#34;H2O&#34;, &#34;H+&#34;, &#34;e-&#34;], [0, math.log10(3), math.log10(0.75), 999, 999])
    &gt;&gt;&gt; species([&#34;rhomboclase&#34;, &#34;ferricopiapite&#34;, &#34;hydronium jarosite&#34;, &#34;goethite&#34;, &#34;melanterite&#34;, &#34;pyrite&#34;])
    &gt;&gt;&gt; a = affinity(pH=[-1, 4, 256], pe=[-5, 23, 256])
    &gt;&gt;&gt; d = diagram(a, main=&#34;Fe-S-O-H, after Majzlan et al., 2006&#34;)
    &gt;&gt;&gt; water_lines(d, lwd=2)

    &gt;&gt;&gt; # Add water lines and display when diagram was created with plot_it=False
    &gt;&gt;&gt; d = diagram(a, main=&#34;Fe-S-O-H&#34;, plot_it=False)
    &gt;&gt;&gt; water_lines(d, lwd=2)  # This will display the figure with water lines

    Notes
    -----
    This function only works on diagrams with a redox variable (Eh, pe, O2, or H2)
    on one axis and pH, T, P, or another non-redox variable on the other axis.
    For 1-D diagrams, vertical lines are drawn.
    &#34;&#34;&#34;

    # Import here to avoid circular imports
    from ..utils.units import convert, envert
    from ..core.subcrt import subcrt

    # Create a deep copy of the input to preserve all diagram information
    # This allows us to return all the original keys plus water line data
    result = copy_plot(eout)

    # Detect if this is a Plotly figure (interactive diagram)
    is_plotly = False
    if &#39;fig&#39; in result and result[&#39;fig&#39;] is not None:
        is_plotly = hasattr(result[&#39;fig&#39;], &#39;add_trace&#39;) and hasattr(result[&#39;fig&#39;], &#39;update_layout&#39;)

    # Ensure which is a list
    if isinstance(which, str):
        which = [which]

    # Get number of variables used in affinity()
    nvar1 = len(result[&#39;vars&#39;])

    # Determine actual number of variables from array dimensions
    # Check both loga.equil (equilibrate output) and values (affinity output)
    if &#39;loga_equil&#39; in result or &#39;loga.equil&#39; in result:
        loga_key = &#39;loga_equil&#39; if &#39;loga_equil&#39; in result else &#39;loga.equil&#39;
        first_val = result[loga_key][0] if isinstance(result[loga_key], list) else list(result[loga_key].values())[0]
    else:
        first_val = list(result[&#39;values&#39;].values())[0] if isinstance(result[&#39;values&#39;], dict) else result[&#39;values&#39;][0]

    if hasattr(first_val, &#39;shape&#39;):
        dim = first_val.shape
    elif hasattr(first_val, &#39;__len__&#39;):
        dim = (len(first_val),)
    else:
        dim = ()

    nvar2 = len(dim)

    # We only work on diagrams with 1 or 2 variables
    if nvar1 not in [1, 2] or nvar2 not in [1, 2]:
        result.update({&#39;xpoints&#39;: None, &#39;y_oxidation&#39;: None, &#39;y_reduction&#39;: None, &#39;swapped&#39;: False})
        return result

    # Get variables from result
    vars_list = result[&#39;vars&#39;].copy()

    # If needed, swap axes so redox variable is on y-axis
    # Also do this for 1-D diagrams
    if len(vars_list) == 1:
        vars_list.append(&#39;nothing&#39;)

    swapped = False
    if vars_list[1] in [&#39;T&#39;, &#39;P&#39;, &#39;nothing&#39;]:
        vars_list = list(reversed(vars_list))
        vals_dict = {vars_list[0]: result[&#39;vals&#39;][vars_list[0]]} if vars_list[0] != &#39;nothing&#39; else {}
        if len(result[&#39;vars&#39;]) &gt; 1:
            vals_dict[vars_list[1]] = result[&#39;vals&#39;][vars_list[1]]
        swapped = True
    else:
        vals_dict = result[&#39;vals&#39;]

    xaxis = vars_list[0]
    yaxis = vars_list[1]
    xpoints = np.asarray(vals_dict[xaxis]) if xaxis in vals_dict else np.array([0])

    # Make xaxis &#34;nothing&#34; if it is not pH, T, or P
    # (so that horizontal water lines can be drawn for any non-redox variable on the x-axis)
    if xaxis not in [&#39;pH&#39;, &#39;T&#39;, &#39;P&#39;]:
        xaxis = &#39;nothing&#39;

    # T and P are constants unless they are plotted on one of the axes
    T = result[&#39;T&#39;]
    if vars_list[0] == &#39;T&#39;:
        T = envert(xpoints, &#39;K&#39;)
    P = result[&#39;P&#39;]
    if vars_list[0] == &#39;P&#39;:
        P = envert(xpoints, &#39;bar&#39;)

    # Handle the case where P is &#34;Psat&#34; - keep it as is for subcrt
    # (subcrt knows how to handle &#34;Psat&#34;)

    # logaH2O is 0 unless given in result[&#39;basis&#39;]
    basis_df = result[&#39;basis&#39;]
    if &#39;H2O&#39; in basis_df.index:
        logaH2O = float(basis_df.loc[&#39;H2O&#39;, &#39;logact&#39;])
    else:
        logaH2O = 0

    # pH is 7 unless given in eout[&#39;basis&#39;] or plotted on one of the axes
    if vars_list[0] == &#39;pH&#39;:
        pH = xpoints
    elif &#39;H+&#39; in basis_df.index:
        minuspH = basis_df.loc[&#39;H+&#39;, &#39;logact&#39;]
        # Special treatment for non-numeric value (happens when a buffer is used)
        try:
            pH = -float(minuspH)
        except (ValueError, TypeError):
            pH = np.nan
    else:
        pH = 7

    # O2 state is gas unless given in eout[&#39;basis&#39;]
    O2state = &#39;gas&#39;
    if &#39;O2&#39; in basis_df.index:
        O2state = basis_df.loc[&#39;O2&#39;, &#39;state&#39;]

    # H2 state is gas unless given in eout[&#39;basis&#39;]
    H2state = &#39;gas&#39;
    if &#39;H2&#39; in basis_df.index:
        H2state = basis_df.loc[&#39;H2&#39;, &#39;state&#39;]

    # Where the calculated values will go
    y_oxidation = None
    y_reduction = None

    if xaxis in [&#39;pH&#39;, &#39;T&#39;, &#39;P&#39;, &#39;nothing&#39;] and yaxis in [&#39;Eh&#39;, &#39;pe&#39;, &#39;O2&#39;, &#39;H2&#39;]:
        # Eh/pe/logfO2/logaO2/logfH2/logaH2 vs pH/T/P

        # Reduction line (H2O + e- = 1/2 H2 + OH-)
        if &#39;reduction&#39; in which:
            logfH2 = logaH2O  # usually 0

            if yaxis == &#39;H2&#39;:
                # Calculate equilibrium constant for gas-aqueous conversion if needed
                logK = subcrt([&#39;H2&#39;, &#39;H2&#39;], [-1, 1], [&#39;gas&#39;, H2state], T=T, P=P, convert=False, messages=messages, show=False).out[&#39;logK&#39;]
                # This is logfH2 if H2state == &#34;gas&#34;, or logaH2 if H2state == &#34;aq&#34;
                logfH2 = logfH2 + logK
                # Broadcast to match xpoints length
                if isinstance(logfH2, (int, float)):
                    y_reduction = np.full_like(xpoints, logfH2)
                else:
                    logfH2_val = float(logfH2.iloc[0]) if hasattr(logfH2, &#39;iloc&#39;) else float(logfH2[0])
                    y_reduction = np.full_like(xpoints, logfH2_val)
            else:
                # Calculate logfO2 from H2O = 1/2 O2 + H2
                logK = subcrt([&#39;H2O&#39;, &#39;O2&#39;, &#39;H2&#39;], [-1, 0.5, 1], [&#39;liq&#39;, O2state, &#39;gas&#39;], T=T, P=P, convert=False, messages=messages, show=False).out[&#39;logK&#39;]
                # This is logfO2 if O2state == &#34;gas&#34;, or logaO2 if O2state == &#34;aq&#34;
                logfO2 = 2 * (logK - logfH2 + logaH2O)

                if yaxis == &#39;O2&#39;:
                    # Broadcast to match xpoints length
                    if isinstance(logfO2, (int, float)):
                        y_reduction = np.full_like(xpoints, logfO2)
                    else:
                        logfO2_val = float(logfO2.iloc[0]) if hasattr(logfO2, &#39;iloc&#39;) else float(logfO2[0])
                        y_reduction = np.full_like(xpoints, logfO2_val)
                elif yaxis == &#39;Eh&#39;:
                    y_reduction = convert(logfO2, &#39;E0&#39;, T=T, P=P, pH=pH, logaH2O=logaH2O, messages=messages)
                elif yaxis == &#39;pe&#39;:
                    Eh_val = convert(logfO2, &#39;E0&#39;, T=T, P=P, pH=pH, logaH2O=logaH2O, messages=messages)
                    y_reduction = convert(Eh_val, &#39;pe&#39;, T=T, messages=messages)

        # Oxidation line (H2O = 1/2 O2 + 2H+ + 2e-)
        if &#39;oxidation&#39; in which:
            logfO2 = logaH2O  # usually 0

            if yaxis == &#39;H2&#39;:
                # Calculate logfH2 from H2O = 1/2 O2 + H2
                logK = subcrt([&#39;H2O&#39;, &#39;O2&#39;, &#39;H2&#39;], [-1, 0.5, 1], [&#39;liq&#39;, &#39;gas&#39;, H2state], T=T, P=P, convert=False, messages=messages, show=False).out[&#39;logK&#39;]
                # This is logfH2 if H2state == &#34;gas&#34;, or logaH2 if H2state == &#34;aq&#34;
                logfH2 = logK - 0.5*logfO2 + logaH2O
                # Broadcast to match xpoints length
                if isinstance(logfH2, (int, float)):
                    y_oxidation = np.full_like(xpoints, logfH2)
                else:
                    logfH2_val = float(logfH2.iloc[0]) if hasattr(logfH2, &#39;iloc&#39;) else float(logfH2[0])
                    y_oxidation = np.full_like(xpoints, logfH2_val)
            else:
                # Calculate equilibrium constant for gas-aqueous conversion if needed
                logK = subcrt([&#39;O2&#39;, &#39;O2&#39;], [-1, 1], [&#39;gas&#39;, O2state], T=T, P=P, convert=False, messages=messages, show=False).out[&#39;logK&#39;]
                # This is logfO2 if O2state == &#34;gas&#34;, or logaO2 if O2state == &#34;aq&#34;
                logfO2 = logfO2 + logK

                if yaxis == &#39;O2&#39;:
                    # Broadcast to match xpoints length
                    if isinstance(logfO2, (int, float)):
                        y_oxidation = np.full_like(xpoints, logfO2)
                    else:
                        logfO2_val = float(logfO2.iloc[0]) if hasattr(logfO2, &#39;iloc&#39;) else float(logfO2[0])
                        y_oxidation = np.full_like(xpoints, logfO2_val)
                elif yaxis == &#39;Eh&#39;:
                    y_oxidation = convert(logfO2, &#39;E0&#39;, T=T, P=P, pH=pH, logaH2O=logaH2O, messages=messages)
                elif yaxis == &#39;pe&#39;:
                    Eh_val = convert(logfO2, &#39;E0&#39;, T=T, P=P, pH=pH, logaH2O=logaH2O, messages=messages)
                    y_oxidation = convert(Eh_val, &#39;pe&#39;, T=T, messages=messages)

    else:
        # Invalid axis combination
        result.update({&#39;xpoints&#39;: xpoints, &#39;y_oxidation&#39;: None, &#39;y_reduction&#39;: None, &#39;swapped&#39;: swapped})
        return result

    # Route to Plotly or matplotlib implementation
    if is_plotly:
        return _water_lines_plotly(result, xpoints, y_oxidation, y_reduction, swapped,
                                  lty, lwd, col, plot_it)

    # Matplotlib implementation
    # Only draw water lines if eout already has an axes (meaning it&#39;s from a diagram)
    # If no axes, this is being called just for calculation (e.g., from within diagram())
    if &#39;ax&#39; not in eout or eout[&#39;ax&#39;] is None:
        # No axes to plot on - just return the calculated values
        result.update({&#39;xpoints&#39;: xpoints, &#39;y_oxidation&#39;: y_oxidation, &#39;y_reduction&#39;: y_reduction, &#39;swapped&#39;: swapped})
        return result

    # Use the axes from result
    ax = result[&#39;ax&#39;]

    # First, shade the water-unstable regions with gray
    # This creates the same effect as R&#39;s fill.NA for H2O.predominant
    if y_oxidation is not None and y_reduction is not None:
        from matplotlib.colors import ListedColormap

        # Get current axis limits to create shading
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()

        # Create a high-resolution mesh for smooth shading
        n_points = 500
        if swapped:
            # When swapped, xpoints is on the y-axis
            y_mesh = np.linspace(ylim[0], ylim[1], n_points)
            x_mesh = np.linspace(xlim[0], xlim[1], n_points)
            X, Y = np.meshgrid(x_mesh, y_mesh)

            # For each y-value, determine if it&#39;s in water-unstable region
            # Interpolate oxidation and reduction values to the mesh
            y_ox_interp = np.interp(y_mesh, xpoints, y_oxidation)
            y_red_interp = np.interp(y_mesh, xpoints, y_reduction)

            # Create mask: unstable where x &lt; min or x &gt; max
            unstable = np.zeros_like(X, dtype=bool)
            for i in range(n_points):
                ymin = min(y_ox_interp[i], y_red_interp[i])
                ymax = max(y_ox_interp[i], y_red_interp[i])
                unstable[i, :] = (X[i, :] &lt; ymin) | (X[i, :] &gt; ymax)
        else:
            # Normal: xpoints on x-axis, y values on y-axis
            x_mesh = np.linspace(xlim[0], xlim[1], n_points)
            y_mesh = np.linspace(ylim[0], ylim[1], n_points)
            X, Y = np.meshgrid(x_mesh, y_mesh)

            # Interpolate oxidation and reduction values to the mesh
            y_ox_interp = np.interp(x_mesh, xpoints, y_oxidation)
            y_red_interp = np.interp(x_mesh, xpoints, y_reduction)

            # Create mask: unstable where y &lt; min or y &gt; max
            unstable = np.zeros_like(Y, dtype=bool)
            for i in range(n_points):
                ymin = min(y_ox_interp[i], y_red_interp[i])
                ymax = max(y_ox_interp[i], y_red_interp[i])
                unstable[:, i] = (Y[:, i] &lt; ymin) | (Y[:, i] &gt; ymax)

        # Create masked array for unstable regions
        import numpy.ma as ma
        unstable_mask = ma.masked_where(~unstable, np.ones_like(X))

        # Draw the shading with gray (matching R&#39;s gray80 = 0.8)
        fill_na_cmap = ListedColormap([&#39;0.8&#39;])
        extent = [xlim[0], xlim[1], ylim[0], ylim[1]]
        ax.imshow(unstable_mask, aspect=&#39;auto&#39;, origin=&#39;lower&#39;,
                 extent=extent, interpolation=&#39;nearest&#39;,
                 cmap=fill_na_cmap, vmin=0, vmax=1, zorder=1)

    # Set line color
    if col is None:
        col = &#39;black&#39;

    # Convert numeric line style to matplotlib style
    lty_map = {1: &#39;-&#39;, 2: &#39;--&#39;, 3: &#39;-.&#39;, 4: &#39;:&#39;, 5: &#39;-&#39;, 6: &#39;--&#39;}
    if isinstance(lty, int):
        lty = lty_map.get(lty, &#39;--&#39;)

    if swapped:
        if nvar1 == 1 or nvar2 == 2:
            # Add vertical lines on 1-D diagram
            if y_oxidation is not None and len(y_oxidation) &gt; 0:
                ax.axvline(x=y_oxidation[0], linestyle=lty, linewidth=lwd, color=col)
            if y_reduction is not None and len(y_reduction) &gt; 0:
                ax.axvline(x=y_reduction[0], linestyle=lty, linewidth=lwd, color=col)
        else:
            # xpoints above is really the ypoints
            if y_oxidation is not None:
                ax.plot(y_oxidation, xpoints, linestyle=lty, linewidth=lwd, color=col)
            if y_reduction is not None:
                ax.plot(y_reduction, xpoints, linestyle=lty, linewidth=lwd, color=col)
    else:
        if y_oxidation is not None:
            ax.plot(xpoints, y_oxidation, linestyle=lty, linewidth=lwd, color=col)
        if y_reduction is not None:
            ax.plot(xpoints, y_reduction, linestyle=lty, linewidth=lwd, color=col)

    # Update the figure and axes references in result to reflect the water lines
    fig = ax.get_figure()
    result[&#39;fig&#39;] = fig
    result[&#39;ax&#39;] = ax

    # Display the figure if plot_it=True
    # This allows water_lines() to display a figure that was created with plot_it=False
    if plot_it and fig is not None:
        try:
            from IPython.display import display
            display(fig)
        except (ImportError, NameError):
            # Not in IPython/Jupyter, matplotlib will handle display
            pass

    # Update result with water line data and return
    result.update({&#39;xpoints&#39;: xpoints, &#39;y_oxidation&#39;: y_oxidation, &#39;y_reduction&#39;: y_reduction, &#39;swapped&#39;: swapped})
    return result</code></pre>
</details>
<div class="desc"><p>Draw water stability limits for Eh-pH, logfO2-pH, logfO2-T or Eh-T diagrams.</p>
<p>This function adds lines showing the oxidation and reduction stability limits
of water to diagrams. Above the oxidation line, water breaks down to O2.
Below the reduction line, water breaks down to H2.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>eout</code></strong> :&ensp;<code>dict</code></dt>
<dd>Output from affinity(), equilibrate(), or diagram()</dd>
<dt><strong><code>which</code></strong> :&ensp;<code>str</code> or <code>list</code> of <code>str</code>, default <code>['oxidation', 'reduction']</code></dt>
<dd>Which line(s) to draw: 'oxidation', 'reduction', or both</dd>
<dt><strong><code>lty</code></strong> :&ensp;<code>int</code> or <code>str</code>, default <code>2</code></dt>
<dd>Line style (matplotlib linestyle or numeric code)</dd>
<dt><strong><code>lwd</code></strong> :&ensp;<code>float</code>, default <code>1</code></dt>
<dd>Line width</dd>
<dt><strong><code>col</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Line color (matplotlib color spec). If None, uses current foreground color</dd>
<dt><strong><code>plot_it</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to plot the lines and display the figure. When True, the lines
are added to the diagram and the figure is displayed (useful when the
original diagram was created with plot_it=False). When False, only
calculates and returns the water line coordinates without plotting.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing all keys from the input diagram (including 'fig', 'ax',
'plotvar', 'plotvals', 'names', 'predominant', etc. if present) plus the
following water line specific keys:
- xpoints: x-axis values
- y_oxidation: y values for oxidation line (or None)
- y_reduction: y values for reduction line (or None)
- swapped: whether axes were swapped</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Add water lines to an existing displayed diagram
&gt;&gt;&gt; basis([&quot;Fe+2&quot;, &quot;SO4-2&quot;, &quot;H2O&quot;, &quot;H+&quot;, &quot;e-&quot;], [0, math.log10(3), math.log10(0.75), 999, 999])
&gt;&gt;&gt; species([&quot;rhomboclase&quot;, &quot;ferricopiapite&quot;, &quot;hydronium jarosite&quot;, &quot;goethite&quot;, &quot;melanterite&quot;, &quot;pyrite&quot;])
&gt;&gt;&gt; a = affinity(pH=[-1, 4, 256], pe=[-5, 23, 256])
&gt;&gt;&gt; d = diagram(a, main=&quot;Fe-S-O-H, after Majzlan et al., 2006&quot;)
&gt;&gt;&gt; water_lines(d, lwd=2)
</code></pre>
<pre><code class="language-python-repl">&gt;&gt;&gt; # Add water lines and display when diagram was created with plot_it=False
&gt;&gt;&gt; d = diagram(a, main=&quot;Fe-S-O-H&quot;, plot_it=False)
&gt;&gt;&gt; water_lines(d, lwd=2)  # This will display the figure with water lines
</code></pre>
<h2 id="notes">Notes</h2>
<p>This function only works on diagrams with a redox variable (Eh, pe, O2, or H2)
on one axis and pH, T, P, or another non-redox variable on the other axis.
For 1-D diagrams, vertical lines are drawn.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pychnosz.ThermoSystem"><code class="flex name class">
<span>class <span class="ident">ThermoSystem</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThermoSystem:
    &#34;&#34;&#34;
    Global thermodynamic system manager for CHNOSZ.
    
    This class manages the thermodynamic database, basis species, 
    formed species, and calculation options - essentially serving
    as the global state container for all CHNOSZ calculations.
    &#34;&#34;&#34;
    
    def __init__(self):
        &#34;&#34;&#34;Initialize the thermodynamic system.&#34;&#34;&#34;
        self._data_loader = DataLoader()
        self._obigt_db = None
        self._initialized = False
        
        # Core data containers (similar to R thermo object)
        self.opt: Dict[str, Any] = {}
        self.element: Optional[pd.DataFrame] = None
        self.obigt: Optional[pd.DataFrame] = None
        self.refs: Optional[pd.DataFrame] = None
        self.Berman: Optional[pd.DataFrame] = None
        self.buffer: Optional[pd.DataFrame] = None
        self.protein: Optional[pd.DataFrame] = None
        self.groups: Optional[pd.DataFrame] = None
        self.stoich: Optional[np.ndarray] = None
        self.stoich_formulas: Optional[np.ndarray] = None
        self.bdot_acirc: Optional[Dict[str, float]] = None
        self.formula_ox: Optional[pd.DataFrame] = None
        
        # System state
        self.basis: Optional[pd.DataFrame] = None
        self.species: Optional[pd.DataFrame] = None
        
        # Options and parameters
        self.opar: Dict[str, Any] = {}
        
    def reset(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Initialize/reset the thermodynamic system.

        This is equivalent to reset() in the R version, loading all
        the thermodynamic data and initializing the system.

        Parameters
        ----------
        messages : bool, default True
            Whether to print informational messages
        &#34;&#34;&#34;
        try:
            # Load core data files
            self._load_options(messages)
            self._load_element_data(messages)
            self._load_berman_data(messages)
            self._load_buffer_data(messages)
            self._load_protein_data(messages)
            self._load_stoich_data(messages)
            self._load_bdot_data(messages)
            self._load_refs_data(messages)

            # Initialize OBIGT database
            self._obigt_db = OBIGTDatabase()
            self.obigt = self._obigt_db.get_combined_data()

            # Reset system state
            self.basis = None
            self.species = None
            self.opar = {}

            self._initialized = True
            if messages:
                print(&#39;reset: thermodynamic system initialized&#39;)

        except Exception as e:
            raise RuntimeError(f&#34;Failed to initialize thermodynamic system: {e}&#34;)
    
    def _load_options(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load default thermodynamic options.&#34;&#34;&#34;
        try:
            opt_file = self._data_loader.get_data_path() / &#34;thermo&#34; / &#34;opt.csv&#34;
            if opt_file.exists():
                df = pd.read_csv(opt_file)
                # Convert to dictionary format (first row contains values)
                self.opt = dict(zip(df.columns, df.iloc[0]))
            else:
                # Default options if file not found
                self.opt = {
                    &#39;E.units&#39;: &#39;J&#39;,
                    &#39;T.units&#39;: &#39;C&#39;,
                    &#39;P.units&#39;: &#39;bar&#39;,
                    &#39;state&#39;: &#39;aq&#39;,
                    &#39;water&#39;: &#39;SUPCRT92&#39;,
                    &#39;G.tol&#39;: 100,
                    &#39;Cp.tol&#39;: 1,
                    &#39;V.tol&#39;: 1,
                    &#39;varP&#39;: False,
                    &#39;IAPWS.sat&#39;: &#39;liquid&#39;,
                    &#39;paramin&#39;: 1000,
                    &#39;ideal.H&#39;: True,
                    &#39;ideal.e&#39;: True,
                    &#39;nonideal&#39;: &#39;Bdot&#39;,
                    &#39;Setchenow&#39;: &#39;bgamma0&#39;,
                    &#39;Berman&#39;: np.nan,
                    &#39;maxcores&#39;: 2,
                    &#39;ionize.aa&#39;: True
                }
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load options: {e}&#34;)
            # Fallback to hardcoded defaults with critical unit options
            self.opt = {
                &#39;E.units&#39;: &#39;J&#39;,
                &#39;T.units&#39;: &#39;C&#39;,
                &#39;P.units&#39;: &#39;bar&#39;,
                &#39;state&#39;: &#39;aq&#39;,
                &#39;water&#39;: &#39;SUPCRT92&#39;,
                &#39;G.tol&#39;: 100,
                &#39;Cp.tol&#39;: 1,
                &#39;V.tol&#39;: 1,
                &#39;varP&#39;: False,
                &#39;IAPWS.sat&#39;: &#39;liquid&#39;,
                &#39;paramin&#39;: 1000,
                &#39;ideal.H&#39;: True,
                &#39;ideal.e&#39;: True,
                &#39;nonideal&#39;: &#39;Bdot&#39;,
                &#39;Setchenow&#39;: &#39;bgamma0&#39;,
                &#39;Berman&#39;: np.nan,
                &#39;maxcores&#39;: 2,
                &#39;ionize.aa&#39;: True
            }
    
    def _load_element_data(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load element properties data.&#34;&#34;&#34;
        try:
            self.element = self._data_loader.load_elements()
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load element data: {e}&#34;)
            self.element = None
    
    def _load_berman_data(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load Berman mineral parameters from CSV files.&#34;&#34;&#34;
        try:
            # Get path to Berman directory
            berman_path = self._data_loader.data_path / &#34;Berman&#34;

            if not berman_path.exists():
                if messages:
                    print(f&#34;Warning: Berman directory not found: {berman_path}&#34;)
                self.Berman = None
                return

            # Find all CSV files in the directory
            csv_files = list(berman_path.glob(&#34;*.csv&#34;))

            if not csv_files:
                if messages:
                    print(f&#34;Warning: No CSV files found in {berman_path}&#34;)
                self.Berman = None
                return
            
            # Extract year from filename and sort in reverse chronological order (youngest first)
            # Following R logic: files &lt;- rev(files[order(sapply(strsplit(files, &#34;_&#34;), &#34;[&#34;, 2))])
            def extract_year(filepath):
                filename = filepath.name
                parts = filename.split(&#39;_&#39;)
                if len(parts) &gt;= 2:
                    year_part = parts[1].replace(&#39;.csv&#39;, &#39;&#39;)
                    try:
                        return int(year_part)
                    except ValueError:
                        return 0
                return 0
            
            # Sort files by year (youngest first)
            sorted_files = sorted(csv_files, key=extract_year, reverse=True)
            
            # Read parameters from each file
            berman_dfs = []
            for file_path in sorted_files:
                try:
                    df = pd.read_csv(file_path)
                    berman_dfs.append(df)
                except Exception as e:
                    print(f&#34;Warning: Could not read Berman file {file_path}: {e}&#34;)
            
            # Combine all data frames (equivalent to do.call(rbind, Berman))
            if berman_dfs:
                self.Berman = pd.concat(berman_dfs, ignore_index=True)
                # Ensure all numeric columns are properly typed
                numeric_cols = [&#39;GfPrTr&#39;, &#39;HfPrTr&#39;, &#39;SPrTr&#39;, &#39;VPrTr&#39;, &#39;k0&#39;, &#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;, &#39;k4&#39;, &#39;k5&#39;, &#39;k6&#39;,
                               &#39;v1&#39;, &#39;v2&#39;, &#39;v3&#39;, &#39;v4&#39;, &#39;Tlambda&#39;, &#39;Tref&#39;, &#39;dTdP&#39;, &#39;l1&#39;, &#39;l2&#39;, &#39;DtH&#39;, &#39;Tmax&#39;, &#39;Tmin&#39;,
                               &#39;d0&#39;, &#39;d1&#39;, &#39;d2&#39;, &#39;d3&#39;, &#39;d4&#39;, &#39;Vad&#39;]
                for col in numeric_cols:
                    if col in self.Berman.columns:
                        self.Berman[col] = pd.to_numeric(self.Berman[col], errors=&#39;coerce&#39;)
            else:
                self.Berman = None
                
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load Berman data: {e}&#34;)
            self.Berman = None

    def _load_buffer_data(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load buffer definitions.&#34;&#34;&#34;
        try:
            self.buffer = self._data_loader.load_buffers()
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load buffer data: {e}&#34;)
            self.buffer = None

    def _load_protein_data(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load protein composition data.&#34;&#34;&#34; 
        try:
            self.protein = self._data_loader.load_proteins()
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load protein data: {e}&#34;)
            self.protein = None

    def _load_stoich_data(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load stoichiometric matrix data.&#34;&#34;&#34;
        try:
            stoich_df = self._data_loader.load_stoich()
            if stoich_df is not None:
                # Extract formulas and convert to matrix
                self.stoich_formulas = stoich_df.iloc[:, 0].values
                self.stoich = stoich_df.iloc[:, 1:].values
            else:
                self.stoich_formulas = None
                self.stoich = None
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load stoichiometric data: {e}&#34;)
            self.stoich_formulas = None
            self.stoich = None

    def _load_bdot_data(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load B-dot activity coefficient parameters.&#34;&#34;&#34;
        try:
            bdot_file = self._data_loader.get_data_path() / &#34;thermo&#34; / &#34;Bdot_acirc.csv&#34;
            if bdot_file.exists():
                df = pd.read_csv(bdot_file)
                if len(df.columns) &gt;= 2:
                    self.bdot_acirc = dict(zip(df.iloc[:, 0], df.iloc[:, 1]))
                else:
                    self.bdot_acirc = {}
            else:
                self.bdot_acirc = {}
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load B-dot data: {e}&#34;)
            self.bdot_acirc = {}

    def _load_refs_data(self, messages: bool = True) -&gt; None:
        &#34;&#34;&#34;Load references data.&#34;&#34;&#34;
        try:
            self.refs = self._data_loader.load_refs()
        except Exception as e:
            if messages:
                print(f&#34;Warning: Could not load refs data: {e}&#34;)
            self.refs = None
    
    def is_initialized(self) -&gt; bool:
        &#34;&#34;&#34;Check if the thermodynamic system is initialized.&#34;&#34;&#34;
        return self._initialized
    
    def get_obigt_db(self) -&gt; OBIGTDatabase:
        &#34;&#34;&#34;Get the OBIGT database instance.&#34;&#34;&#34;
        if not self._initialized:
            self.reset()
        return self._obigt_db
    
    def get_option(self, key: str, default: Any = None) -&gt; Any:
        &#34;&#34;&#34;Get a thermodynamic option value.&#34;&#34;&#34;
        return self.opt.get(key, default)
    
    def set_option(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Set a thermodynamic option value.&#34;&#34;&#34;
        self.opt[key] = value
    
    def info(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Get information about the current thermodynamic system.&#34;&#34;&#34;
        if not self._initialized:
            return {&#34;status&#34;: &#34;Not initialized&#34;}
        
        info = {
            &#34;status&#34;: &#34;Initialized&#34;,
            &#34;obigt_species&#34;: len(self.obigt) if self.obigt is not None else 0,
            &#34;elements&#34;: len(self.element) if self.element is not None else 0,
            &#34;berman_minerals&#34;: len(self.Berman) if self.Berman is not None else 0,
            &#34;buffers&#34;: len(self.buffer) if self.buffer is not None else 0,
            &#34;proteins&#34;: len(self.protein) if self.protein is not None else 0,
            &#34;stoich_species&#34;: len(self.stoich_formulas) if self.stoich_formulas is not None else 0,
            &#34;basis_species&#34;: len(self.basis) if self.basis is not None else 0,
            &#34;formed_species&#34;: len(self.species) if self.species is not None else 0,
            &#34;current_options&#34;: dict(self.opt)
        }
        return info
    
    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;String representation of the thermodynamic system.&#34;&#34;&#34;
        if not self._initialized:
            return &#34;ThermoSystem(uninitialized)&#34;

        info = self.info()
        return (f&#34;ThermoSystem(&#34;
                f&#34;obigt={info[&#39;obigt_species&#39;]} species, &#34;
                f&#34;basis={info[&#39;basis_species&#39;]}, &#34;
                f&#34;formed={info[&#39;formed_species&#39;]})&#34;)

    # R-style uppercase property aliases for compatibility
    @property
    def OBIGT(self):
        &#34;&#34;&#34;Alias for obigt (R compatibility).&#34;&#34;&#34;
        # Auto-initialize if needed AND obigt is None (matches R behavior)
        if self.obigt is None and not self._initialized:
            self.reset(messages=True)
        return self.obigt

    @OBIGT.setter
    def OBIGT(self, value):
        &#34;&#34;&#34;Setter for OBIGT (R compatibility).&#34;&#34;&#34;
        _set_obigt_data(self, value)</code></pre>
</details>
<div class="desc"><p>Global thermodynamic system manager for CHNOSZ.</p>
<p>This class manages the thermodynamic database, basis species,
formed species, and calculation options - essentially serving
as the global state container for all CHNOSZ calculations.</p>
<p>Initialize the thermodynamic system.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="pychnosz.ThermoSystem.OBIGT"><code class="name">prop <span class="ident">OBIGT</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def OBIGT(self):
    &#34;&#34;&#34;Alias for obigt (R compatibility).&#34;&#34;&#34;
    # Auto-initialize if needed AND obigt is None (matches R behavior)
    if self.obigt is None and not self._initialized:
        self.reset(messages=True)
    return self.obigt</code></pre>
</details>
<div class="desc"><p>Alias for obigt (R compatibility).</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pychnosz.ThermoSystem.get_obigt_db"><code class="name flex">
<span>def <span class="ident">get_obigt_db</span></span>(<span>self) ‑> <a title="pychnosz.data.obigt.OBIGTDatabase" href="data/obigt.html#pychnosz.data.obigt.OBIGTDatabase">OBIGTDatabase</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_obigt_db(self) -&gt; OBIGTDatabase:
    &#34;&#34;&#34;Get the OBIGT database instance.&#34;&#34;&#34;
    if not self._initialized:
        self.reset()
    return self._obigt_db</code></pre>
</details>
<div class="desc"><p>Get the OBIGT database instance.</p></div>
</dd>
<dt id="pychnosz.ThermoSystem.get_option"><code class="name flex">
<span>def <span class="ident">get_option</span></span>(<span>self, key: str, default: Any = None) ‑> Any</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_option(self, key: str, default: Any = None) -&gt; Any:
    &#34;&#34;&#34;Get a thermodynamic option value.&#34;&#34;&#34;
    return self.opt.get(key, default)</code></pre>
</details>
<div class="desc"><p>Get a thermodynamic option value.</p></div>
</dd>
<dt id="pychnosz.ThermoSystem.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Get information about the current thermodynamic system.&#34;&#34;&#34;
    if not self._initialized:
        return {&#34;status&#34;: &#34;Not initialized&#34;}
    
    info = {
        &#34;status&#34;: &#34;Initialized&#34;,
        &#34;obigt_species&#34;: len(self.obigt) if self.obigt is not None else 0,
        &#34;elements&#34;: len(self.element) if self.element is not None else 0,
        &#34;berman_minerals&#34;: len(self.Berman) if self.Berman is not None else 0,
        &#34;buffers&#34;: len(self.buffer) if self.buffer is not None else 0,
        &#34;proteins&#34;: len(self.protein) if self.protein is not None else 0,
        &#34;stoich_species&#34;: len(self.stoich_formulas) if self.stoich_formulas is not None else 0,
        &#34;basis_species&#34;: len(self.basis) if self.basis is not None else 0,
        &#34;formed_species&#34;: len(self.species) if self.species is not None else 0,
        &#34;current_options&#34;: dict(self.opt)
    }
    return info</code></pre>
</details>
<div class="desc"><p>Get information about the current thermodynamic system.</p></div>
</dd>
<dt id="pychnosz.ThermoSystem.is_initialized"><code class="name flex">
<span>def <span class="ident">is_initialized</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_initialized(self) -&gt; bool:
    &#34;&#34;&#34;Check if the thermodynamic system is initialized.&#34;&#34;&#34;
    return self._initialized</code></pre>
</details>
<div class="desc"><p>Check if the thermodynamic system is initialized.</p></div>
</dd>
<dt id="pychnosz.ThermoSystem.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, messages: bool = True) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, messages: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Initialize/reset the thermodynamic system.

    This is equivalent to reset() in the R version, loading all
    the thermodynamic data and initializing the system.

    Parameters
    ----------
    messages : bool, default True
        Whether to print informational messages
    &#34;&#34;&#34;
    try:
        # Load core data files
        self._load_options(messages)
        self._load_element_data(messages)
        self._load_berman_data(messages)
        self._load_buffer_data(messages)
        self._load_protein_data(messages)
        self._load_stoich_data(messages)
        self._load_bdot_data(messages)
        self._load_refs_data(messages)

        # Initialize OBIGT database
        self._obigt_db = OBIGTDatabase()
        self.obigt = self._obigt_db.get_combined_data()

        # Reset system state
        self.basis = None
        self.species = None
        self.opar = {}

        self._initialized = True
        if messages:
            print(&#39;reset: thermodynamic system initialized&#39;)

    except Exception as e:
        raise RuntimeError(f&#34;Failed to initialize thermodynamic system: {e}&#34;)</code></pre>
</details>
<div class="desc"><p>Initialize/reset the thermodynamic system.</p>
<p>This is equivalent to reset() in the R version, loading all
the thermodynamic data and initializing the system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>messages</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Whether to print informational messages</dd>
</dl></div>
</dd>
<dt id="pychnosz.ThermoSystem.set_option"><code class="name flex">
<span>def <span class="ident">set_option</span></span>(<span>self, key: str, value: Any) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_option(self, key: str, value: Any) -&gt; None:
    &#34;&#34;&#34;Set a thermodynamic option value.&#34;&#34;&#34;
    self.opt[key] = value</code></pre>
</details>
<div class="desc"><p>Set a thermodynamic option value.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pychnosz.biomolecules" href="biomolecules/index.html">pychnosz.biomolecules</a></code></li>
<li><code><a title="pychnosz.core" href="core/index.html">pychnosz.core</a></code></li>
<li><code><a title="pychnosz.data" href="data/index.html">pychnosz.data</a></code></li>
<li><code><a title="pychnosz.fortran" href="fortran/index.html">pychnosz.fortran</a></code></li>
<li><code><a title="pychnosz.geochemistry" href="geochemistry/index.html">pychnosz.geochemistry</a></code></li>
<li><code><a title="pychnosz.models" href="models/index.html">pychnosz.models</a></code></li>
<li><code><a title="pychnosz.utils" href="utils/index.html">pychnosz.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pychnosz.Berman" href="#pychnosz.Berman">Berman</a></code></li>
<li><code><a title="pychnosz.G2logK" href="#pychnosz.G2logK">G2logK</a></code></li>
<li><code><a title="pychnosz.OBIGT2eos" href="#pychnosz.OBIGT2eos">OBIGT2eos</a></code></li>
<li><code><a title="pychnosz.ZC" href="#pychnosz.ZC">ZC</a></code></li>
<li><code><a title="pychnosz.add_OBIGT" href="#pychnosz.add_OBIGT">add_OBIGT</a></code></li>
<li><code><a title="pychnosz.add_legend" href="#pychnosz.add_legend">add_legend</a></code></li>
<li><code><a title="pychnosz.add_protein" href="#pychnosz.add_protein">add_protein</a></code></li>
<li><code><a title="pychnosz.affinity" href="#pychnosz.affinity">affinity</a></code></li>
<li><code><a title="pychnosz.animation" href="#pychnosz.animation">animation</a></code></li>
<li><code><a title="pychnosz.balance_reaction" href="#pychnosz.balance_reaction">balance_reaction</a></code></li>
<li><code><a title="pychnosz.basis" href="#pychnosz.basis">basis</a></code></li>
<li><code><a title="pychnosz.calc_G_TP" href="#pychnosz.calc_G_TP">calc_G_TP</a></code></li>
<li><code><a title="pychnosz.calc_logK" href="#pychnosz.calc_logK">calc_logK</a></code></li>
<li><code><a title="pychnosz.cgl" href="#pychnosz.cgl">cgl</a></code></li>
<li><code><a title="pychnosz.convert" href="#pychnosz.convert">convert</a></code></li>
<li><code><a title="pychnosz.copy_plot" href="#pychnosz.copy_plot">copy_plot</a></code></li>
<li><code><a title="pychnosz.describe_basis" href="#pychnosz.describe_basis">describe_basis</a></code></li>
<li><code><a title="pychnosz.describe_basis_html" href="#pychnosz.describe_basis_html">describe_basis_html</a></code></li>
<li><code><a title="pychnosz.describe_property" href="#pychnosz.describe_property">describe_property</a></code></li>
<li><code><a title="pychnosz.describe_property_html" href="#pychnosz.describe_property_html">describe_property_html</a></code></li>
<li><code><a title="pychnosz.diagram" href="#pychnosz.diagram">diagram</a></code></li>
<li><code><a title="pychnosz.diagram_interactive" href="#pychnosz.diagram_interactive">diagram_interactive</a></code></li>
<li><code><a title="pychnosz.dissrxn2logK" href="#pychnosz.dissrxn2logK">dissrxn2logK</a></code></li>
<li><code><a title="pychnosz.entropy" href="#pychnosz.entropy">entropy</a></code></li>
<li><code><a title="pychnosz.envert" href="#pychnosz.envert">envert</a></code></li>
<li><code><a title="pychnosz.equilibrate" href="#pychnosz.equilibrate">equilibrate</a></code></li>
<li><code><a title="pychnosz.expr_species" href="#pychnosz.expr_species">expr_species</a></code></li>
<li><code><a title="pychnosz.find_tp" href="#pychnosz.find_tp">find_tp</a></code></li>
<li><code><a title="pychnosz.format_reaction" href="#pychnosz.format_reaction">format_reaction</a></code></li>
<li><code><a title="pychnosz.get_formula_ox" href="#pychnosz.get_formula_ox">get_formula_ox</a></code></li>
<li><code><a title="pychnosz.get_n_element_ox" href="#pychnosz.get_n_element_ox">get_n_element_ox</a></code></li>
<li><code><a title="pychnosz.gfun" href="#pychnosz.gfun">gfun</a></code></li>
<li><code><a title="pychnosz.group_formulas" href="#pychnosz.group_formulas">group_formulas</a></code></li>
<li><code><a title="pychnosz.hkf" href="#pychnosz.hkf">hkf</a></code></li>
<li><code><a title="pychnosz.info" href="#pychnosz.info">info</a></code></li>
<li><code><a title="pychnosz.ionize_aa" href="#pychnosz.ionize_aa">ionize_aa</a></code></li>
<li><code><a title="pychnosz.list_OBIGT_files" href="#pychnosz.list_OBIGT_files">list_OBIGT_files</a></code></li>
<li><code><a title="pychnosz.load_WORM" href="#pychnosz.load_WORM">load_WORM</a></code></li>
<li><code><a title="pychnosz.makeup" href="#pychnosz.makeup">makeup</a></code></li>
<li><code><a title="pychnosz.mass" href="#pychnosz.mass">mass</a></code></li>
<li><code><a title="pychnosz.mod_OBIGT" href="#pychnosz.mod_OBIGT">mod_OBIGT</a></code></li>
<li><code><a title="pychnosz.pinfo" href="#pychnosz.pinfo">pinfo</a></code></li>
<li><code><a title="pychnosz.protein_OBIGT" href="#pychnosz.protein_OBIGT">protein_OBIGT</a></code></li>
<li><code><a title="pychnosz.protein_basis" href="#pychnosz.protein_basis">protein_basis</a></code></li>
<li><code><a title="pychnosz.protein_formula" href="#pychnosz.protein_formula">protein_formula</a></code></li>
<li><code><a title="pychnosz.protein_length" href="#pychnosz.protein_length">protein_length</a></code></li>
<li><code><a title="pychnosz.quartz_coesite" href="#pychnosz.quartz_coesite">quartz_coesite</a></code></li>
<li><code><a title="pychnosz.ratlab" href="#pychnosz.ratlab">ratlab</a></code></li>
<li><code><a title="pychnosz.ratlab_html" href="#pychnosz.ratlab_html">ratlab_html</a></code></li>
<li><code><a title="pychnosz.reset" href="#pychnosz.reset">reset</a></code></li>
<li><code><a title="pychnosz.reset_OBIGT" href="#pychnosz.reset_OBIGT">reset_OBIGT</a></code></li>
<li><code><a title="pychnosz.reset_WORM" href="#pychnosz.reset_WORM">reset_WORM</a></code></li>
<li><code><a title="pychnosz.retrieve" href="#pychnosz.retrieve">retrieve</a></code></li>
<li><code><a title="pychnosz.set_title" href="#pychnosz.set_title">set_title</a></code></li>
<li><code><a title="pychnosz.species" href="#pychnosz.species">species</a></code></li>
<li><code><a title="pychnosz.subcrt" href="#pychnosz.subcrt">subcrt</a></code></li>
<li><code><a title="pychnosz.syslab" href="#pychnosz.syslab">syslab</a></code></li>
<li><code><a title="pychnosz.syslab_html" href="#pychnosz.syslab_html">syslab_html</a></code></li>
<li><code><a title="pychnosz.thermo" href="#pychnosz.thermo">thermo</a></code></li>
<li><code><a title="pychnosz.unicurve" href="#pychnosz.unicurve">unicurve</a></code></li>
<li><code><a title="pychnosz.univariant_TP" href="#pychnosz.univariant_TP">univariant_TP</a></code></li>
<li><code><a title="pychnosz.water" href="#pychnosz.water">water</a></code></li>
<li><code><a title="pychnosz.water_lines" href="#pychnosz.water_lines">water_lines</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pychnosz.ThermoSystem" href="#pychnosz.ThermoSystem">ThermoSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="pychnosz.ThermoSystem.OBIGT" href="#pychnosz.ThermoSystem.OBIGT">OBIGT</a></code></li>
<li><code><a title="pychnosz.ThermoSystem.get_obigt_db" href="#pychnosz.ThermoSystem.get_obigt_db">get_obigt_db</a></code></li>
<li><code><a title="pychnosz.ThermoSystem.get_option" href="#pychnosz.ThermoSystem.get_option">get_option</a></code></li>
<li><code><a title="pychnosz.ThermoSystem.info" href="#pychnosz.ThermoSystem.info">info</a></code></li>
<li><code><a title="pychnosz.ThermoSystem.is_initialized" href="#pychnosz.ThermoSystem.is_initialized">is_initialized</a></code></li>
<li><code><a title="pychnosz.ThermoSystem.reset" href="#pychnosz.ThermoSystem.reset">reset</a></code></li>
<li><code><a title="pychnosz.ThermoSystem.set_option" href="#pychnosz.ThermoSystem.set_option">set_option</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
